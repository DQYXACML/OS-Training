
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000048ec memsz 0x000048ec flags r-x
    LOAD off    0x00006000 vaddr 0x00015000 paddr 0x00015000 align 2**12
         filesz 0x00000044 memsz 0x00025c38 flags rw-
    LOAD off    0x00007000 vaddr 0x80000000 paddr 0x0003ac38 align 2**12
         filesz 0x000001db memsz 0x000001db flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003da6  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .first_task   000001db  80000000  0003ac38  00007000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  2 .data         00000044  00015000  00015000  00006000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00024c38  00016000  00016000  00006044  2**12
                  ALLOC
  4 .debug_line   00002030  00000000  00000000  000071db  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000598e  00000000  00000000  0000920b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001700  00000000  00000000  0000eb99  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000220  00000000  00000000  000102a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .rodata       00000b2c  00013dc0  00013dc0  00004dc0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .debug_ranges 00000060  00000000  00000000  000104c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001575  00000000  00000000  00010520  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  00011a95  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00001760  00000000  00000000  00011aa8  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
80000000 l    d  .first_task	00000000 .first_task
00015000 l    d  .data	00000000 .data
00016000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00013dc0 l    d  .rodata	00000000 .rodata
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102f2 l     F .text	00000017 up2
00010309 l     F .text	0000000d down2
00010316 l     F .text	0000000c write_cr3
00010322 l     F .text	00000014 pde_index
00010336 l     F .text	00000027 pde_paddr
0001035d l     F .text	00000010 pte_index
0001036d l     F .text	00000027 pte_paddr
00010394 l     F .text	0000000f get_pte_perm
000103a3 l     F .text	00000011 mmu_set_page_dir
00018000 l     O .bss	00000028 paddr_alloc
00019000 l     O .bss	00001000 kernel_page_dir
000103b4 l     F .text	00000010 current_page_dir
000103c4 l     F .text	00000058 addr_alloc_init
0001041c l     F .text	00000067 addr_alloc_page
00010483 l     F .text	00000062 addr_free_page
000104e5 l     F .text	00000066 show_mem_info
0001054b l     F .text	0000003c total_mem_size
00013ef4 l     O .rodata	00000012 __func__.2248
00015000 l     O .data	00000040 kernel_map.2260
00013f08 l     O .rodata	00000013 __func__.2288
00013f1c l     O .rodata	00000011 __func__.2361
00013f30 l     O .rodata	0000000c __func__.2373
00000000 l    df *ABS*	00000000 syscall.c
00013f40 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010e64 l     F .text	0000001b list_node_init
00010e7f l     F .text	0000000b list_node_next
00010e8a l     F .text	0000000b list_count
00010e95 l     F .text	0000000a list_first
00010e9f l     F .text	0000000c write_cr3
00010eab l     F .text	00000007 hlt
00010eb2 l     F .text	0000000c write_tr
00010ebe l     F .text	00000011 mmu_set_page_dir
0001a000 l     O .bss	00001000 idle_task_stack
0001b000 l     O .bss	000001a8 task_manager
0001b1c0 l     O .bss	00005e00 task_table
00020fc0 l     O .bss	00000014 task_table_mutex
00010ecf l     F .text	00000198 tss_init
0001428c l     O .rodata	0000000a __func__.2372
00014298 l     O .rodata	00000010 __func__.2392
0001129f l     F .text	0000000a idle_task_entry
0001145d l     F .text	00000043 task_next_run
000116a3 l     F .text	00000069 alloc_task
0001170c l     F .text	00000030 free_task
00011952 l     F .text	00000129 load_phdr
000142a8 l     O .rodata	0000000a __func__.2487
00011a7b l     F .text	000001f4 load_elf_file
00011c6f l     F .text	00000130 copy_args
000142b4 l     O .rodata	0000000a __func__.2522
00000000 l    df *ABS*	00000000 cpu.c
00011fb1 l     F .text	00000028 lgdt
00011fd9 l     F .text	0000001a far_jump
00020fe0 l     O .bss	00000800 gdt_table
000217e0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
00012223 l     F .text	0000001d inb
00012240 l     F .text	0000001f outb
0001225f l     F .text	00000007 cli
00012266 l     F .text	00000007 sti
0001226d l     F .text	00000028 lidt
00012295 l     F .text	00000011 read_cr2
000122a6 l     F .text	00000007 hlt
000122ad l     F .text	00000010 read_eflags
000122bd l     F .text	0000000b write_eflags
00021800 l     O .bss	00000400 idt_table
000122c8 l     F .text	000000ff dump_core_regs
000123c7 l     F .text	0000004e do_default_handler
00012796 l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 time.c
00012b8d l     F .text	0000001f outb
00021c00 l     O .bss	00000004 sys_tick
00012bac l     F .text	00000060 init_pic
00000000 l    df *ABS*	00000000 fs.c
00012c4c l     F .text	0000001d inb
00012c69 l     F .text	0000001f inw
00012c88 l     F .text	0000001f outb
00021c20 l     O .bss	00019000 TEMP_ADDR
0003ac20 l     O .bss	00000004 temp_pos
00012ca7 l     F .text	0000012f read_disk
00000000 l    df *ABS*	00000000 init.c
00014888 l     O .rodata	00000013 __func__.2247
00000000 l    df *ABS*	00000000 mutex.c
00012f70 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000130fa l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
00013483 l     F .text	00000007 hlt
00015040 l     O .data	00000004 num2ch.1927
00000000 l    df *ABS*	00000000 list.c
00013a1b l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00013c13 l     F .text	0000001d inb
00013c30 l     F .text	0000001f outb
0003ac24 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 first_task.c
80000010 l     F .first_task	0000004c sys_call
8000005c l     F .first_task	0000002a msleep
80000086 l     F .first_task	0000001b getpid
800000a1 l     F .first_task	00000028 print_msg
800000c9 l     F .first_task	0000001b fork
800000e4 l     F .first_task	0000002d execve
0001337b g     F .text	0000003a bitmap_get_bit
000135fa g     F .text	0000004f kernel_memcpy
00012e7c g     F .text	0000000a sys_close
000113f2 g     F .text	0000000a task_current
00012b2e g     F .text	0000000b irq_enable_global
00013ab2 g     F .text	00000064 list_insert_last
00011f50 g     F .text	00000061 sys_yield
0001163f g     F .text	00000064 sys_msleep
00012549 g     F .text	0000001c do_handler_segment_not_present
00011393 g     F .text	00000034 task_set_ready
000133b5 g     F .text	0000001b bitmap_is_set
00013649 g     F .text	00000041 kernel_memset
00012e58 g     F .text	00000024 sys_lseek
00010274 g       .text	00000000 exception_handler_virtual_exception
00010dcf g     F .text	00000095 do_handler_syscall
000139ee g     F .text	0000002d strings_count
000121f2 g     F .text	0000001e cpu_init
00013c4f g     F .text	00000079 log_init
000117cf g     F .text	00000183 sys_fork
00012f1a g     F .text	00000056 init_main
00010219 g       .text	00000000 exception_handler_alignment_check
00012072 g     F .text	00000039 gdt_free_sel
00010db5 g     F .text	0000001a sys_print_msg
0001348a g     F .text	00000047 kernel_strcpy
00015000 g       .data	00000000 s_data
00012a11 g     F .text	0000008b irq_enable
00010035 g       .text	00000000 exception_handler_unknown
000100b1 g       .text	00000000 exception_handler_breakpoint
000124a1 g     F .text	0000001c do_handler_overflow
0001259d g     F .text	0000001c do_handler_alignment_check
00010637 g     F .text	0000008c memory_create_map
00012e0f g     F .text	0000003f sys_read
000101c0 g       .text	00000000 exception_handler_general_protection
0001260d g     F .text	000000b5 do_handler_general_protection
00013215 g     F .text	00000029 sem_count
80000111 g     F .first_task	000000ca first_task_main
00012431 g     F .text	0000001c do_handler_divider
000132a7 g     F .text	000000d4 bitmap_set_bit
00012511 g     F .text	0000001c do_handler_double_fault
000126c2 g     F .text	000000d4 do_handler_page_fault
0001014c g       .text	00000000 exception_handler_double_fault
00012b39 g     F .text	0000002b pic_send_eoi
00011295 g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
0001077e g     F .text	00000085 memory_create_uvm
00013128 g     F .text	0000006b sem_wait
00010caf g     F .text	00000022 memory_alloc_page_for
00012c0c g     F .text	00000028 do_handler_timer
000101a3 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
000125f1 g     F .text	0000001c do_handler_virtual_exception
000100d0 g       .text	00000000 exception_handler_overflow
000120ab g     F .text	00000075 get_alloc_desc
000102b2 g       .text	00000000 simple_switch
00016000 g     O .bss	00002000 stack
00010c16 g     F .text	00000099 memory_free_page
0003ac38 g       *ABS*	00000000 s_first_task
00011752 g     F .text	0000007d task_uninit
00010b30 g     F .text	000000cc memory_alloc_for_page_dir
000100ef g       .text	00000000 exception_handler_bound_range
00013193 g     F .text	00000082 sem_notify
00010aad g     F .text	00000083 memory_copy_uvm_data
000124d9 g     F .text	0000001c do_handler_invalid_opcode
00010169 g       .text	00000000 exception_handler_invalid_tss
00012581 g     F .text	0000001c do_handler_fpu_error
000111bf g     F .text	000000d6 task_first_init
000125b9 g     F .text	0000001c do_handler_machine_check
00012dd6 g     F .text	00000039 sys_open
0001244d g     F .text	0000001c do_handler_Debug
00013a53 g     F .text	0000005f list_insert_first
0001161f g     F .text	00000020 task_set_wakeup
00012469 g     F .text	0000001c do_handler_NMI
00010054 g       .text	00000000 exception_handler_divider
000134d1 g     F .text	00000070 kernel_strncpy
00012b23 g     F .text	0000000b irq_disable_global
000113fc g     F .text	00000061 sys_sched_yield
00012e4e g     F .text	0000000a sys_write
0003ae13 g       *ABS*	00000000 mem_free_start
00012e86 g     F .text	00000030 kernel_init
00013105 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00013827 g     F .text	0000014b kernel_vsprintf
000139a8 g     F .text	00000046 get_file_name
0001012d g       .text	00000000 exception_handler_device_unavailable
0001010e g       .text	00000000 exception_handler_invalid_opcode
0003ac38 g       .bss	00000000 e_data
00012fa9 g     F .text	00000094 mutex_lock
00010236 g       .text	00000000 exception_handler_machine_check
0001252d g     F .text	0000001c do_handler_invalid_tss
00000000 g       *ABS*	00000000 kernel_base
0003ae13 g       *ABS*	00000000 e_first_task
000115e5 g     F .text	0000003a task_set_sleep
00013972 g     F .text	00000036 panic
00010293 g       .text	00000000 exception_handler_timer
000129d7 g     F .text	0000003a irq_install
00012120 g     F .text	0000008b init_gdt
00012b64 g     F .text	00000018 irq_enter_protection
00012f7b g     F .text	0000002e mutex_init
00012a9c g     F .text	00000087 irq_disable
00010255 g       .text	00000000 exception_handler_smd_exception
00010803 g     F .text	0000010f memory_destroy_uvm
0001323e g     F .text	00000016 bitmap_byte_count
000124f5 g     F .text	0000001c do_handler_device_unavailable
000114a0 g     F .text	0000005b task_dispatch
00010912 g     F .text	00000155 memory_copy_uvm
00012eb6 g     F .text	00000064 move_to_first_task
00012210 g     F .text	00000013 switch_to_tss
0001368a g     F .text	0000005e kernel_memcmp
000106c3 g     F .text	000000bb create_kernel_table
00013a2e g     F .text	00000025 list_init
000125d5 g     F .text	0000001c do_handler_smd_exception
000101dd g       .text	00000000 exception_handler_page_fault
000113c7 g     F .text	0000002b task_set_block
00012415 g     F .text	0000001c do_handler_unknown
00010bfc g     F .text	0000001a memory_alloc_page
000101fa g       .text	00000000 exception_handler_fpu_error
00011174 g     F .text	0000001e task_switch_from_to
00012829 g     F .text	000001ae irq_init
0001303d g     F .text	000000bd mutex_unlock
00012b7c g     F .text	00000011 irq_leave_protection
000135bf g     F .text	0000003b kernel_strlen
00011ff3 g     F .text	0000007f segment_desc_set
000124bd g     F .text	0000001c do_handler_bound_range
000102c7 g       .text	00000000 exception_handler_syscall
00013b16 g     F .text	00000078 list_remove_first
000148ec g       .rodata	00000000 e_text
00013541 g     F .text	0000007e kernel_strncmp
00013254 g     F .text	00000053 bitmap_init
00010186 g       .text	00000000 exception_handler_segment_not_present
00010092 g       .text	00000000 exception_handler_NMI
000133d0 g     F .text	000000b3 bitmap_alloc_nbits
000112a9 g     F .text	000000ea task_manager_init
00011192 g     F .text	0000002d task_start
00010073 g       .text	00000000 exception_handler_Debug
000114fb g     F .text	000000ea task_time_tick
00010cd1 g     F .text	000000e4 memory_init
00011d9f g     F .text	000001b1 sys_execve
00010a67 g     F .text	00000046 memory_get_paddr
00012565 g     F .text	0000001c do_handler_stack_segment_fault
00012485 g     F .text	0000001c do_handler_breakpoint
00013cc8 g     F .text	000000de log_printf
00011067 g     F .text	0000010d task_init
0001173c g     F .text	00000016 sys_getpid
000136e8 g     F .text	0000013f kernel_itoa
00013b8e g     F .text	00000085 list_remove
000121ab g     F .text	00000047 gate_desc_set
00010587 g     F .text	000000b0 find_pte
00012c34 g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .extern kernel_init
    .extern init_main
    .global _start
    # void start (boot_info_t *boot_info)
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax
    # kernel_init(boot_info)
    push %eax
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 7a 2e 00 00       	call   12e86 <kernel_init>
    jmp $KERNEL_SELECTOR_CS, $gdt_reload # 重新加载GDT
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs

    ; mov $stack, %eax
   10021:	b8 00 60 01 00       	mov    $0x16000,%eax
    ; mov $KERNEL_STACK_SIZE, %ebx
   10026:	bb 00 20 00 00       	mov    $0x2000,%ebx

    mov $(stack + KERNEL_STACK_SIZE), %esp
   1002b:	bc 00 80 01 00       	mov    $0x18000,%esp
    jmp init_main
   10030:	e9 e5 2e 00 00       	jmp    12f1a <init_main>

00010035 <exception_handler_unknown>:
    add $(2*4), %esp

    iret
.endm

exception_handler unknown, -1, 0
   10035:	6a 00                	push   $0x0
   10037:	6a ff                	push   $0xffffffff
   10039:	60                   	pusha  
   1003a:	1e                   	push   %ds
   1003b:	06                   	push   %es
   1003c:	0f a0                	push   %fs
   1003e:	0f a8                	push   %gs
   10040:	54                   	push   %esp
   10041:	e8 cf 23 00 00       	call   12415 <do_handler_unknown>
   10046:	83 c4 04             	add    $0x4,%esp
   10049:	0f a9                	pop    %gs
   1004b:	0f a1                	pop    %fs
   1004d:	07                   	pop    %es
   1004e:	1f                   	pop    %ds
   1004f:	61                   	popa   
   10050:	83 c4 08             	add    $0x8,%esp
   10053:	cf                   	iret   

00010054 <exception_handler_divider>:
exception_handler divider, 0, 0
   10054:	6a 00                	push   $0x0
   10056:	6a 00                	push   $0x0
   10058:	60                   	pusha  
   10059:	1e                   	push   %ds
   1005a:	06                   	push   %es
   1005b:	0f a0                	push   %fs
   1005d:	0f a8                	push   %gs
   1005f:	54                   	push   %esp
   10060:	e8 cc 23 00 00       	call   12431 <do_handler_divider>
   10065:	83 c4 04             	add    $0x4,%esp
   10068:	0f a9                	pop    %gs
   1006a:	0f a1                	pop    %fs
   1006c:	07                   	pop    %es
   1006d:	1f                   	pop    %ds
   1006e:	61                   	popa   
   1006f:	83 c4 08             	add    $0x8,%esp
   10072:	cf                   	iret   

00010073 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10073:	6a 00                	push   $0x0
   10075:	6a 01                	push   $0x1
   10077:	60                   	pusha  
   10078:	1e                   	push   %ds
   10079:	06                   	push   %es
   1007a:	0f a0                	push   %fs
   1007c:	0f a8                	push   %gs
   1007e:	54                   	push   %esp
   1007f:	e8 c9 23 00 00       	call   1244d <do_handler_Debug>
   10084:	83 c4 04             	add    $0x4,%esp
   10087:	0f a9                	pop    %gs
   10089:	0f a1                	pop    %fs
   1008b:	07                   	pop    %es
   1008c:	1f                   	pop    %ds
   1008d:	61                   	popa   
   1008e:	83 c4 08             	add    $0x8,%esp
   10091:	cf                   	iret   

00010092 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10092:	6a 00                	push   $0x0
   10094:	6a 02                	push   $0x2
   10096:	60                   	pusha  
   10097:	1e                   	push   %ds
   10098:	06                   	push   %es
   10099:	0f a0                	push   %fs
   1009b:	0f a8                	push   %gs
   1009d:	54                   	push   %esp
   1009e:	e8 c6 23 00 00       	call   12469 <do_handler_NMI>
   100a3:	83 c4 04             	add    $0x4,%esp
   100a6:	0f a9                	pop    %gs
   100a8:	0f a1                	pop    %fs
   100aa:	07                   	pop    %es
   100ab:	1f                   	pop    %ds
   100ac:	61                   	popa   
   100ad:	83 c4 08             	add    $0x8,%esp
   100b0:	cf                   	iret   

000100b1 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100b1:	6a 00                	push   $0x0
   100b3:	6a 03                	push   $0x3
   100b5:	60                   	pusha  
   100b6:	1e                   	push   %ds
   100b7:	06                   	push   %es
   100b8:	0f a0                	push   %fs
   100ba:	0f a8                	push   %gs
   100bc:	54                   	push   %esp
   100bd:	e8 c3 23 00 00       	call   12485 <do_handler_breakpoint>
   100c2:	83 c4 04             	add    $0x4,%esp
   100c5:	0f a9                	pop    %gs
   100c7:	0f a1                	pop    %fs
   100c9:	07                   	pop    %es
   100ca:	1f                   	pop    %ds
   100cb:	61                   	popa   
   100cc:	83 c4 08             	add    $0x8,%esp
   100cf:	cf                   	iret   

000100d0 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100d0:	6a 00                	push   $0x0
   100d2:	6a 04                	push   $0x4
   100d4:	60                   	pusha  
   100d5:	1e                   	push   %ds
   100d6:	06                   	push   %es
   100d7:	0f a0                	push   %fs
   100d9:	0f a8                	push   %gs
   100db:	54                   	push   %esp
   100dc:	e8 c0 23 00 00       	call   124a1 <do_handler_overflow>
   100e1:	83 c4 04             	add    $0x4,%esp
   100e4:	0f a9                	pop    %gs
   100e6:	0f a1                	pop    %fs
   100e8:	07                   	pop    %es
   100e9:	1f                   	pop    %ds
   100ea:	61                   	popa   
   100eb:	83 c4 08             	add    $0x8,%esp
   100ee:	cf                   	iret   

000100ef <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100ef:	6a 00                	push   $0x0
   100f1:	6a 05                	push   $0x5
   100f3:	60                   	pusha  
   100f4:	1e                   	push   %ds
   100f5:	06                   	push   %es
   100f6:	0f a0                	push   %fs
   100f8:	0f a8                	push   %gs
   100fa:	54                   	push   %esp
   100fb:	e8 bd 23 00 00       	call   124bd <do_handler_bound_range>
   10100:	83 c4 04             	add    $0x4,%esp
   10103:	0f a9                	pop    %gs
   10105:	0f a1                	pop    %fs
   10107:	07                   	pop    %es
   10108:	1f                   	pop    %ds
   10109:	61                   	popa   
   1010a:	83 c4 08             	add    $0x8,%esp
   1010d:	cf                   	iret   

0001010e <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   1010e:	6a 00                	push   $0x0
   10110:	6a 06                	push   $0x6
   10112:	60                   	pusha  
   10113:	1e                   	push   %ds
   10114:	06                   	push   %es
   10115:	0f a0                	push   %fs
   10117:	0f a8                	push   %gs
   10119:	54                   	push   %esp
   1011a:	e8 ba 23 00 00       	call   124d9 <do_handler_invalid_opcode>
   1011f:	83 c4 04             	add    $0x4,%esp
   10122:	0f a9                	pop    %gs
   10124:	0f a1                	pop    %fs
   10126:	07                   	pop    %es
   10127:	1f                   	pop    %ds
   10128:	61                   	popa   
   10129:	83 c4 08             	add    $0x8,%esp
   1012c:	cf                   	iret   

0001012d <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   1012d:	6a 00                	push   $0x0
   1012f:	6a 07                	push   $0x7
   10131:	60                   	pusha  
   10132:	1e                   	push   %ds
   10133:	06                   	push   %es
   10134:	0f a0                	push   %fs
   10136:	0f a8                	push   %gs
   10138:	54                   	push   %esp
   10139:	e8 b7 23 00 00       	call   124f5 <do_handler_device_unavailable>
   1013e:	83 c4 04             	add    $0x4,%esp
   10141:	0f a9                	pop    %gs
   10143:	0f a1                	pop    %fs
   10145:	07                   	pop    %es
   10146:	1f                   	pop    %ds
   10147:	61                   	popa   
   10148:	83 c4 08             	add    $0x8,%esp
   1014b:	cf                   	iret   

0001014c <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   1014c:	6a 08                	push   $0x8
   1014e:	60                   	pusha  
   1014f:	1e                   	push   %ds
   10150:	06                   	push   %es
   10151:	0f a0                	push   %fs
   10153:	0f a8                	push   %gs
   10155:	54                   	push   %esp
   10156:	e8 b6 23 00 00       	call   12511 <do_handler_double_fault>
   1015b:	83 c4 04             	add    $0x4,%esp
   1015e:	0f a9                	pop    %gs
   10160:	0f a1                	pop    %fs
   10162:	07                   	pop    %es
   10163:	1f                   	pop    %ds
   10164:	61                   	popa   
   10165:	83 c4 08             	add    $0x8,%esp
   10168:	cf                   	iret   

00010169 <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   10169:	6a 0a                	push   $0xa
   1016b:	60                   	pusha  
   1016c:	1e                   	push   %ds
   1016d:	06                   	push   %es
   1016e:	0f a0                	push   %fs
   10170:	0f a8                	push   %gs
   10172:	54                   	push   %esp
   10173:	e8 b5 23 00 00       	call   1252d <do_handler_invalid_tss>
   10178:	83 c4 04             	add    $0x4,%esp
   1017b:	0f a9                	pop    %gs
   1017d:	0f a1                	pop    %fs
   1017f:	07                   	pop    %es
   10180:	1f                   	pop    %ds
   10181:	61                   	popa   
   10182:	83 c4 08             	add    $0x8,%esp
   10185:	cf                   	iret   

00010186 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10186:	6a 0b                	push   $0xb
   10188:	60                   	pusha  
   10189:	1e                   	push   %ds
   1018a:	06                   	push   %es
   1018b:	0f a0                	push   %fs
   1018d:	0f a8                	push   %gs
   1018f:	54                   	push   %esp
   10190:	e8 b4 23 00 00       	call   12549 <do_handler_segment_not_present>
   10195:	83 c4 04             	add    $0x4,%esp
   10198:	0f a9                	pop    %gs
   1019a:	0f a1                	pop    %fs
   1019c:	07                   	pop    %es
   1019d:	1f                   	pop    %ds
   1019e:	61                   	popa   
   1019f:	83 c4 08             	add    $0x8,%esp
   101a2:	cf                   	iret   

000101a3 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   101a3:	6a 0c                	push   $0xc
   101a5:	60                   	pusha  
   101a6:	1e                   	push   %ds
   101a7:	06                   	push   %es
   101a8:	0f a0                	push   %fs
   101aa:	0f a8                	push   %gs
   101ac:	54                   	push   %esp
   101ad:	e8 b3 23 00 00       	call   12565 <do_handler_stack_segment_fault>
   101b2:	83 c4 04             	add    $0x4,%esp
   101b5:	0f a9                	pop    %gs
   101b7:	0f a1                	pop    %fs
   101b9:	07                   	pop    %es
   101ba:	1f                   	pop    %ds
   101bb:	61                   	popa   
   101bc:	83 c4 08             	add    $0x8,%esp
   101bf:	cf                   	iret   

000101c0 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101c0:	6a 0d                	push   $0xd
   101c2:	60                   	pusha  
   101c3:	1e                   	push   %ds
   101c4:	06                   	push   %es
   101c5:	0f a0                	push   %fs
   101c7:	0f a8                	push   %gs
   101c9:	54                   	push   %esp
   101ca:	e8 3e 24 00 00       	call   1260d <do_handler_general_protection>
   101cf:	83 c4 04             	add    $0x4,%esp
   101d2:	0f a9                	pop    %gs
   101d4:	0f a1                	pop    %fs
   101d6:	07                   	pop    %es
   101d7:	1f                   	pop    %ds
   101d8:	61                   	popa   
   101d9:	83 c4 08             	add    $0x8,%esp
   101dc:	cf                   	iret   

000101dd <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101dd:	6a 0e                	push   $0xe
   101df:	60                   	pusha  
   101e0:	1e                   	push   %ds
   101e1:	06                   	push   %es
   101e2:	0f a0                	push   %fs
   101e4:	0f a8                	push   %gs
   101e6:	54                   	push   %esp
   101e7:	e8 d6 24 00 00       	call   126c2 <do_handler_page_fault>
   101ec:	83 c4 04             	add    $0x4,%esp
   101ef:	0f a9                	pop    %gs
   101f1:	0f a1                	pop    %fs
   101f3:	07                   	pop    %es
   101f4:	1f                   	pop    %ds
   101f5:	61                   	popa   
   101f6:	83 c4 08             	add    $0x8,%esp
   101f9:	cf                   	iret   

000101fa <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101fa:	6a 00                	push   $0x0
   101fc:	6a 10                	push   $0x10
   101fe:	60                   	pusha  
   101ff:	1e                   	push   %ds
   10200:	06                   	push   %es
   10201:	0f a0                	push   %fs
   10203:	0f a8                	push   %gs
   10205:	54                   	push   %esp
   10206:	e8 76 23 00 00       	call   12581 <do_handler_fpu_error>
   1020b:	83 c4 04             	add    $0x4,%esp
   1020e:	0f a9                	pop    %gs
   10210:	0f a1                	pop    %fs
   10212:	07                   	pop    %es
   10213:	1f                   	pop    %ds
   10214:	61                   	popa   
   10215:	83 c4 08             	add    $0x8,%esp
   10218:	cf                   	iret   

00010219 <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   10219:	6a 11                	push   $0x11
   1021b:	60                   	pusha  
   1021c:	1e                   	push   %ds
   1021d:	06                   	push   %es
   1021e:	0f a0                	push   %fs
   10220:	0f a8                	push   %gs
   10222:	54                   	push   %esp
   10223:	e8 75 23 00 00       	call   1259d <do_handler_alignment_check>
   10228:	83 c4 04             	add    $0x4,%esp
   1022b:	0f a9                	pop    %gs
   1022d:	0f a1                	pop    %fs
   1022f:	07                   	pop    %es
   10230:	1f                   	pop    %ds
   10231:	61                   	popa   
   10232:	83 c4 08             	add    $0x8,%esp
   10235:	cf                   	iret   

00010236 <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   10236:	6a 00                	push   $0x0
   10238:	6a 12                	push   $0x12
   1023a:	60                   	pusha  
   1023b:	1e                   	push   %ds
   1023c:	06                   	push   %es
   1023d:	0f a0                	push   %fs
   1023f:	0f a8                	push   %gs
   10241:	54                   	push   %esp
   10242:	e8 72 23 00 00       	call   125b9 <do_handler_machine_check>
   10247:	83 c4 04             	add    $0x4,%esp
   1024a:	0f a9                	pop    %gs
   1024c:	0f a1                	pop    %fs
   1024e:	07                   	pop    %es
   1024f:	1f                   	pop    %ds
   10250:	61                   	popa   
   10251:	83 c4 08             	add    $0x8,%esp
   10254:	cf                   	iret   

00010255 <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   10255:	6a 00                	push   $0x0
   10257:	6a 13                	push   $0x13
   10259:	60                   	pusha  
   1025a:	1e                   	push   %ds
   1025b:	06                   	push   %es
   1025c:	0f a0                	push   %fs
   1025e:	0f a8                	push   %gs
   10260:	54                   	push   %esp
   10261:	e8 6f 23 00 00       	call   125d5 <do_handler_smd_exception>
   10266:	83 c4 04             	add    $0x4,%esp
   10269:	0f a9                	pop    %gs
   1026b:	0f a1                	pop    %fs
   1026d:	07                   	pop    %es
   1026e:	1f                   	pop    %ds
   1026f:	61                   	popa   
   10270:	83 c4 08             	add    $0x8,%esp
   10273:	cf                   	iret   

00010274 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10274:	6a 00                	push   $0x0
   10276:	6a 14                	push   $0x14
   10278:	60                   	pusha  
   10279:	1e                   	push   %ds
   1027a:	06                   	push   %es
   1027b:	0f a0                	push   %fs
   1027d:	0f a8                	push   %gs
   1027f:	54                   	push   %esp
   10280:	e8 6c 23 00 00       	call   125f1 <do_handler_virtual_exception>
   10285:	83 c4 04             	add    $0x4,%esp
   10288:	0f a9                	pop    %gs
   1028a:	0f a1                	pop    %fs
   1028c:	07                   	pop    %es
   1028d:	1f                   	pop    %ds
   1028e:	61                   	popa   
   1028f:	83 c4 08             	add    $0x8,%esp
   10292:	cf                   	iret   

00010293 <exception_handler_timer>:

# 硬件中断
exception_handler timer, 0x20, 0
   10293:	6a 00                	push   $0x0
   10295:	6a 20                	push   $0x20
   10297:	60                   	pusha  
   10298:	1e                   	push   %ds
   10299:	06                   	push   %es
   1029a:	0f a0                	push   %fs
   1029c:	0f a8                	push   %gs
   1029e:	54                   	push   %esp
   1029f:	e8 68 29 00 00       	call   12c0c <do_handler_timer>
   102a4:	83 c4 04             	add    $0x4,%esp
   102a7:	0f a9                	pop    %gs
   102a9:	0f a1                	pop    %fs
   102ab:	07                   	pop    %es
   102ac:	1f                   	pop    %ds
   102ad:	61                   	popa   
   102ae:	83 c4 08             	add    $0x8,%esp
   102b1:	cf                   	iret   

000102b2 <simple_switch>:
// esp不用保存，只需要让esp保存在调用之前的状态
// eflags ?
    .text
    .global simple_switch
simple_switch:
    movl 4(%esp), %eax   // 取from->stack
   102b2:	8b 44 24 04          	mov    0x4(%esp),%eax
	movl 8(%esp), %edx   // 取to->stack
   102b6:	8b 54 24 08          	mov    0x8(%esp),%edx

	// 保存前一任务的状态
	push %ebp
   102ba:	55                   	push   %ebp
	push %ebx
   102bb:	53                   	push   %ebx
	push %esi
   102bc:	56                   	push   %esi
	push %edi
   102bd:	57                   	push   %edi

	// 切换栈
	mov %esp, (%eax)    // from->stack = esp
   102be:	89 20                	mov    %esp,(%eax)
  	mov %edx, %esp      // esp = to->stack
   102c0:	89 d4                	mov    %edx,%esp

	// 加载下一任务的栈
	pop %edi
   102c2:	5f                   	pop    %edi
	pop %esi
   102c3:	5e                   	pop    %esi
	pop %ebx
   102c4:	5b                   	pop    %ebx
	pop %ebp
   102c5:	5d                   	pop    %ebp
  	ret
   102c6:	c3                   	ret    

000102c7 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    # 保存前一任务的状态
	pusha
   102c7:	60                   	pusha  
	push %ds
   102c8:	1e                   	push   %ds
	push %es
   102c9:	06                   	push   %es
	push %fs
   102ca:	0f a0                	push   %fs
	push %gs
   102cc:	0f a8                	push   %gs
	pushf
   102ce:	9c                   	pushf  

    # 使用内核段寄存器，避免使用应用层的
	mov $(KERNEL_SELECTOR_DS), %eax
   102cf:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
   102d4:	8e d8                	mov    %eax,%ds
	mov %eax, %es
   102d6:	8e c0                	mov    %eax,%es
	mov %eax, %fs
   102d8:	8e e0                	mov    %eax,%fs
	mov %eax, %gs
   102da:	8e e8                	mov    %eax,%gs

    # 调用处理函数
    mov %esp, %eax
   102dc:	89 e0                	mov    %esp,%eax
    push %eax
   102de:	50                   	push   %eax
	call do_handler_syscall
   102df:	e8 eb 0a 00 00       	call   10dcf <do_handler_syscall>
	add $4, %esp
   102e4:	83 c4 04             	add    $0x4,%esp

    # 再切换回来
	popf
   102e7:	9d                   	popf   
	pop %gs
   102e8:	0f a9                	pop    %gs
	pop %fs
   102ea:	0f a1                	pop    %fs
	pop %es
   102ec:	07                   	pop    %es
	pop %ds
   102ed:	1f                   	pop    %ds
	popa
   102ee:	61                   	popa   
   102ef:	ca 14 00             	lret   $0x14

000102f2 <up2>:
#include "comm/types.h"
#include <stdarg.h>

// 向上对齐到页边界
static inline uint32_t up2(uint32_t size, uint32_t bound)
{
   102f2:	55                   	push   %ebp
   102f3:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   102f5:	8b 55 08             	mov    0x8(%ebp),%edx
   102f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   102fb:	01 d0                	add    %edx,%eax
   102fd:	8d 50 ff             	lea    -0x1(%eax),%edx
   10300:	8b 45 0c             	mov    0xc(%ebp),%eax
   10303:	f7 d8                	neg    %eax
   10305:	21 d0                	and    %edx,%eax
}
   10307:	5d                   	pop    %ebp
   10308:	c3                   	ret    

00010309 <down2>:
// size = 0x1010 bound = 0x1000
// bound - 1 = 0x0FFF
// ~(bound-1) = 0xFFFF1000
// size & ~(bound-1) =  0x1010 & 0xFFFF1000 = 0x1000
static inline uint32_t down2(uint32_t size, uint32_t bound)
{
   10309:	55                   	push   %ebp
   1030a:	89 e5                	mov    %esp,%ebp
    return size & ~(bound - 1);
   1030c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1030f:	f7 d8                	neg    %eax
   10311:	23 45 08             	and    0x8(%ebp),%eax
}
   10314:	5d                   	pop    %ebp
   10315:	c3                   	ret    

00010316 <write_cr3>:
    __asm__ __volatile__("mov %%cr3, %[v]" : [v] "=r"(cr3));
    return cr3;
}

static inline void write_cr3(uint32_t v)
{
   10316:	55                   	push   %ebp
   10317:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3" ::[v] "r"(v));
   10319:	8b 45 08             	mov    0x8(%ebp),%eax
   1031c:	0f 22 d8             	mov    %eax,%cr3
}
   1031f:	90                   	nop
   10320:	5d                   	pop    %ebp
   10321:	c3                   	ret    

00010322 <pde_index>:

/**
 * @brief 返回vaddr在页目录中的索引
 */
static inline uint32_t pde_index(uint32_t vaddr)
{
   10322:	55                   	push   %ebp
   10323:	89 e5                	mov    %esp,%ebp
   10325:	83 ec 10             	sub    $0x10,%esp
    int index = (vaddr >> 22); // 只取高10位
   10328:	8b 45 08             	mov    0x8(%ebp),%eax
   1032b:	c1 e8 16             	shr    $0x16,%eax
   1032e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return index;
   10331:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10334:	c9                   	leave  
   10335:	c3                   	ret    

00010336 <pde_paddr>:

/**
 * @brief 获取pde中地址
 */
static inline uint32_t pde_paddr(pde_t *pde)
{
   10336:	55                   	push   %ebp
   10337:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   10339:	8b 45 08             	mov    0x8(%ebp),%eax
   1033c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10340:	c0 ea 04             	shr    $0x4,%dl
   10343:	0f b6 d2             	movzbl %dl,%edx
   10346:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   1034a:	c1 e1 04             	shl    $0x4,%ecx
   1034d:	09 ca                	or     %ecx,%edx
   1034f:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   10353:	c1 e0 0c             	shl    $0xc,%eax
   10356:	09 d0                	or     %edx,%eax
   10358:	c1 e0 0c             	shl    $0xc,%eax
}
   1035b:	5d                   	pop    %ebp
   1035c:	c3                   	ret    

0001035d <pte_index>:

/**
 * @brief 返回vaddr在页表中的索引
 */
static inline int pte_index(uint32_t vaddr)
{
   1035d:	55                   	push   %ebp
   1035e:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12) & 0x3FF; // 取中间10位
   10360:	8b 45 08             	mov    0x8(%ebp),%eax
   10363:	c1 e8 0c             	shr    $0xc,%eax
   10366:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   1036b:	5d                   	pop    %ebp
   1036c:	c3                   	ret    

0001036d <pte_paddr>:

/**
 * @brief 获取pte中的物理地址
 */
static inline uint32_t pte_paddr(pte_t *pte)
{
   1036d:	55                   	push   %ebp
   1036e:	89 e5                	mov    %esp,%ebp
    return pte->phy_page_addr << 12;
   10370:	8b 45 08             	mov    0x8(%ebp),%eax
   10373:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10377:	c0 ea 04             	shr    $0x4,%dl
   1037a:	0f b6 d2             	movzbl %dl,%edx
   1037d:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   10381:	c1 e1 04             	shl    $0x4,%ecx
   10384:	09 ca                	or     %ecx,%edx
   10386:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1038a:	c1 e0 0c             	shl    $0xc,%eax
   1038d:	09 d0                	or     %edx,%eax
   1038f:	c1 e0 0c             	shl    $0xc,%eax
}
   10392:	5d                   	pop    %ebp
   10393:	c3                   	ret    

00010394 <get_pte_perm>:

/**
 * @brief 获取pte中的权限位
 */
static inline uint32_t get_pte_perm(pte_t *pte)
{
   10394:	55                   	push   %ebp
   10395:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   10397:	8b 45 08             	mov    0x8(%ebp),%eax
   1039a:	8b 00                	mov    (%eax),%eax
   1039c:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103a1:	5d                   	pop    %ebp
   103a2:	c3                   	ret    

000103a3 <mmu_set_page_dir>:
/**
 * @brief 重新加载整个页表至cr3高20位寄存器
 * @param vaddr 页表的虚拟地址
 */
static inline void mmu_set_page_dir(uint32_t paddr)
{
   103a3:	55                   	push   %ebp
   103a4:	89 e5                	mov    %esp,%ebp
    // 将虚拟地址转换为物理地址
    write_cr3(paddr);
   103a6:	ff 75 08             	pushl  0x8(%ebp)
   103a9:	e8 68 ff ff ff       	call   10316 <write_cr3>
   103ae:	83 c4 04             	add    $0x4,%esp
}
   103b1:	90                   	nop
   103b2:	c9                   	leave  
   103b3:	c3                   	ret    

000103b4 <current_page_dir>:

/**
 * @brief 获取当前页表地址
 */
static pde_t *current_page_dir(void)
{
   103b4:	55                   	push   %ebp
   103b5:	89 e5                	mov    %esp,%ebp
   103b7:	83 ec 08             	sub    $0x8,%esp
    return (pde_t *)task_current()->tss.cr3;
   103ba:	e8 33 10 00 00       	call   113f2 <task_current>
   103bf:	8b 40 6c             	mov    0x6c(%eax),%eax
}
   103c2:	c9                   	leave  
   103c3:	c3                   	ret    

000103c4 <addr_alloc_init>:
 * @brief 初始化地址分配结构
 * 以下不检查start和size的页边界，由上层调用者检查
 */
static void addr_alloc_init(addr_alloc_t *alloc, uint8_t *bits,
                            uint32_t start, uint32_t size, uint32_t page_size)
{
   103c4:	55                   	push   %ebp
   103c5:	89 e5                	mov    %esp,%ebp
   103c7:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&alloc->mutex);
   103ca:	8b 45 08             	mov    0x8(%ebp),%eax
   103cd:	83 ec 0c             	sub    $0xc,%esp
   103d0:	50                   	push   %eax
   103d1:	e8 a5 2b 00 00       	call   12f7b <mutex_init>
   103d6:	83 c4 10             	add    $0x10,%esp
    alloc->start = start;
   103d9:	8b 45 08             	mov    0x8(%ebp),%eax
   103dc:	8b 55 10             	mov    0x10(%ebp),%edx
   103df:	89 50 20             	mov    %edx,0x20(%eax)
    alloc->size = size;
   103e2:	8b 45 08             	mov    0x8(%ebp),%eax
   103e5:	8b 55 14             	mov    0x14(%ebp),%edx
   103e8:	89 50 24             	mov    %edx,0x24(%eax)
    alloc->page_size = page_size;
   103eb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ee:	8b 55 18             	mov    0x18(%ebp),%edx
   103f1:	89 50 1c             	mov    %edx,0x1c(%eax)
    bitmap_init(&alloc->bitmap, bits, alloc->size / page_size, 0);
   103f4:	8b 45 08             	mov    0x8(%ebp),%eax
   103f7:	8b 40 24             	mov    0x24(%eax),%eax
   103fa:	ba 00 00 00 00       	mov    $0x0,%edx
   103ff:	f7 75 18             	divl   0x18(%ebp)
   10402:	89 c2                	mov    %eax,%edx
   10404:	8b 45 08             	mov    0x8(%ebp),%eax
   10407:	83 c0 14             	add    $0x14,%eax
   1040a:	6a 00                	push   $0x0
   1040c:	52                   	push   %edx
   1040d:	ff 75 0c             	pushl  0xc(%ebp)
   10410:	50                   	push   %eax
   10411:	e8 3e 2e 00 00       	call   13254 <bitmap_init>
   10416:	83 c4 10             	add    $0x10,%esp
}
   10419:	90                   	nop
   1041a:	c9                   	leave  
   1041b:	c3                   	ret    

0001041c <addr_alloc_page>:

/**
 * @brief 分配多页内存
 */
static uint32_t addr_alloc_page(addr_alloc_t *alloc, int page_count)
{
   1041c:	55                   	push   %ebp
   1041d:	89 e5                	mov    %esp,%ebp
   1041f:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = 0;
   10422:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&alloc->mutex);
   10429:	8b 45 08             	mov    0x8(%ebp),%eax
   1042c:	83 ec 0c             	sub    $0xc,%esp
   1042f:	50                   	push   %eax
   10430:	e8 74 2b 00 00       	call   12fa9 <mutex_lock>
   10435:	83 c4 10             	add    $0x10,%esp

    int page_index = bitmap_alloc_nbits(&alloc->bitmap, 0, page_count);
   10438:	8b 45 08             	mov    0x8(%ebp),%eax
   1043b:	83 c0 14             	add    $0x14,%eax
   1043e:	83 ec 04             	sub    $0x4,%esp
   10441:	ff 75 0c             	pushl  0xc(%ebp)
   10444:	6a 00                	push   $0x0
   10446:	50                   	push   %eax
   10447:	e8 84 2f 00 00       	call   133d0 <bitmap_alloc_nbits>
   1044c:	83 c4 10             	add    $0x10,%esp
   1044f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_index >= 0)
   10452:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10456:	78 17                	js     1046f <addr_alloc_page+0x53>
    {
        addr = alloc->start + page_index * alloc->page_size;
   10458:	8b 45 08             	mov    0x8(%ebp),%eax
   1045b:	8b 50 20             	mov    0x20(%eax),%edx
   1045e:	8b 45 08             	mov    0x8(%ebp),%eax
   10461:	8b 48 1c             	mov    0x1c(%eax),%ecx
   10464:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10467:	0f af c1             	imul   %ecx,%eax
   1046a:	01 d0                	add    %edx,%eax
   1046c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    mutex_unlock(&alloc->mutex);
   1046f:	8b 45 08             	mov    0x8(%ebp),%eax
   10472:	83 ec 0c             	sub    $0xc,%esp
   10475:	50                   	push   %eax
   10476:	e8 c2 2b 00 00       	call   1303d <mutex_unlock>
   1047b:	83 c4 10             	add    $0x10,%esp
    return addr;
   1047e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10481:	c9                   	leave  
   10482:	c3                   	ret    

00010483 <addr_free_page>:

/**
 * @brief 释放多页内存
 */
static void addr_free_page(addr_alloc_t *alloc, uint32_t addr, int page_count)
{
   10483:	55                   	push   %ebp
   10484:	89 e5                	mov    %esp,%ebp
   10486:	53                   	push   %ebx
   10487:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   1048a:	8b 45 08             	mov    0x8(%ebp),%eax
   1048d:	83 ec 0c             	sub    $0xc,%esp
   10490:	50                   	push   %eax
   10491:	e8 13 2b 00 00       	call   12fa9 <mutex_lock>
   10496:	83 c4 10             	add    $0x10,%esp

    uint32_t pg_idx = (addr - alloc->start) / alloc->page_size;
   10499:	8b 45 08             	mov    0x8(%ebp),%eax
   1049c:	8b 40 20             	mov    0x20(%eax),%eax
   1049f:	8b 55 0c             	mov    0xc(%ebp),%edx
   104a2:	89 d1                	mov    %edx,%ecx
   104a4:	29 c1                	sub    %eax,%ecx
   104a6:	8b 45 08             	mov    0x8(%ebp),%eax
   104a9:	8b 58 1c             	mov    0x1c(%eax),%ebx
   104ac:	89 c8                	mov    %ecx,%eax
   104ae:	ba 00 00 00 00       	mov    $0x0,%edx
   104b3:	f7 f3                	div    %ebx
   104b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap, pg_idx, page_count, 0);
   104b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104bb:	8b 55 08             	mov    0x8(%ebp),%edx
   104be:	83 c2 14             	add    $0x14,%edx
   104c1:	6a 00                	push   $0x0
   104c3:	ff 75 10             	pushl  0x10(%ebp)
   104c6:	50                   	push   %eax
   104c7:	52                   	push   %edx
   104c8:	e8 da 2d 00 00       	call   132a7 <bitmap_set_bit>
   104cd:	83 c4 10             	add    $0x10,%esp

    mutex_unlock(&alloc->mutex);
   104d0:	8b 45 08             	mov    0x8(%ebp),%eax
   104d3:	83 ec 0c             	sub    $0xc,%esp
   104d6:	50                   	push   %eax
   104d7:	e8 61 2b 00 00       	call   1303d <mutex_unlock>
   104dc:	83 c4 10             	add    $0x10,%esp
}
   104df:	90                   	nop
   104e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   104e3:	c9                   	leave  
   104e4:	c3                   	ret    

000104e5 <show_mem_info>:

static void show_mem_info(boot_info_t *boot_info)
{
   104e5:	55                   	push   %ebp
   104e6:	89 e5                	mov    %esp,%ebp
   104e8:	83 ec 18             	sub    $0x18,%esp
    log_printf("mem region:");
   104eb:	83 ec 0c             	sub    $0xc,%esp
   104ee:	68 c0 3d 01 00       	push   $0x13dc0
   104f3:	e8 d0 37 00 00       	call   13cc8 <log_printf>
   104f8:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++)
   104fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10502:	eb 29                	jmp    1052d <show_mem_info+0x48>
    {
        log_printf("[%d]: 0x%x - 0x%x", i,
   10504:	8b 45 08             	mov    0x8(%ebp),%eax
   10507:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1050a:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   1050e:	8b 45 08             	mov    0x8(%ebp),%eax
   10511:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10514:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   10517:	52                   	push   %edx
   10518:	50                   	push   %eax
   10519:	ff 75 f4             	pushl  -0xc(%ebp)
   1051c:	68 cc 3d 01 00       	push   $0x13dcc
   10521:	e8 a2 37 00 00       	call   13cc8 <log_printf>
   10526:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10529:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1052d:	8b 45 08             	mov    0x8(%ebp),%eax
   10530:	8b 40 50             	mov    0x50(%eax),%eax
   10533:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   10536:	7c cc                	jl     10504 <show_mem_info+0x1f>
                   boot_info->ram_region_cfg[i].start,
                   boot_info->ram_region_cfg[i].size);
    }
    log_printf("\n");
   10538:	83 ec 0c             	sub    $0xc,%esp
   1053b:	68 de 3d 01 00       	push   $0x13dde
   10540:	e8 83 37 00 00       	call   13cc8 <log_printf>
   10545:	83 c4 10             	add    $0x10,%esp
}
   10548:	90                   	nop
   10549:	c9                   	leave  
   1054a:	c3                   	ret    

0001054b <total_mem_size>:

/**
 * @brief 获取可用的物理内存大小
 */
static uint32_t total_mem_size(boot_info_t *boot_info)
{
   1054b:	55                   	push   %ebp
   1054c:	89 e5                	mov    %esp,%ebp
   1054e:	83 ec 10             	sub    $0x10,%esp
    int mem_size = 0;
   10551:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    // 简单起见，暂不考虑中间有空洞的情况
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10558:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1055f:	eb 16                	jmp    10577 <total_mem_size+0x2c>
    {
        mem_size += boot_info->ram_region_cfg[i].size;
   10561:	8b 45 08             	mov    0x8(%ebp),%eax
   10564:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10567:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   1056b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1056e:	01 d0                	add    %edx,%eax
   10570:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10573:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   10577:	8b 45 08             	mov    0x8(%ebp),%eax
   1057a:	8b 40 50             	mov    0x50(%eax),%eax
   1057d:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10580:	7c df                	jl     10561 <total_mem_size+0x16>
    }
    return mem_size;
   10582:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10585:	c9                   	leave  
   10586:	c3                   	ret    

00010587 <find_pte>:

pte_t *find_pte(pde_t *page_dir, uint32_t vaddr, int alloc)
{
   10587:	55                   	push   %ebp
   10588:	89 e5                	mov    %esp,%ebp
   1058a:	83 ec 18             	sub    $0x18,%esp
    pte_t *page_table;

    pde_t *pde = page_dir + pde_index(vaddr);
   1058d:	ff 75 0c             	pushl  0xc(%ebp)
   10590:	e8 8d fd ff ff       	call   10322 <pde_index>
   10595:	83 c4 04             	add    $0x4,%esp
   10598:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1059f:	8b 45 08             	mov    0x8(%ebp),%eax
   105a2:	01 d0                	add    %edx,%eax
   105a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pde->present)
   105a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105aa:	0f b6 00             	movzbl (%eax),%eax
   105ad:	83 e0 01             	and    $0x1,%eax
   105b0:	84 c0                	test   %al,%al
   105b2:	74 10                	je     105c4 <find_pte+0x3d>
    {
        page_table = (pte_t *)pde_paddr(pde);
   105b4:	ff 75 f0             	pushl  -0x10(%ebp)
   105b7:	e8 7a fd ff ff       	call   10336 <pde_paddr>
   105bc:	83 c4 04             	add    $0x4,%esp
   105bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
   105c2:	eb 57                	jmp    1061b <find_pte+0x94>
    }
    else
    {
        // 如果不存在，则考虑分配一个
        if (alloc == 0)
   105c4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   105c8:	75 07                	jne    105d1 <find_pte+0x4a>
        {
            return (pte_t *)0;
   105ca:	b8 00 00 00 00       	mov    $0x0,%eax
   105cf:	eb 64                	jmp    10635 <find_pte+0xae>
        }

        // 分配一个物理页表
        uint32_t pg_paddr = addr_alloc_page(&paddr_alloc, 1);
   105d1:	83 ec 08             	sub    $0x8,%esp
   105d4:	6a 01                	push   $0x1
   105d6:	68 00 80 01 00       	push   $0x18000
   105db:	e8 3c fe ff ff       	call   1041c <addr_alloc_page>
   105e0:	83 c4 10             	add    $0x10,%esp
   105e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (pg_paddr == 0)
   105e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   105ea:	75 07                	jne    105f3 <find_pte+0x6c>
        {
            return (pte_t *)0;
   105ec:	b8 00 00 00 00       	mov    $0x0,%eax
   105f1:	eb 42                	jmp    10635 <find_pte+0xae>
        }

        // 设置为用户可读写，将被pte中设置所覆盖
        pde->v = pg_paddr | PTE_P | PTE_W | PDE_U;
   105f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105f6:	83 c8 07             	or     $0x7,%eax
   105f9:	89 c2                	mov    %eax,%edx
   105fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105fe:	89 10                	mov    %edx,(%eax)
        // 为物理页表绑定虚拟地址的映射，这样下面就可以计算出虚拟地址了
        // kernel_pg_last[pde_index(vaddr)].v = pg_paddr | PTE_P | PTE_W;

        // 清空页表，防止出现异常
        // 这里虚拟地址和物理地址一一映射，所以直接写入
        page_table = (pte_t *)(pg_paddr);
   10600:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10603:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table, 0, MEM_PAGE_SIZE);
   10606:	83 ec 04             	sub    $0x4,%esp
   10609:	68 00 10 00 00       	push   $0x1000
   1060e:	6a 00                	push   $0x0
   10610:	ff 75 f4             	pushl  -0xc(%ebp)
   10613:	e8 31 30 00 00       	call   13649 <kernel_memset>
   10618:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + pte_index(vaddr);
   1061b:	83 ec 0c             	sub    $0xc,%esp
   1061e:	ff 75 0c             	pushl  0xc(%ebp)
   10621:	e8 37 fd ff ff       	call   1035d <pte_index>
   10626:	83 c4 10             	add    $0x10,%esp
   10629:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10630:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10633:	01 d0                	add    %edx,%eax
}
   10635:	c9                   	leave  
   10636:	c3                   	ret    

00010637 <memory_create_map>:

/**
 * @brief 将指定的地址空间进行一页的映射
 */
int memory_create_map(pde_t *page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
   10637:	55                   	push   %ebp
   10638:	89 e5                	mov    %esp,%ebp
   1063a:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < count; i++)
   1063d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10644:	eb 6e                	jmp    106b4 <memory_create_map+0x7d>
    {
        // log_printf("create map: v-0x%x p-0x%x, perm: 0x%x", vaddr, paddr, perm);

        pte_t *pte = find_pte(page_dir, vaddr, 1);
   10646:	83 ec 04             	sub    $0x4,%esp
   10649:	6a 01                	push   $0x1
   1064b:	ff 75 0c             	pushl  0xc(%ebp)
   1064e:	ff 75 08             	pushl  0x8(%ebp)
   10651:	e8 31 ff ff ff       	call   10587 <find_pte>
   10656:	83 c4 10             	add    $0x10,%esp
   10659:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pte == (pte_t *)0)
   1065c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10660:	75 07                	jne    10669 <memory_create_map+0x32>
        {
            // log_printf("create pte failed. pte == 0");
            return -1;
   10662:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10667:	eb 58                	jmp    106c1 <memory_create_map+0x8a>
        }

        // 创建映射的时候，这条pte应当是不存在的。
        // 如果存在，说明可能有问题
        // log_printf("\tpte addr: 0x%x", (uint32_t)pte);
        ASSERT(pte->present == 0);
   10669:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1066c:	0f b6 00             	movzbl (%eax),%eax
   1066f:	83 e0 01             	and    $0x1,%eax
   10672:	84 c0                	test   %al,%al
   10674:	74 1c                	je     10692 <memory_create_map+0x5b>
   10676:	68 e0 3d 01 00       	push   $0x13de0
   1067b:	68 f4 3e 01 00       	push   $0x13ef4
   10680:	68 96 00 00 00       	push   $0x96
   10685:	68 f4 3d 01 00       	push   $0x13df4
   1068a:	e8 e3 32 00 00       	call   13972 <panic>
   1068f:	83 c4 10             	add    $0x10,%esp

        pte->v = paddr | perm | PTE_P;
   10692:	8b 45 10             	mov    0x10(%ebp),%eax
   10695:	0b 45 18             	or     0x18(%ebp),%eax
   10698:	83 c8 01             	or     $0x1,%eax
   1069b:	89 c2                	mov    %eax,%edx
   1069d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106a0:	89 10                	mov    %edx,(%eax)

        vaddr += MEM_PAGE_SIZE;
   106a2:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   106a9:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++)
   106b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106b7:	3b 45 14             	cmp    0x14(%ebp),%eax
   106ba:	7c 8a                	jl     10646 <memory_create_map+0xf>
    }

    return 0;
   106bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   106c1:	c9                   	leave  
   106c2:	c3                   	ret    

000106c3 <create_kernel_table>:

/**
 * @brief 根据内存映射表，构造内核页表
 */
void create_kernel_table(void)
{
   106c3:	55                   	push   %ebp
   106c4:	89 e5                	mov    %esp,%ebp
   106c6:	83 ec 28             	sub    $0x28,%esp
        // 1M以上空间扩展V\P一一映射，方便直接操作
        {(void *)MEM_EXT_START, (void *)MEM_EXT_END, (void *)MEM_EXT_START, PTE_W},
    };

    // 清空页目录表
    kernel_memset(kernel_page_dir, 0, sizeof(kernel_page_dir));
   106c9:	83 ec 04             	sub    $0x4,%esp
   106cc:	68 00 10 00 00       	push   $0x1000
   106d1:	6a 00                	push   $0x0
   106d3:	68 00 90 01 00       	push   $0x19000
   106d8:	e8 6c 2f 00 00       	call   13649 <kernel_memset>
   106dd:	83 c4 10             	add    $0x10,%esp

    // 清空后，然后依次根据映射关系创建映射表
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   106e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   106e7:	e9 83 00 00 00       	jmp    1076f <create_kernel_table+0xac>
    {
        memory_map_t *map = kernel_map + i;
   106ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106ef:	c1 e0 04             	shl    $0x4,%eax
   106f2:	05 00 50 01 00       	add    $0x15000,%eax
   106f7:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 可能有多个页，建立多个页的配置
        // 简化起见，不考虑4M的情况
        int vstart = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   106fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106fd:	8b 00                	mov    (%eax),%eax
   106ff:	83 ec 08             	sub    $0x8,%esp
   10702:	68 00 10 00 00       	push   $0x1000
   10707:	50                   	push   %eax
   10708:	e8 fc fb ff ff       	call   10309 <down2>
   1070d:	83 c4 10             	add    $0x10,%esp
   10710:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int vend = up2((uint32_t)map->vend, MEM_PAGE_SIZE);
   10713:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10716:	8b 40 04             	mov    0x4(%eax),%eax
   10719:	83 ec 08             	sub    $0x8,%esp
   1071c:	68 00 10 00 00       	push   $0x1000
   10721:	50                   	push   %eax
   10722:	e8 cb fb ff ff       	call   102f2 <up2>
   10727:	83 c4 10             	add    $0x10,%esp
   1072a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int page_count = (vend - vstart) / MEM_PAGE_SIZE;
   1072d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10730:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10733:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
   10739:	85 c0                	test   %eax,%eax
   1073b:	0f 48 c2             	cmovs  %edx,%eax
   1073e:	c1 f8 0c             	sar    $0xc,%eax
   10741:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        memory_create_map(kernel_page_dir, vstart, (uint32_t)map->pstart, page_count, map->perm);
   10744:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10747:	8b 50 0c             	mov    0xc(%eax),%edx
   1074a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1074d:	8b 40 08             	mov    0x8(%eax),%eax
   10750:	89 c1                	mov    %eax,%ecx
   10752:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10755:	83 ec 0c             	sub    $0xc,%esp
   10758:	52                   	push   %edx
   10759:	ff 75 e4             	pushl  -0x1c(%ebp)
   1075c:	51                   	push   %ecx
   1075d:	50                   	push   %eax
   1075e:	68 00 90 01 00       	push   $0x19000
   10763:	e8 cf fe ff ff       	call   10637 <memory_create_map>
   10768:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   1076b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1076f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10772:	83 f8 03             	cmp    $0x3,%eax
   10775:	0f 86 71 ff ff ff    	jbe    106ec <create_kernel_table+0x29>
    }
}
   1077b:	90                   	nop
   1077c:	c9                   	leave  
   1077d:	c3                   	ret    

0001077e <memory_create_uvm>:
/**
 * @brief 创建进程的初始页表
 * 主要的工作创建页目录表，然后从内核页表中复制一部分
 */
uint32_t memory_create_uvm(void)
{
   1077e:	55                   	push   %ebp
   1077f:	89 e5                	mov    %esp,%ebp
   10781:	83 ec 18             	sub    $0x18,%esp
    pde_t *page_dir = (pde_t *)addr_alloc_page(&paddr_alloc, 1);
   10784:	83 ec 08             	sub    $0x8,%esp
   10787:	6a 01                	push   $0x1
   10789:	68 00 80 01 00       	push   $0x18000
   1078e:	e8 89 fc ff ff       	call   1041c <addr_alloc_page>
   10793:	83 c4 10             	add    $0x10,%esp
   10796:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_dir == 0)
   10799:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1079d:	75 07                	jne    107a6 <memory_create_uvm+0x28>
    {
        return 0;
   1079f:	b8 00 00 00 00       	mov    $0x0,%eax
   107a4:	eb 5b                	jmp    10801 <memory_create_uvm+0x83>
    }
    kernel_memset((void *)page_dir, 0, MEM_PAGE_SIZE);
   107a6:	83 ec 04             	sub    $0x4,%esp
   107a9:	68 00 10 00 00       	push   $0x1000
   107ae:	6a 00                	push   $0x0
   107b0:	ff 75 f0             	pushl  -0x10(%ebp)
   107b3:	e8 91 2e 00 00       	call   13649 <kernel_memset>
   107b8:	83 c4 10             	add    $0x10,%esp

    // 复制整个内核空间的页目录项，以便与其它进程共享内核空间
    // 用户空间的内存映射暂不处理，等加载程序时创建
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   107bb:	83 ec 0c             	sub    $0xc,%esp
   107be:	68 00 00 00 80       	push   $0x80000000
   107c3:	e8 5a fb ff ff       	call   10322 <pde_index>
   107c8:	83 c4 10             	add    $0x10,%esp
   107cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i = 0; i < user_pde_start; i++)
   107ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   107d5:	eb 1f                	jmp    107f6 <memory_create_uvm+0x78>
    {
        page_dir[i].v = kernel_page_dir[i].v;
   107d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   107e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107e4:	01 c2                	add    %eax,%edx
   107e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107e9:	8b 04 85 00 90 01 00 	mov    0x19000(,%eax,4),%eax
   107f0:	89 02                	mov    %eax,(%edx)
    for (int i = 0; i < user_pde_start; i++)
   107f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   107f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107f9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   107fc:	77 d9                	ja     107d7 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   107fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   10801:	c9                   	leave  
   10802:	c3                   	ret    

00010803 <memory_destroy_uvm>:

/**
 * @brief 销毁用户空间内存
 */
void memory_destroy_uvm(uint32_t page_dir)
{
   10803:	55                   	push   %ebp
   10804:	89 e5                	mov    %esp,%ebp
   10806:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10809:	68 00 00 00 80       	push   $0x80000000
   1080e:	e8 0f fb ff ff       	call   10322 <pde_index>
   10813:	83 c4 04             	add    $0x4,%esp
   10816:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t *pde = (pde_t *)page_dir + user_pde_start;
   10819:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1081c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10823:	8b 45 08             	mov    0x8(%ebp),%eax
   10826:	01 d0                	add    %edx,%eax
   10828:	89 45 f4             	mov    %eax,-0xc(%ebp)

    ASSERT(page_dir != 0);
   1082b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1082f:	75 1c                	jne    1084d <memory_destroy_uvm+0x4a>
   10831:	68 30 3e 01 00       	push   $0x13e30
   10836:	68 08 3f 01 00       	push   $0x13f08
   1083b:	68 e5 00 00 00       	push   $0xe5
   10840:	68 f4 3d 01 00       	push   $0x13df4
   10845:	e8 28 31 00 00       	call   13972 <panic>
   1084a:	83 c4 10             	add    $0x10,%esp

    // 释放页表中对应的各项，不包含映射的内核页面
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   1084d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10850:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10853:	e9 95 00 00 00       	jmp    108ed <memory_destroy_uvm+0xea>
    {
        if (!pde->present)
   10858:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1085b:	0f b6 00             	movzbl (%eax),%eax
   1085e:	83 e0 01             	and    $0x1,%eax
   10861:	84 c0                	test   %al,%al
   10863:	74 7f                	je     108e4 <memory_destroy_uvm+0xe1>
        {
            continue;
        }

        // 释放页表对应的物理页 + 页表
        pte_t *pte = (pte_t *)pde_paddr(pde);
   10865:	83 ec 0c             	sub    $0xc,%esp
   10868:	ff 75 f4             	pushl  -0xc(%ebp)
   1086b:	e8 c6 fa ff ff       	call   10336 <pde_paddr>
   10870:	83 c4 10             	add    $0x10,%esp
   10873:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10876:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1087d:	eb 39                	jmp    108b8 <memory_destroy_uvm+0xb5>
        {
            if (!pte->present)
   1087f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10882:	0f b6 00             	movzbl (%eax),%eax
   10885:	83 e0 01             	and    $0x1,%eax
   10888:	84 c0                	test   %al,%al
   1088a:	74 23                	je     108af <memory_destroy_uvm+0xac>
            {
                continue;
            }

            addr_free_page(&paddr_alloc, pte_paddr(pte), 1);
   1088c:	83 ec 0c             	sub    $0xc,%esp
   1088f:	ff 75 ec             	pushl  -0x14(%ebp)
   10892:	e8 d6 fa ff ff       	call   1036d <pte_paddr>
   10897:	83 c4 10             	add    $0x10,%esp
   1089a:	83 ec 04             	sub    $0x4,%esp
   1089d:	6a 01                	push   $0x1
   1089f:	50                   	push   %eax
   108a0:	68 00 80 01 00       	push   $0x18000
   108a5:	e8 d9 fb ff ff       	call   10483 <addr_free_page>
   108aa:	83 c4 10             	add    $0x10,%esp
   108ad:	eb 01                	jmp    108b0 <memory_destroy_uvm+0xad>
                continue;
   108af:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   108b0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   108b4:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   108b8:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   108bf:	7e be                	jle    1087f <memory_destroy_uvm+0x7c>
        }

        addr_free_page(&paddr_alloc, (uint32_t)pde_paddr(pde), 1);
   108c1:	83 ec 0c             	sub    $0xc,%esp
   108c4:	ff 75 f4             	pushl  -0xc(%ebp)
   108c7:	e8 6a fa ff ff       	call   10336 <pde_paddr>
   108cc:	83 c4 10             	add    $0x10,%esp
   108cf:	83 ec 04             	sub    $0x4,%esp
   108d2:	6a 01                	push   $0x1
   108d4:	50                   	push   %eax
   108d5:	68 00 80 01 00       	push   $0x18000
   108da:	e8 a4 fb ff ff       	call   10483 <addr_free_page>
   108df:	83 c4 10             	add    $0x10,%esp
   108e2:	eb 01                	jmp    108e5 <memory_destroy_uvm+0xe2>
            continue;
   108e4:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   108e5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   108e9:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   108ed:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   108f4:	0f 8e 5e ff ff ff    	jle    10858 <memory_destroy_uvm+0x55>
    }

    // 页目录表
    addr_free_page(&paddr_alloc, page_dir, 1);
   108fa:	83 ec 04             	sub    $0x4,%esp
   108fd:	6a 01                	push   $0x1
   108ff:	ff 75 08             	pushl  0x8(%ebp)
   10902:	68 00 80 01 00       	push   $0x18000
   10907:	e8 77 fb ff ff       	call   10483 <addr_free_page>
   1090c:	83 c4 10             	add    $0x10,%esp
}
   1090f:	90                   	nop
   10910:	c9                   	leave  
   10911:	c3                   	ret    

00010912 <memory_copy_uvm>:

/**
 * @brief 复制页表及其所有的内存空间
 */
uint32_t memory_copy_uvm(uint32_t page_dir)
{
   10912:	55                   	push   %ebp
   10913:	89 e5                	mov    %esp,%ebp
   10915:	83 ec 38             	sub    $0x38,%esp
    // 复制基础页表
    uint32_t to_page_dir = memory_create_uvm();
   10918:	e8 61 fe ff ff       	call   1077e <memory_create_uvm>
   1091d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (to_page_dir == 0)
   10920:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10924:	0f 84 1b 01 00 00    	je     10a45 <memory_copy_uvm+0x133>
    {
        goto copy_uvm_failed;
    }

    // 再复制用户空间的各项
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   1092a:	83 ec 0c             	sub    $0xc,%esp
   1092d:	68 00 00 00 80       	push   $0x80000000
   10932:	e8 eb f9 ff ff       	call   10322 <pde_index>
   10937:	83 c4 10             	add    $0x10,%esp
   1093a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t *pde = (pde_t *)page_dir + user_pde_start;
   1093d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10940:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10947:	8b 45 08             	mov    0x8(%ebp),%eax
   1094a:	01 d0                	add    %edx,%eax
   1094c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 遍历用户空间页目录项
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   1094f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10952:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10955:	e9 d9 00 00 00       	jmp    10a33 <memory_copy_uvm+0x121>
    {
        if (!pde->present)
   1095a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1095d:	0f b6 00             	movzbl (%eax),%eax
   10960:	83 e0 01             	and    $0x1,%eax
   10963:	84 c0                	test   %al,%al
   10965:	0f 84 bf 00 00 00    	je     10a2a <memory_copy_uvm+0x118>
        {
            continue;
        }

        // 遍历页表
        pte_t *pte = (pte_t *)pde_paddr(pde);
   1096b:	83 ec 0c             	sub    $0xc,%esp
   1096e:	ff 75 f4             	pushl  -0xc(%ebp)
   10971:	e8 c0 f9 ff ff       	call   10336 <pde_paddr>
   10976:	83 c4 10             	add    $0x10,%esp
   10979:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   1097c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10983:	e9 93 00 00 00       	jmp    10a1b <memory_copy_uvm+0x109>
        {
            if (!pte->present)
   10988:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1098b:	0f b6 00             	movzbl (%eax),%eax
   1098e:	83 e0 01             	and    $0x1,%eax
   10991:	84 c0                	test   %al,%al
   10993:	74 7d                	je     10a12 <memory_copy_uvm+0x100>
            {
                continue;
            }

            // 分配物理内存
            uint32_t page = addr_alloc_page(&paddr_alloc, 1);
   10995:	83 ec 08             	sub    $0x8,%esp
   10998:	6a 01                	push   $0x1
   1099a:	68 00 80 01 00       	push   $0x18000
   1099f:	e8 78 fa ff ff       	call   1041c <addr_alloc_page>
   109a4:	83 c4 10             	add    $0x10,%esp
   109a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (page == 0)
   109aa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   109ae:	0f 84 94 00 00 00    	je     10a48 <memory_copy_uvm+0x136>
            {
                goto copy_uvm_failed;
            }

            // 建立映射关系
            uint32_t vaddr = (i << 22) | (j << 12);
   109b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109b7:	c1 e0 16             	shl    $0x16,%eax
   109ba:	89 c2                	mov    %eax,%edx
   109bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109bf:	c1 e0 0c             	shl    $0xc,%eax
   109c2:	09 d0                	or     %edx,%eax
   109c4:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte));
   109c7:	83 ec 0c             	sub    $0xc,%esp
   109ca:	ff 75 ec             	pushl  -0x14(%ebp)
   109cd:	e8 c2 f9 ff ff       	call   10394 <get_pte_perm>
   109d2:	83 c4 10             	add    $0x10,%esp
   109d5:	89 c2                	mov    %eax,%edx
   109d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   109da:	83 ec 0c             	sub    $0xc,%esp
   109dd:	52                   	push   %edx
   109de:	6a 01                	push   $0x1
   109e0:	ff 75 dc             	pushl  -0x24(%ebp)
   109e3:	ff 75 d8             	pushl  -0x28(%ebp)
   109e6:	50                   	push   %eax
   109e7:	e8 4b fc ff ff       	call   10637 <memory_create_map>
   109ec:	83 c4 20             	add    $0x20,%esp
   109ef:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0)
   109f2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   109f6:	78 53                	js     10a4b <memory_copy_uvm+0x139>
            {
                goto copy_uvm_failed;
            }

            // 复制内容。
            kernel_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   109f8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   109fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   109fe:	83 ec 04             	sub    $0x4,%esp
   10a01:	68 00 10 00 00       	push   $0x1000
   10a06:	52                   	push   %edx
   10a07:	50                   	push   %eax
   10a08:	e8 ed 2b 00 00       	call   135fa <kernel_memcpy>
   10a0d:	83 c4 10             	add    $0x10,%esp
   10a10:	eb 01                	jmp    10a13 <memory_copy_uvm+0x101>
                continue;
   10a12:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10a13:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10a17:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10a1b:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10a22:	0f 8e 60 ff ff ff    	jle    10988 <memory_copy_uvm+0x76>
   10a28:	eb 01                	jmp    10a2b <memory_copy_uvm+0x119>
            continue;
   10a2a:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   10a2b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10a2f:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10a33:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10a3a:	0f 8e 1a ff ff ff    	jle    1095a <memory_copy_uvm+0x48>
        }
    }
    return to_page_dir;
   10a40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a43:	eb 20                	jmp    10a65 <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10a45:	90                   	nop
   10a46:	eb 04                	jmp    10a4c <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10a48:	90                   	nop
   10a49:	eb 01                	jmp    10a4c <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10a4b:	90                   	nop

copy_uvm_failed:
    if (to_page_dir)
   10a4c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10a50:	74 0e                	je     10a60 <memory_copy_uvm+0x14e>
    {
        memory_destroy_uvm(to_page_dir);
   10a52:	83 ec 0c             	sub    $0xc,%esp
   10a55:	ff 75 e4             	pushl  -0x1c(%ebp)
   10a58:	e8 a6 fd ff ff       	call   10803 <memory_destroy_uvm>
   10a5d:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10a60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10a65:	c9                   	leave  
   10a66:	c3                   	ret    

00010a67 <memory_get_paddr>:
/**
 * @brief 获取指定虚拟地址的物理地址
 * 如果转换失败，返回0。
 */
uint32_t memory_get_paddr(uint32_t page_dir, uint32_t vaddr)
{
   10a67:	55                   	push   %ebp
   10a68:	89 e5                	mov    %esp,%ebp
   10a6a:	83 ec 18             	sub    $0x18,%esp
    pte_t *pte = find_pte((pde_t *)page_dir, vaddr, 0);
   10a6d:	8b 45 08             	mov    0x8(%ebp),%eax
   10a70:	83 ec 04             	sub    $0x4,%esp
   10a73:	6a 00                	push   $0x0
   10a75:	ff 75 0c             	pushl  0xc(%ebp)
   10a78:	50                   	push   %eax
   10a79:	e8 09 fb ff ff       	call   10587 <find_pte>
   10a7e:	83 c4 10             	add    $0x10,%esp
   10a81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (pte == (pte_t *)0)
   10a84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a88:	75 07                	jne    10a91 <memory_get_paddr+0x2a>
    {
        return 0;
   10a8a:	b8 00 00 00 00       	mov    $0x0,%eax
   10a8f:	eb 1a                	jmp    10aab <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE - 1));
   10a91:	83 ec 0c             	sub    $0xc,%esp
   10a94:	ff 75 f4             	pushl  -0xc(%ebp)
   10a97:	e8 d1 f8 ff ff       	call   1036d <pte_paddr>
   10a9c:	83 c4 10             	add    $0x10,%esp
   10a9f:	89 c2                	mov    %eax,%edx
   10aa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa4:	25 ff 0f 00 00       	and    $0xfff,%eax
   10aa9:	01 d0                	add    %edx,%eax
}
   10aab:	c9                   	leave  
   10aac:	c3                   	ret    

00010aad <memory_copy_uvm_data>:
/**
 * @brief 在不同的进程空间中拷贝字符串
 * page_dir为目标页表，当前仍为老页表
 */
int memory_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size)
{
   10aad:	55                   	push   %ebp
   10aae:	89 e5                	mov    %esp,%ebp
   10ab0:	83 ec 18             	sub    $0x18,%esp
    char *buf, *pa0;

    while (size > 0)
   10ab3:	eb 6e                	jmp    10b23 <memory_copy_uvm_data+0x76>
    {
        // 获取目标的物理地址, 也即其另一个虚拟地址
        uint32_t to_paddr = memory_get_paddr(page_dir, to);
   10ab5:	83 ec 08             	sub    $0x8,%esp
   10ab8:	ff 75 08             	pushl  0x8(%ebp)
   10abb:	ff 75 0c             	pushl  0xc(%ebp)
   10abe:	e8 a4 ff ff ff       	call   10a67 <memory_get_paddr>
   10ac3:	83 c4 10             	add    $0x10,%esp
   10ac6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (to_paddr == 0)
   10ac9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10acd:	75 07                	jne    10ad6 <memory_copy_uvm_data+0x29>
        {
            return -1;
   10acf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10ad4:	eb 58                	jmp    10b2e <memory_copy_uvm_data+0x81>
        }

        // 计算当前可拷贝的大小
        uint32_t offset_in_page = to_paddr & (MEM_PAGE_SIZE - 1);
   10ad6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ad9:	25 ff 0f 00 00       	and    $0xfff,%eax
   10ade:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;
   10ae1:	b8 00 10 00 00       	mov    $0x1000,%eax
   10ae6:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10ae9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (curr_size > size)
   10aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10aef:	3b 45 14             	cmp    0x14(%ebp),%eax
   10af2:	76 06                	jbe    10afa <memory_copy_uvm_data+0x4d>
        {
            curr_size = size; // 如果比较大，超过页边界，则只拷贝此页内的
   10af4:	8b 45 14             	mov    0x14(%ebp),%eax
   10af7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void *)to_paddr, (void *)from, curr_size);
   10afa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10afd:	8b 55 10             	mov    0x10(%ebp),%edx
   10b00:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b03:	83 ec 04             	sub    $0x4,%esp
   10b06:	51                   	push   %ecx
   10b07:	52                   	push   %edx
   10b08:	50                   	push   %eax
   10b09:	e8 ec 2a 00 00       	call   135fa <kernel_memcpy>
   10b0e:	83 c4 10             	add    $0x10,%esp

        size -= curr_size;
   10b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b14:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b1a:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b20:	01 45 10             	add    %eax,0x10(%ebp)
    while (size > 0)
   10b23:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10b27:	75 8c                	jne    10ab5 <memory_copy_uvm_data+0x8>
    }

    return 0;
   10b29:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b2e:	c9                   	leave  
   10b2f:	c3                   	ret    

00010b30 <memory_alloc_for_page_dir>:

uint32_t memory_alloc_for_page_dir(uint32_t page_dir, uint32_t vaddr, uint32_t size, int perm)
{
   10b30:	55                   	push   %ebp
   10b31:	89 e5                	mov    %esp,%ebp
   10b33:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr = vaddr;
   10b36:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b39:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10b3c:	68 00 10 00 00       	push   $0x1000
   10b41:	ff 75 10             	pushl  0x10(%ebp)
   10b44:	e8 a9 f7 ff ff       	call   102f2 <up2>
   10b49:	83 c4 08             	add    $0x8,%esp
   10b4c:	c1 e8 0c             	shr    $0xc,%eax
   10b4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vaddr = down2(vaddr, MEM_PAGE_SIZE);
   10b52:	68 00 10 00 00       	push   $0x1000
   10b57:	ff 75 0c             	pushl  0xc(%ebp)
   10b5a:	e8 aa f7 ff ff       	call   10309 <down2>
   10b5f:	83 c4 08             	add    $0x8,%esp
   10b62:	89 45 0c             	mov    %eax,0xc(%ebp)

    // 逐页分配内存，然后建立映射关系
    for (int i = 0; i < page_count; i++)
   10b65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10b6c:	eb 7b                	jmp    10be9 <memory_alloc_for_page_dir+0xb9>
    {
        // 分配需要的内存
        uint32_t paddr = addr_alloc_page(&paddr_alloc, 1);
   10b6e:	83 ec 08             	sub    $0x8,%esp
   10b71:	6a 01                	push   $0x1
   10b73:	68 00 80 01 00       	push   $0x18000
   10b78:	e8 9f f8 ff ff       	call   1041c <addr_alloc_page>
   10b7d:	83 c4 10             	add    $0x10,%esp
   10b80:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (paddr == 0)
   10b83:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10b87:	75 17                	jne    10ba0 <memory_alloc_for_page_dir+0x70>
        {
            log_printf("mem alloc failed. no memory");
   10b89:	83 ec 0c             	sub    $0xc,%esp
   10b8c:	68 3e 3e 01 00       	push   $0x13e3e
   10b91:	e8 32 31 00 00       	call   13cc8 <log_printf>
   10b96:	83 c4 10             	add    $0x10,%esp
            return 0;
   10b99:	b8 00 00 00 00       	mov    $0x0,%eax
   10b9e:	eb 5a                	jmp    10bfa <memory_alloc_for_page_dir+0xca>
        }

        // 建立分配的内存与指定地址的关联
        int err = memory_create_map((pde_t *)page_dir, curr_vaddr, paddr, 1, perm);
   10ba0:	8b 55 14             	mov    0x14(%ebp),%edx
   10ba3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ba6:	83 ec 0c             	sub    $0xc,%esp
   10ba9:	52                   	push   %edx
   10baa:	6a 01                	push   $0x1
   10bac:	ff 75 e8             	pushl  -0x18(%ebp)
   10baf:	ff 75 f4             	pushl  -0xc(%ebp)
   10bb2:	50                   	push   %eax
   10bb3:	e8 7f fa ff ff       	call   10637 <memory_create_map>
   10bb8:	83 c4 20             	add    $0x20,%esp
   10bbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0)
   10bbe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10bc2:	79 1a                	jns    10bde <memory_alloc_for_page_dir+0xae>
        {
            log_printf("create memory map failed. err = %d", err);
   10bc4:	83 ec 08             	sub    $0x8,%esp
   10bc7:	ff 75 e4             	pushl  -0x1c(%ebp)
   10bca:	68 5c 3e 01 00       	push   $0x13e5c
   10bcf:	e8 f4 30 00 00       	call   13cc8 <log_printf>
   10bd4:	83 c4 10             	add    $0x10,%esp
            // addr_free_page(&paddr_alloc, vaddr, i + 1); 清理之前分配的页
            return -1;
   10bd7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10bdc:	eb 1c                	jmp    10bfa <memory_alloc_for_page_dir+0xca>
        }

        curr_vaddr += MEM_PAGE_SIZE;
   10bde:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for (int i = 0; i < page_count; i++)
   10be5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10be9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   10bef:	0f 8c 79 ff ff ff    	jl     10b6e <memory_alloc_for_page_dir+0x3e>
    }

    return 0;
   10bf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10bfa:	c9                   	leave  
   10bfb:	c3                   	ret    

00010bfc <memory_alloc_page>:
/**
 * @brief 分配一页内存
 * 主要用于内核空间内存的分配，不用于进程内存空间
 */
uint32_t memory_alloc_page(void)
{
   10bfc:	55                   	push   %ebp
   10bfd:	89 e5                	mov    %esp,%ebp
   10bff:	83 ec 08             	sub    $0x8,%esp
    // 内核空间虚拟地址与物理地址相同
    return addr_alloc_page(&paddr_alloc, 1);
   10c02:	83 ec 08             	sub    $0x8,%esp
   10c05:	6a 01                	push   $0x1
   10c07:	68 00 80 01 00       	push   $0x18000
   10c0c:	e8 0b f8 ff ff       	call   1041c <addr_alloc_page>
   10c11:	83 c4 10             	add    $0x10,%esp
}
   10c14:	c9                   	leave  
   10c15:	c3                   	ret    

00010c16 <memory_free_page>:

/**
 * @brief 释放一页内存
 */
void memory_free_page(uint32_t addr)
{
   10c16:	55                   	push   %ebp
   10c17:	89 e5                	mov    %esp,%ebp
   10c19:	83 ec 18             	sub    $0x18,%esp
    if (addr < MEMORY_TASK_BASE)
   10c1c:	8b 45 08             	mov    0x8(%ebp),%eax
   10c1f:	85 c0                	test   %eax,%eax
   10c21:	78 17                	js     10c3a <memory_free_page+0x24>
    {
        // 内核空间，直接释放
        addr_free_page(&paddr_alloc, addr, 1);
   10c23:	83 ec 04             	sub    $0x4,%esp
   10c26:	6a 01                	push   $0x1
   10c28:	ff 75 08             	pushl  0x8(%ebp)
   10c2b:	68 00 80 01 00       	push   $0x18000
   10c30:	e8 4e f8 ff ff       	call   10483 <addr_free_page>
   10c35:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc, pte_paddr(pte), 1);

        // 释放页表
        pte->v = 0;
    }
}
   10c38:	eb 72                	jmp    10cac <memory_free_page+0x96>
        pte_t *pte = find_pte(current_page_dir(), addr, 0);
   10c3a:	e8 75 f7 ff ff       	call   103b4 <current_page_dir>
   10c3f:	83 ec 04             	sub    $0x4,%esp
   10c42:	6a 00                	push   $0x0
   10c44:	ff 75 08             	pushl  0x8(%ebp)
   10c47:	50                   	push   %eax
   10c48:	e8 3a f9 ff ff       	call   10587 <find_pte>
   10c4d:	83 c4 10             	add    $0x10,%esp
   10c50:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT((pte == (pte_t *)0) && pte->present);
   10c53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c57:	75 0d                	jne    10c66 <memory_free_page+0x50>
   10c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c5c:	0f b6 00             	movzbl (%eax),%eax
   10c5f:	83 e0 01             	and    $0x1,%eax
   10c62:	84 c0                	test   %al,%al
   10c64:	75 1c                	jne    10c82 <memory_free_page+0x6c>
   10c66:	68 80 3e 01 00       	push   $0x13e80
   10c6b:	68 1c 3f 01 00       	push   $0x13f1c
   10c70:	68 aa 01 00 00       	push   $0x1aa
   10c75:	68 f4 3d 01 00       	push   $0x13df4
   10c7a:	e8 f3 2c 00 00       	call   13972 <panic>
   10c7f:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc, pte_paddr(pte), 1);
   10c82:	83 ec 0c             	sub    $0xc,%esp
   10c85:	ff 75 f4             	pushl  -0xc(%ebp)
   10c88:	e8 e0 f6 ff ff       	call   1036d <pte_paddr>
   10c8d:	83 c4 10             	add    $0x10,%esp
   10c90:	83 ec 04             	sub    $0x4,%esp
   10c93:	6a 01                	push   $0x1
   10c95:	50                   	push   %eax
   10c96:	68 00 80 01 00       	push   $0x18000
   10c9b:	e8 e3 f7 ff ff       	call   10483 <addr_free_page>
   10ca0:	83 c4 10             	add    $0x10,%esp
        pte->v = 0;
   10ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ca6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   10cac:	90                   	nop
   10cad:	c9                   	leave  
   10cae:	c3                   	ret    

00010caf <memory_alloc_page_for>:

/**
 * @brief 为指定的虚拟地址空间分配多页内存
 */
int memory_alloc_page_for(uint32_t addr, uint32_t size, int perm)
{
   10caf:	55                   	push   %ebp
   10cb0:	89 e5                	mov    %esp,%ebp
   10cb2:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3, addr, size, perm);
   10cb5:	e8 38 07 00 00       	call   113f2 <task_current>
   10cba:	8b 40 6c             	mov    0x6c(%eax),%eax
   10cbd:	ff 75 10             	pushl  0x10(%ebp)
   10cc0:	ff 75 0c             	pushl  0xc(%ebp)
   10cc3:	ff 75 08             	pushl  0x8(%ebp)
   10cc6:	50                   	push   %eax
   10cc7:	e8 64 fe ff ff       	call   10b30 <memory_alloc_for_page_dir>
   10ccc:	83 c4 10             	add    $0x10,%esp
}
   10ccf:	c9                   	leave  
   10cd0:	c3                   	ret    

00010cd1 <memory_init>:
 * 该函数的主要任务：
 * 1、初始化物理内存分配器：将所有物理内存管理起来. 在1MB内存中分配物理位图
 * 2、重新创建内核页表：原loader中创建的页表已经不再合适
 */
void memory_init(boot_info_t *boot_info)
{
   10cd1:	55                   	push   %ebp
   10cd2:	89 e5                	mov    %esp,%ebp
   10cd4:	83 ec 18             	sub    $0x18,%esp
    extern uint8_t *mem_free_start;
    log_printf("mem init");
   10cd7:	83 ec 0c             	sub    $0xc,%esp
   10cda:	68 a4 3e 01 00       	push   $0x13ea4
   10cdf:	e8 e4 2f 00 00       	call   13cc8 <log_printf>
   10ce4:	83 c4 10             	add    $0x10,%esp
    show_mem_info(boot_info);
   10ce7:	83 ec 0c             	sub    $0xc,%esp
   10cea:	ff 75 08             	pushl  0x8(%ebp)
   10ced:	e8 f3 f7 ff ff       	call   104e5 <show_mem_info>
   10cf2:	83 c4 10             	add    $0x10,%esp

    // 在内核数据后面放物理页位图
    uint8_t *mem_free = (uint8_t *)&mem_free_start;
   10cf5:	c7 45 f4 13 ae 03 00 	movl   $0x3ae13,-0xc(%ebp)

    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;
   10cfc:	83 ec 0c             	sub    $0xc,%esp
   10cff:	ff 75 08             	pushl  0x8(%ebp)
   10d02:	e8 44 f8 ff ff       	call   1054b <total_mem_size>
   10d07:	83 c4 10             	add    $0x10,%esp
   10d0a:	2d 00 00 10 00       	sub    $0x100000,%eax
   10d0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);
   10d12:	83 ec 08             	sub    $0x8,%esp
   10d15:	68 00 10 00 00       	push   $0x1000
   10d1a:	ff 75 f0             	pushl  -0x10(%ebp)
   10d1d:	e8 e7 f5 ff ff       	call   10309 <down2>
   10d22:	83 c4 10             	add    $0x10,%esp
   10d25:	89 45 f0             	mov    %eax,-0x10(%ebp)
    log_printf("free memory: 0x%x, size:0x%x", MEM_EXT_START, mem_up1MB_free);
   10d28:	83 ec 04             	sub    $0x4,%esp
   10d2b:	ff 75 f0             	pushl  -0x10(%ebp)
   10d2e:	68 00 00 10 00       	push   $0x100000
   10d33:	68 ad 3e 01 00       	push   $0x13ead
   10d38:	e8 8b 2f 00 00       	call   13cc8 <log_printf>
   10d3d:	83 c4 10             	add    $0x10,%esp

    // 4GB大小需要总共4*1024*1024*1024/4096/8=128KB的位图, 使用低1MB的RAM空间中足够
    // 该部分的内存仅跟在mem_free_start开始放置
    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);
   10d40:	83 ec 0c             	sub    $0xc,%esp
   10d43:	68 00 10 00 00       	push   $0x1000
   10d48:	ff 75 f0             	pushl  -0x10(%ebp)
   10d4b:	68 00 00 10 00       	push   $0x100000
   10d50:	ff 75 f4             	pushl  -0xc(%ebp)
   10d53:	68 00 80 01 00       	push   $0x18000
   10d58:	e8 67 f6 ff ff       	call   103c4 <addr_alloc_init>
   10d5d:	83 c4 20             	add    $0x20,%esp
    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE); // mem_free 跳过bit的地址
   10d60:	a1 24 80 01 00       	mov    0x18024,%eax
   10d65:	c1 e8 0c             	shr    $0xc,%eax
   10d68:	83 ec 0c             	sub    $0xc,%esp
   10d6b:	50                   	push   %eax
   10d6c:	e8 cd 24 00 00       	call   1323e <bitmap_byte_count>
   10d71:	83 c4 10             	add    $0x10,%esp
   10d74:	01 45 f4             	add    %eax,-0xc(%ebp)
    // 到这里，mem_free应该比EBDA地址要小
    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   10d77:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   10d7e:	76 1c                	jbe    10d9c <memory_init+0xcb>
   10d80:	68 cc 3e 01 00       	push   $0x13ecc
   10d85:	68 30 3f 01 00       	push   $0x13f30
   10d8a:	68 d4 01 00 00       	push   $0x1d4
   10d8f:	68 f4 3d 01 00       	push   $0x13df4
   10d94:	e8 d9 2b 00 00       	call   13972 <panic>
   10d99:	83 c4 10             	add    $0x10,%esp

    // 创建内核页表并切换过去
    create_kernel_table();
   10d9c:	e8 22 f9 ff ff       	call   106c3 <create_kernel_table>
    // 先切换到当前页表
    mmu_set_page_dir((uint32_t)kernel_page_dir);
   10da1:	b8 00 90 01 00       	mov    $0x19000,%eax
   10da6:	83 ec 0c             	sub    $0xc,%esp
   10da9:	50                   	push   %eax
   10daa:	e8 f4 f5 ff ff       	call   103a3 <mmu_set_page_dir>
   10daf:	83 c4 10             	add    $0x10,%esp
    // {
    //     addr_free_page(&addr_alloc, addr, 2);
    //     addr += 4096 * 2;
    //     log_printf("alloc addr: 0x%x", addr);
    // }
   10db2:	90                   	nop
   10db3:	c9                   	leave  
   10db4:	c3                   	ret    

00010db5 <sys_print_msg>:

// 系统调用处理函数类型
typedef int (*syscall_handler_t)(uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3);

void sys_print_msg(char *fmt, int arg)
{
   10db5:	55                   	push   %ebp
   10db6:	89 e5                	mov    %esp,%ebp
   10db8:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt, arg);
   10dbb:	83 ec 08             	sub    $0x8,%esp
   10dbe:	ff 75 0c             	pushl  0xc(%ebp)
   10dc1:	ff 75 08             	pushl  0x8(%ebp)
   10dc4:	e8 ff 2e 00 00       	call   13cc8 <log_printf>
   10dc9:	83 c4 10             	add    $0x10,%esp
}
   10dcc:	90                   	nop
   10dcd:	c9                   	leave  
   10dce:	c3                   	ret    

00010dcf <do_handler_syscall>:

/**
 * 处理系统调用。该函数由系统调用函数调用
 */
void do_handler_syscall(syscall_frame_t *frame)
{
   10dcf:	55                   	push   %ebp
   10dd0:	89 e5                	mov    %esp,%ebp
   10dd2:	53                   	push   %ebx
   10dd3:	83 ec 14             	sub    $0x14,%esp
    if (frame->func_id < sizeof(sys_table) / sizeof(sys_table[0]))
   10dd6:	8b 45 08             	mov    0x8(%ebp),%eax
   10dd9:	8b 40 3c             	mov    0x3c(%eax),%eax
   10ddc:	83 f8 64             	cmp    $0x64,%eax
   10ddf:	77 4e                	ja     10e2f <do_handler_syscall+0x60>
    {
        // 查表取得处理函数，然后调用处理
        syscall_handler_t handler = sys_table[frame->func_id];
   10de1:	8b 45 08             	mov    0x8(%ebp),%eax
   10de4:	8b 40 3c             	mov    0x3c(%eax),%eax
   10de7:	8b 04 85 40 3f 01 00 	mov    0x13f40(,%eax,4),%eax
   10dee:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (handler)
   10df1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10df5:	74 38                	je     10e2f <do_handler_syscall+0x60>
        {
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3);
   10df7:	8b 45 08             	mov    0x8(%ebp),%eax
   10dfa:	8b 40 4c             	mov    0x4c(%eax),%eax
   10dfd:	89 c3                	mov    %eax,%ebx
   10dff:	8b 45 08             	mov    0x8(%ebp),%eax
   10e02:	8b 40 48             	mov    0x48(%eax),%eax
   10e05:	89 c1                	mov    %eax,%ecx
   10e07:	8b 45 08             	mov    0x8(%ebp),%eax
   10e0a:	8b 40 44             	mov    0x44(%eax),%eax
   10e0d:	89 c2                	mov    %eax,%edx
   10e0f:	8b 45 08             	mov    0x8(%ebp),%eax
   10e12:	8b 40 40             	mov    0x40(%eax),%eax
   10e15:	53                   	push   %ebx
   10e16:	51                   	push   %ecx
   10e17:	52                   	push   %edx
   10e18:	50                   	push   %eax
   10e19:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e1c:	ff d0                	call   *%eax
   10e1e:	83 c4 10             	add    $0x10,%esp
   10e21:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax = ret; // 设置系统调用的返回值，由eax传递
   10e24:	8b 45 08             	mov    0x8(%ebp),%eax
   10e27:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10e2a:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10e2d:	eb 30                	jmp    10e5f <do_handler_syscall+0x90>
        }
    }
    // 不支持的系统调用，打印出错信息
    task_t *task = task_current();
   10e2f:	e8 be 05 00 00       	call   113f2 <task_current>
   10e34:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d", task->name, frame->func_id);
   10e37:	8b 45 08             	mov    0x8(%ebp),%eax
   10e3a:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e3d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e40:	83 c2 04             	add    $0x4,%edx
   10e43:	83 ec 04             	sub    $0x4,%esp
   10e46:	50                   	push   %eax
   10e47:	52                   	push   %edx
   10e48:	68 d4 40 01 00       	push   $0x140d4
   10e4d:	e8 76 2e 00 00       	call   13cc8 <log_printf>
   10e52:	83 c4 10             	add    $0x10,%esp
    frame->eax = -1; // 设置系统调用的返回值，由eax传递
   10e55:	8b 45 08             	mov    0x8(%ebp),%eax
   10e58:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
}
   10e5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10e62:	c9                   	leave  
   10e63:	c3                   	ret    

00010e64 <list_node_init>:
/**
 * 头结点的初始化
 * @param node 待初始化的结果
 */
static inline void list_node_init(list_node_t *node)
{
   10e64:	55                   	push   %ebp
   10e65:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   10e67:	8b 45 08             	mov    0x8(%ebp),%eax
   10e6a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10e71:	8b 45 08             	mov    0x8(%ebp),%eax
   10e74:	8b 50 04             	mov    0x4(%eax),%edx
   10e77:	8b 45 08             	mov    0x8(%ebp),%eax
   10e7a:	89 10                	mov    %edx,(%eax)
}
   10e7c:	90                   	nop
   10e7d:	5d                   	pop    %ebp
   10e7e:	c3                   	ret    

00010e7f <list_node_next>:
 * 获取结点的后一结点
 * @param node 查询的结点
 * @return 后继结点
 */
static inline list_node_t *list_node_next(list_node_t *node)
{
   10e7f:	55                   	push   %ebp
   10e80:	89 e5                	mov    %esp,%ebp
    return node->next;
   10e82:	8b 45 08             	mov    0x8(%ebp),%eax
   10e85:	8b 40 04             	mov    0x4(%eax),%eax
}
   10e88:	5d                   	pop    %ebp
   10e89:	c3                   	ret    

00010e8a <list_count>:
 * 获取链表的结点数量
 * @param list 查询的链表
 * @return 结果的数据
 */
static inline int list_count(list_t *list)
{
   10e8a:	55                   	push   %ebp
   10e8b:	89 e5                	mov    %esp,%ebp
    return list->count;
   10e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e90:	8b 40 08             	mov    0x8(%eax),%eax
}
   10e93:	5d                   	pop    %ebp
   10e94:	c3                   	ret    

00010e95 <list_first>:
 * 获取指定链表的第一个表项
 * @param list 查询的链表
 * @return 第一个表项
 */
static inline list_node_t *list_first(list_t *list)
{
   10e95:	55                   	push   %ebp
   10e96:	89 e5                	mov    %esp,%ebp
    return list->first;
   10e98:	8b 45 08             	mov    0x8(%ebp),%eax
   10e9b:	8b 00                	mov    (%eax),%eax
}
   10e9d:	5d                   	pop    %ebp
   10e9e:	c3                   	ret    

00010e9f <write_cr3>:
{
   10e9f:	55                   	push   %ebp
   10ea0:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3" ::[v] "r"(v));
   10ea2:	8b 45 08             	mov    0x8(%ebp),%eax
   10ea5:	0f 22 d8             	mov    %eax,%cr3
}
   10ea8:	90                   	nop
   10ea9:	5d                   	pop    %ebp
   10eaa:	c3                   	ret    

00010eab <hlt>:
    uint32_t addr[] = {offset, selector};
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
}

static inline void hlt(void)
{
   10eab:	55                   	push   %ebp
   10eac:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10eae:	f4                   	hlt    
}
   10eaf:	90                   	nop
   10eb0:	5d                   	pop    %ebp
   10eb1:	c3                   	ret    

00010eb2 <write_tr>:

// 写tss register 当前运行那个进程
static inline void write_tr(uint32_t tss_selector)
{
   10eb2:	55                   	push   %ebp
   10eb3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("ltr %%ax" ::"a"(tss_selector));
   10eb5:	8b 45 08             	mov    0x8(%ebp),%eax
   10eb8:	0f 00 d8             	ltr    %ax
}
   10ebb:	90                   	nop
   10ebc:	5d                   	pop    %ebp
   10ebd:	c3                   	ret    

00010ebe <mmu_set_page_dir>:
{
   10ebe:	55                   	push   %ebp
   10ebf:	89 e5                	mov    %esp,%ebp
    write_cr3(paddr);
   10ec1:	ff 75 08             	pushl  0x8(%ebp)
   10ec4:	e8 d6 ff ff ff       	call   10e9f <write_cr3>
   10ec9:	83 c4 04             	add    $0x4,%esp
}
   10ecc:	90                   	nop
   10ecd:	c9                   	leave  
   10ece:	c3                   	ret    

00010ecf <tss_init>:
static task_manager_t task_manager; // 任务管理器
static task_t task_table[TASK_NR];
static mutex_t task_table_mutex;

static int tss_init(task_t *task, int flag, uint32_t entry, uint32_t esp)
{
   10ecf:	55                   	push   %ebp
   10ed0:	89 e5                	mov    %esp,%ebp
   10ed2:	83 ec 28             	sub    $0x28,%esp
    int tss_sel = get_alloc_desc();
   10ed5:	e8 d1 11 00 00       	call   120ab <get_alloc_desc>
   10eda:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (tss_sel < 0)
   10edd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10ee1:	79 1a                	jns    10efd <tss_init+0x2e>
    {
        log_printf("alloc tss failed.\n");
   10ee3:	83 ec 0c             	sub    $0xc,%esp
   10ee6:	68 f4 40 01 00       	push   $0x140f4
   10eeb:	e8 d8 2d 00 00       	call   13cc8 <log_printf>
   10ef0:	83 c4 10             	add    $0x10,%esp
        return -1;
   10ef3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10ef8:	e9 68 01 00 00       	jmp    11065 <tss_init+0x196>
    }

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t), SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); // 设置GDT表项内容
   10efd:	8b 45 08             	mov    0x8(%ebp),%eax
   10f00:	83 c0 50             	add    $0x50,%eax
   10f03:	68 89 00 00 00       	push   $0x89
   10f08:	6a 68                	push   $0x68
   10f0a:	50                   	push   %eax
   10f0b:	ff 75 ec             	pushl  -0x14(%ebp)
   10f0e:	e8 e0 10 00 00       	call   11ff3 <segment_desc_set>
   10f13:	83 c4 10             	add    $0x10,%esp

    // tss段初始化
    kernel_memset(&task->tss, 0, sizeof(tss_t));
   10f16:	8b 45 08             	mov    0x8(%ebp),%eax
   10f19:	83 c0 50             	add    $0x50,%eax
   10f1c:	83 ec 04             	sub    $0x4,%esp
   10f1f:	6a 68                	push   $0x68
   10f21:	6a 00                	push   $0x0
   10f23:	50                   	push   %eax
   10f24:	e8 20 27 00 00       	call   13649 <kernel_memset>
   10f29:	83 c4 10             	add    $0x10,%esp

    // 分配内核栈，得到的是物理地址
    uint32_t kernel_stack = memory_alloc_page();
   10f2c:	e8 cb fc ff ff       	call   10bfc <memory_alloc_page>
   10f31:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (kernel_stack == 0)
   10f34:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10f38:	0f 84 fc 00 00 00    	je     1103a <tss_init+0x16b>

    int code_sel, data_sel;
    // code_sel = task_manager.app_code_sel | SEG_CPL3;
    // data_sel = task_manager.app_data_sel | SEG_CPL3;
    // 根据不同的权限选择不同的访问选择子
    if (flag & TASK_FLAG_SYSTEM)
   10f3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f41:	83 e0 01             	and    $0x1,%eax
   10f44:	85 c0                	test   %eax,%eax
   10f46:	74 10                	je     10f58 <tss_init+0x89>
    {
        code_sel = KERNEL_SELECTOR_CS;
   10f48:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel = KERNEL_SELECTOR_DS;
   10f4f:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   10f56:	eb 16                	jmp    10f6e <tss_init+0x9f>
    }
    else
    {
        // 注意加了RP3,不然将产生段保护错误
        code_sel = task_manager.app_code_sel | SEG_CPL3;
   10f58:	a1 a0 b1 01 00       	mov    0x1b1a0,%eax
   10f5d:	83 c8 03             	or     $0x3,%eax
   10f60:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel = task_manager.app_data_sel | SEG_CPL3;
   10f63:	a1 a4 b1 01 00       	mov    0x1b1a4,%eax
   10f68:	83 c8 03             	or     $0x3,%eax
   10f6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip = entry;
   10f6e:	8b 45 08             	mov    0x8(%ebp),%eax
   10f71:	8b 55 10             	mov    0x10(%ebp),%edx
   10f74:	89 50 70             	mov    %edx,0x70(%eax)
    // task->tss.esp = task->tss.esp0 = esp;
    task->tss.esp = esp ? esp : kernel_stack + MEM_PAGE_SIZE; // 未指定栈则用内核栈，即运行在特权级0的进程
   10f77:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10f7b:	75 0a                	jne    10f87 <tss_init+0xb8>
   10f7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f80:	05 00 10 00 00       	add    $0x1000,%eax
   10f85:	eb 03                	jmp    10f8a <tss_init+0xbb>
   10f87:	8b 45 14             	mov    0x14(%ebp),%eax
   10f8a:	8b 55 08             	mov    0x8(%ebp),%edx
   10f8d:	89 82 88 00 00 00    	mov    %eax,0x88(%edx)
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE;
   10f93:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f96:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   10f9c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f9f:	89 50 54             	mov    %edx,0x54(%eax)
    task->tss.ss = data_sel;            // 特权3
   10fa2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10fa5:	8b 45 08             	mov    0x8(%ebp),%eax
   10fa8:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
    task->tss.ss0 = KERNEL_SELECTOR_DS; // 特权0
   10fae:	8b 45 08             	mov    0x8(%ebp),%eax
   10fb1:	c7 40 58 10 00 00 00 	movl   $0x10,0x58(%eax)
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = data_sel;
   10fb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10fbb:	8b 45 08             	mov    0x8(%ebp),%eax
   10fbe:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
   10fc4:	8b 45 08             	mov    0x8(%ebp),%eax
   10fc7:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd0:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
   10fd6:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd9:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
   10fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   10fe2:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
   10fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   10feb:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   10ff1:	8b 45 08             	mov    0x8(%ebp),%eax
   10ff4:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
    task->tss.cs = code_sel;
   10ffa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10ffd:	8b 45 08             	mov    0x8(%ebp),%eax
   11000:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
   11006:	8b 45 08             	mov    0x8(%ebp),%eax
   11009:	c7 40 74 02 02 00 00 	movl   $0x202,0x74(%eax)

    // 页表初始化
    uint32_t page_dir = memory_create_uvm();
   11010:	e8 69 f7 ff ff       	call   1077e <memory_create_uvm>
   11015:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (page_dir == 0)
   11018:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1101c:	74 1f                	je     1103d <tss_init+0x16e>
    {
        goto tss_init_failed;
    }
    task->tss.cr3 = page_dir;
   1101e:	8b 45 08             	mov    0x8(%ebp),%eax
   11021:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   11024:	89 50 6c             	mov    %edx,0x6c(%eax)
    task->tss_sel = tss_sel;
   11027:	8b 45 08             	mov    0x8(%ebp),%eax
   1102a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1102d:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)
    return 0;
   11033:	b8 00 00 00 00       	mov    $0x0,%eax
   11038:	eb 2b                	jmp    11065 <tss_init+0x196>
        goto tss_init_failed;
   1103a:	90                   	nop
   1103b:	eb 01                	jmp    1103e <tss_init+0x16f>
        goto tss_init_failed;
   1103d:	90                   	nop
tss_init_failed:
    gdt_free_sel(tss_sel);
   1103e:	83 ec 0c             	sub    $0xc,%esp
   11041:	ff 75 ec             	pushl  -0x14(%ebp)
   11044:	e8 29 10 00 00       	call   12072 <gdt_free_sel>
   11049:	83 c4 10             	add    $0x10,%esp

    if (kernel_stack)
   1104c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11050:	74 0e                	je     11060 <tss_init+0x191>
    {
        memory_free_page(kernel_stack);
   11052:	83 ec 0c             	sub    $0xc,%esp
   11055:	ff 75 e8             	pushl  -0x18(%ebp)
   11058:	e8 b9 fb ff ff       	call   10c16 <memory_free_page>
   1105d:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11060:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11065:	c9                   	leave  
   11066:	c3                   	ret    

00011067 <task_init>:

int task_init(task_t *task, const char *name, int flag, uint32_t entry, uint32_t esp)
{
   11067:	55                   	push   %ebp
   11068:	89 e5                	mov    %esp,%ebp
   1106a:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task_t *)0);
   1106d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11071:	75 19                	jne    1108c <task_init+0x25>
   11073:	68 07 41 01 00       	push   $0x14107
   11078:	68 8c 42 01 00       	push   $0x1428c
   1107d:	6a 57                	push   $0x57
   1107f:	68 1c 41 01 00       	push   $0x1411c
   11084:	e8 e9 28 00 00       	call   13972 <panic>
   11089:	83 c4 10             	add    $0x10,%esp

    int err = tss_init(task, flag, entry, esp);
   1108c:	ff 75 18             	pushl  0x18(%ebp)
   1108f:	ff 75 14             	pushl  0x14(%ebp)
   11092:	ff 75 10             	pushl  0x10(%ebp)
   11095:	ff 75 08             	pushl  0x8(%ebp)
   11098:	e8 32 fe ff ff       	call   10ecf <tss_init>
   1109d:	83 c4 10             	add    $0x10,%esp
   110a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err < 0)
   110a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110a7:	79 18                	jns    110c1 <task_init+0x5a>
    {
        log_printf("init task failed.\n");
   110a9:	83 ec 0c             	sub    $0xc,%esp
   110ac:	68 56 41 01 00       	push   $0x14156
   110b1:	e8 12 2c 00 00       	call   13cc8 <log_printf>
   110b6:	83 c4 10             	add    $0x10,%esp
        return err;
   110b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110bc:	e9 b1 00 00 00       	jmp    11172 <task_init+0x10b>
    }

    // 任务字段初始化
    kernel_strncpy(task->name, name, TASK_NAME_SIZE);
   110c1:	8b 45 08             	mov    0x8(%ebp),%eax
   110c4:	83 c0 04             	add    $0x4,%eax
   110c7:	83 ec 04             	sub    $0x4,%esp
   110ca:	6a 20                	push   $0x20
   110cc:	ff 75 0c             	pushl  0xc(%ebp)
   110cf:	50                   	push   %eax
   110d0:	e8 fc 23 00 00       	call   134d1 <kernel_strncpy>
   110d5:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_CREATED;
   110d8:	8b 45 08             	mov    0x8(%ebp),%eax
   110db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->sleep_ticks = 0;
   110e1:	8b 45 08             	mov    0x8(%ebp),%eax
   110e4:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   110eb:	8b 45 08             	mov    0x8(%ebp),%eax
   110ee:	c7 40 30 0a 00 00 00 	movl   $0xa,0x30(%eax)
    task->slice_ticks = task->time_ticks;
   110f5:	8b 45 08             	mov    0x8(%ebp),%eax
   110f8:	8b 50 30             	mov    0x30(%eax),%edx
   110fb:	8b 45 08             	mov    0x8(%ebp),%eax
   110fe:	89 50 34             	mov    %edx,0x34(%eax)
    list_node_init(&task->all_node);
   11101:	8b 45 08             	mov    0x8(%ebp),%eax
   11104:	83 c0 48             	add    $0x48,%eax
   11107:	83 ec 0c             	sub    $0xc,%esp
   1110a:	50                   	push   %eax
   1110b:	e8 54 fd ff ff       	call   10e64 <list_node_init>
   11110:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   11113:	8b 45 08             	mov    0x8(%ebp),%eax
   11116:	83 c0 38             	add    $0x38,%eax
   11119:	83 ec 0c             	sub    $0xc,%esp
   1111c:	50                   	push   %eax
   1111d:	e8 42 fd ff ff       	call   10e64 <list_node_init>
   11122:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   11125:	8b 45 08             	mov    0x8(%ebp),%eax
   11128:	83 c0 40             	add    $0x40,%eax
   1112b:	83 ec 0c             	sub    $0xc,%esp
   1112e:	50                   	push   %eax
   1112f:	e8 30 fd ff ff       	call   10e64 <list_node_init>
   11134:	83 c4 10             	add    $0x10,%esp

    irq_state_t state = irq_enter_protection();
   11137:	e8 28 1a 00 00       	call   12b64 <irq_enter_protection>
   1113c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task->pid = (uint32_t)task;
   1113f:	8b 55 08             	mov    0x8(%ebp),%edx
   11142:	8b 45 08             	mov    0x8(%ebp),%eax
   11145:	89 50 24             	mov    %edx,0x24(%eax)
    // task_set_ready(task);
    list_insert_last(&task_manager.task_list, &task->all_node); // 插入所有task进队尾
   11148:	8b 45 08             	mov    0x8(%ebp),%eax
   1114b:	83 c0 48             	add    $0x48,%eax
   1114e:	83 ec 08             	sub    $0x8,%esp
   11151:	50                   	push   %eax
   11152:	68 10 b0 01 00       	push   $0x1b010
   11157:	e8 56 29 00 00       	call   13ab2 <list_insert_last>
   1115c:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   1115f:	83 ec 0c             	sub    $0xc,%esp
   11162:	ff 75 f0             	pushl  -0x10(%ebp)
   11165:	e8 12 1a 00 00       	call   12b7c <irq_leave_protection>
   1116a:	83 c4 10             	add    $0x10,%esp
    return 0;
   1116d:	b8 00 00 00 00       	mov    $0x0,%eax
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    // }
}
   11172:	c9                   	leave  
   11173:	c3                   	ret    

00011174 <task_switch_from_to>:

void task_switch_from_to(task_t *from, task_t *to)
{
   11174:	55                   	push   %ebp
   11175:	89 e5                	mov    %esp,%ebp
   11177:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   1117a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1117d:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11183:	83 ec 0c             	sub    $0xc,%esp
   11186:	50                   	push   %eax
   11187:	e8 84 10 00 00       	call   12210 <switch_to_tss>
   1118c:	83 c4 10             	add    $0x10,%esp
    // simple_switch(&from->stack, to->stack);
}
   1118f:	90                   	nop
   11190:	c9                   	leave  
   11191:	c3                   	ret    

00011192 <task_start>:

/**
 * @brief 启动任务
 */
void task_start(task_t *task)
{
   11192:	55                   	push   %ebp
   11193:	89 e5                	mov    %esp,%ebp
   11195:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11198:	e8 c7 19 00 00       	call   12b64 <irq_enter_protection>
   1119d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   111a0:	83 ec 0c             	sub    $0xc,%esp
   111a3:	ff 75 08             	pushl  0x8(%ebp)
   111a6:	e8 e8 01 00 00       	call   11393 <task_set_ready>
   111ab:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   111ae:	83 ec 0c             	sub    $0xc,%esp
   111b1:	ff 75 f4             	pushl  -0xc(%ebp)
   111b4:	e8 c3 19 00 00       	call   12b7c <irq_leave_protection>
   111b9:	83 c4 10             	add    $0x10,%esp
}
   111bc:	90                   	nop
   111bd:	c9                   	leave  
   111be:	c3                   	ret    

000111bf <task_first_init>:
 * 不过，考虑到init可能用到newlib库，如果与kernel合并编译，在lds中很难控制将newlib的
 * 代码与init进程的放在一起，有可能与kernel放在了一起。
 * 综上，最好是分离。
 */
void task_first_init(void)
{
   111bf:	55                   	push   %ebp
   111c0:	89 e5                	mov    %esp,%ebp
   111c2:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    // 以下获得的是bin文件在内存中的物理地址，起始和结束
    extern uint8_t s_first_task[], e_first_task[];
    // 分配的空间比实际存储的空间要大一些，多余的用于放置栈
    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task);
   111c5:	ba 13 ae 03 00       	mov    $0x3ae13,%edx
   111ca:	b8 38 ac 03 00       	mov    $0x3ac38,%eax
   111cf:	29 c2                	sub    %eax,%edx
   111d1:	89 d0                	mov    %edx,%eax
   111d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
   111d6:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   111dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   111e0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   111e3:	72 1c                	jb     11201 <task_first_init+0x42>
   111e5:	68 69 41 01 00       	push   $0x14169
   111ea:	68 98 42 01 00       	push   $0x14298
   111ef:	68 9c 00 00 00       	push   $0x9c
   111f4:	68 1c 41 01 00       	push   $0x1411c
   111f9:	e8 74 27 00 00       	call   13972 <panic>
   111fe:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start = (uint32_t)first_task_entry;
   11201:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
    task_init(&task_manager.first_task, "first task", 0, first_start, first_start + alloc_size);
   11208:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1120b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1120e:	01 d0                	add    %edx,%eax
   11210:	83 ec 0c             	sub    $0xc,%esp
   11213:	50                   	push   %eax
   11214:	ff 75 ec             	pushl  -0x14(%ebp)
   11217:	6a 00                	push   $0x0
   11219:	68 80 41 01 00       	push   $0x14180
   1121e:	68 28 b0 01 00       	push   $0x1b028
   11223:	e8 3f fe ff ff       	call   11067 <task_init>
   11228:	83 c4 20             	add    $0x20,%esp
    // 写TR寄存器，指示当前运行的第一个任务
    write_tr(task_manager.first_task.tss_sel);
   1122b:	a1 e0 b0 01 00       	mov    0x1b0e0,%eax
   11230:	83 ec 0c             	sub    $0xc,%esp
   11233:	50                   	push   %eax
   11234:	e8 79 fc ff ff       	call   10eb2 <write_tr>
   11239:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = &task_manager.first_task;
   1123c:	c7 05 00 b0 01 00 28 	movl   $0x1b028,0x1b000
   11243:	b0 01 00 

    // 切换页表
    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   11246:	a1 94 b0 01 00       	mov    0x1b094,%eax
   1124b:	83 ec 0c             	sub    $0xc,%esp
   1124e:	50                   	push   %eax
   1124f:	e8 6a fc ff ff       	call   10ebe <mmu_set_page_dir>
   11254:	83 c4 10             	add    $0x10,%esp

    // 分配一页内存供代码存放使用，然后将代码复制过去
    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);
   11257:	83 ec 04             	sub    $0x4,%esp
   1125a:	6a 07                	push   $0x7
   1125c:	ff 75 f0             	pushl  -0x10(%ebp)
   1125f:	ff 75 ec             	pushl  -0x14(%ebp)
   11262:	e8 48 fa ff ff       	call   10caf <memory_alloc_page_for>
   11267:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void *)first_start, (void *)&s_first_task, copy_size);
   1126a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1126d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11270:	83 ec 04             	sub    $0x4,%esp
   11273:	52                   	push   %edx
   11274:	68 38 ac 03 00       	push   $0x3ac38
   11279:	50                   	push   %eax
   1127a:	e8 7b 23 00 00       	call   135fa <kernel_memcpy>
   1127f:	83 c4 10             	add    $0x10,%esp

    // 启动进程
    task_start(&task_manager.first_task);
   11282:	83 ec 0c             	sub    $0xc,%esp
   11285:	68 28 b0 01 00       	push   $0x1b028
   1128a:	e8 03 ff ff ff       	call   11192 <task_start>
   1128f:	83 c4 10             	add    $0x10,%esp

    // 写TR寄存器，指示当前运行的第一个任务
    // write_tr(task_manager.first_task.tss_sel);
}
   11292:	90                   	nop
   11293:	c9                   	leave  
   11294:	c3                   	ret    

00011295 <task_first_task>:

/**
 * @brief 返回初始任务
 */
task_t *task_first_task(void)
{
   11295:	55                   	push   %ebp
   11296:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   11298:	b8 28 b0 01 00       	mov    $0x1b028,%eax
}
   1129d:	5d                   	pop    %ebp
   1129e:	c3                   	ret    

0001129f <idle_task_entry>:

static void idle_task_entry(void)
{
   1129f:	55                   	push   %ebp
   112a0:	89 e5                	mov    %esp,%ebp
    for (;;)
    {
        hlt();
   112a2:	e8 04 fc ff ff       	call   10eab <hlt>
   112a7:	eb f9                	jmp    112a2 <idle_task_entry+0x3>

000112a9 <task_manager_init>:
    }
}

void task_manager_init(void)
{
   112a9:	55                   	push   %ebp
   112aa:	89 e5                	mov    %esp,%ebp
   112ac:	83 ec 18             	sub    $0x18,%esp
    kernel_memset(task_table, 0, sizeof(task_table));
   112af:	83 ec 04             	sub    $0x4,%esp
   112b2:	68 00 5e 00 00       	push   $0x5e00
   112b7:	6a 00                	push   $0x0
   112b9:	68 c0 b1 01 00       	push   $0x1b1c0
   112be:	e8 86 23 00 00       	call   13649 <kernel_memset>
   112c3:	83 c4 10             	add    $0x10,%esp
    mutex_init(&task_table_mutex);
   112c6:	83 ec 0c             	sub    $0xc,%esp
   112c9:	68 c0 0f 02 00       	push   $0x20fc0
   112ce:	e8 a8 1c 00 00       	call   12f7b <mutex_init>
   112d3:	83 c4 10             	add    $0x10,%esp

    int sel = get_alloc_desc();
   112d6:	e8 d0 0d 00 00       	call   120ab <get_alloc_desc>
   112db:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0x00000000, 0xFFFFFFFF,
   112de:	68 f2 40 00 00       	push   $0x40f2
   112e3:	6a ff                	push   $0xffffffff
   112e5:	6a 00                	push   $0x0
   112e7:	ff 75 f4             	pushl  -0xc(%ebp)
   112ea:	e8 04 0d 00 00       	call   11ff3 <segment_desc_set>
   112ef:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |
                         SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    task_manager.app_data_sel = sel;
   112f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112f5:	a3 a4 b1 01 00       	mov    %eax,0x1b1a4

    sel = get_alloc_desc();
   112fa:	e8 ac 0d 00 00       	call   120ab <get_alloc_desc>
   112ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0x00000000, 0xFFFFFFFF,
   11302:	68 fa 40 00 00       	push   $0x40fa
   11307:	6a ff                	push   $0xffffffff
   11309:	6a 00                	push   $0x0
   1130b:	ff 75 f4             	pushl  -0xc(%ebp)
   1130e:	e8 e0 0c 00 00       	call   11ff3 <segment_desc_set>
   11313:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |
                         SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
    task_manager.app_code_sel = sel;
   11316:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11319:	a3 a0 b1 01 00       	mov    %eax,0x1b1a0

    // 各队列初始化
    list_init(&task_manager.ready_list);
   1131e:	83 ec 0c             	sub    $0xc,%esp
   11321:	68 04 b0 01 00       	push   $0x1b004
   11326:	e8 03 27 00 00       	call   13a2e <list_init>
   1132b:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   1132e:	83 ec 0c             	sub    $0xc,%esp
   11331:	68 10 b0 01 00       	push   $0x1b010
   11336:	e8 f3 26 00 00       	call   13a2e <list_init>
   1133b:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   1133e:	83 ec 0c             	sub    $0xc,%esp
   11341:	68 1c b0 01 00       	push   $0x1b01c
   11346:	e8 e3 26 00 00       	call   13a2e <list_init>
   1134b:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = (task_t *)0;
   1134e:	c7 05 00 b0 01 00 00 	movl   $0x0,0x1b000
   11355:	00 00 00 

    task_init(&task_manager.idle_task, "idle_task", TASK_FLAG_SYSTEM, (uint32_t)idle_task_entry, (uint32_t)idle_task_stack + 1024);
   11358:	b8 00 a0 01 00       	mov    $0x1a000,%eax
   1135d:	05 00 04 00 00       	add    $0x400,%eax
   11362:	ba 9f 12 01 00       	mov    $0x1129f,%edx
   11367:	83 ec 0c             	sub    $0xc,%esp
   1136a:	50                   	push   %eax
   1136b:	52                   	push   %edx
   1136c:	6a 01                	push   $0x1
   1136e:	68 8b 41 01 00       	push   $0x1418b
   11373:	68 e4 b0 01 00       	push   $0x1b0e4
   11378:	e8 ea fc ff ff       	call   11067 <task_init>
   1137d:	83 c4 20             	add    $0x20,%esp
    task_start(&task_manager.idle_task);
   11380:	83 ec 0c             	sub    $0xc,%esp
   11383:	68 e4 b0 01 00       	push   $0x1b0e4
   11388:	e8 05 fe ff ff       	call   11192 <task_start>
   1138d:	83 c4 10             	add    $0x10,%esp
}
   11390:	90                   	nop
   11391:	c9                   	leave  
   11392:	c3                   	ret    

00011393 <task_set_ready>:

/**
 * @brief 将任务插入就绪队列
 */
void task_set_ready(task_t *task)
{
   11393:	55                   	push   %ebp
   11394:	89 e5                	mov    %esp,%ebp
   11396:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   11399:	81 7d 08 e4 b0 01 00 	cmpl   $0x1b0e4,0x8(%ebp)
   113a0:	74 22                	je     113c4 <task_set_ready+0x31>
    {
        return;
    }
    list_insert_last(&task_manager.ready_list, &task->run_node);
   113a2:	8b 45 08             	mov    0x8(%ebp),%eax
   113a5:	83 c0 38             	add    $0x38,%eax
   113a8:	83 ec 08             	sub    $0x8,%esp
   113ab:	50                   	push   %eax
   113ac:	68 04 b0 01 00       	push   $0x1b004
   113b1:	e8 fc 26 00 00       	call   13ab2 <list_insert_last>
   113b6:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;
   113b9:	8b 45 08             	mov    0x8(%ebp),%eax
   113bc:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   113c2:	eb 01                	jmp    113c5 <task_set_ready+0x32>
        return;
   113c4:	90                   	nop
}
   113c5:	c9                   	leave  
   113c6:	c3                   	ret    

000113c7 <task_set_block>:

/**
 * @brief 将任务从就绪队列移除
 */
void task_set_block(task_t *task)
{
   113c7:	55                   	push   %ebp
   113c8:	89 e5                	mov    %esp,%ebp
   113ca:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   113cd:	81 7d 08 e4 b0 01 00 	cmpl   $0x1b0e4,0x8(%ebp)
   113d4:	74 19                	je     113ef <task_set_block+0x28>
    {
        return;
    }
    list_remove(&task_manager.ready_list, &task->run_node);
   113d6:	8b 45 08             	mov    0x8(%ebp),%eax
   113d9:	83 c0 38             	add    $0x38,%eax
   113dc:	83 ec 08             	sub    $0x8,%esp
   113df:	50                   	push   %eax
   113e0:	68 04 b0 01 00       	push   $0x1b004
   113e5:	e8 a4 27 00 00       	call   13b8e <list_remove>
   113ea:	83 c4 10             	add    $0x10,%esp
   113ed:	eb 01                	jmp    113f0 <task_set_block+0x29>
        return;
   113ef:	90                   	nop
}
   113f0:	c9                   	leave  
   113f1:	c3                   	ret    

000113f2 <task_current>:

/**
 * @brief 获取当前正在运行的任务
 */
task_t *task_current(void)
{
   113f2:	55                   	push   %ebp
   113f3:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   113f5:	a1 00 b0 01 00       	mov    0x1b000,%eax
}
   113fa:	5d                   	pop    %ebp
   113fb:	c3                   	ret    

000113fc <sys_sched_yield>:

int sys_sched_yield(void)
{
   113fc:	55                   	push   %ebp
   113fd:	89 e5                	mov    %esp,%ebp
   113ff:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11402:	e8 5d 17 00 00       	call   12b64 <irq_enter_protection>
   11407:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (list_count(&task_manager.ready_list) > 1)
   1140a:	83 ec 0c             	sub    $0xc,%esp
   1140d:	68 04 b0 01 00       	push   $0x1b004
   11412:	e8 73 fa ff ff       	call   10e8a <list_count>
   11417:	83 c4 10             	add    $0x10,%esp
   1141a:	83 f8 01             	cmp    $0x1,%eax
   1141d:	7e 29                	jle    11448 <sys_sched_yield+0x4c>
    {
        task_t *curr_task = task_current();
   1141f:	e8 ce ff ff ff       	call   113f2 <task_current>
   11424:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        task_set_block(curr_task);
   11427:	83 ec 0c             	sub    $0xc,%esp
   1142a:	ff 75 f0             	pushl  -0x10(%ebp)
   1142d:	e8 95 ff ff ff       	call   113c7 <task_set_block>
   11432:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   11435:	83 ec 0c             	sub    $0xc,%esp
   11438:	ff 75 f0             	pushl  -0x10(%ebp)
   1143b:	e8 53 ff ff ff       	call   11393 <task_set_ready>
   11440:	83 c4 10             	add    $0x10,%esp

        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
   11443:	e8 58 00 00 00       	call   114a0 <task_dispatch>
    }
    irq_leave_protection(state);
   11448:	83 ec 0c             	sub    $0xc,%esp
   1144b:	ff 75 f4             	pushl  -0xc(%ebp)
   1144e:	e8 29 17 00 00       	call   12b7c <irq_leave_protection>
   11453:	83 c4 10             	add    $0x10,%esp
    return 0;
   11456:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1145b:	c9                   	leave  
   1145c:	c3                   	ret    

0001145d <task_next_run>:

/**
 * @brief 获取下一将要运行的任务
 */
static task_t *task_next_run(void)
{
   1145d:	55                   	push   %ebp
   1145e:	89 e5                	mov    %esp,%ebp
   11460:	83 ec 10             	sub    $0x10,%esp
    if (list_count(&task_manager.ready_list) == 0)
   11463:	68 04 b0 01 00       	push   $0x1b004
   11468:	e8 1d fa ff ff       	call   10e8a <list_count>
   1146d:	83 c4 04             	add    $0x4,%esp
   11470:	85 c0                	test   %eax,%eax
   11472:	75 07                	jne    1147b <task_next_run+0x1e>
    {
        return &task_manager.idle_task;
   11474:	b8 e4 b0 01 00       	mov    $0x1b0e4,%eax
   11479:	eb 23                	jmp    1149e <task_next_run+0x41>
    }

    // 普通任务
    list_node_t *task_node = list_first(&task_manager.ready_list);
   1147b:	68 04 b0 01 00       	push   $0x1b004
   11480:	e8 10 fa ff ff       	call   10e95 <list_first>
   11485:	83 c4 04             	add    $0x4,%esp
   11488:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node, task_t, run_node);
   1148b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1148f:	74 08                	je     11499 <task_next_run+0x3c>
   11491:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11494:	83 e8 38             	sub    $0x38,%eax
   11497:	eb 05                	jmp    1149e <task_next_run+0x41>
   11499:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1149e:	c9                   	leave  
   1149f:	c3                   	ret    

000114a0 <task_dispatch>:

/**
 * @brief 进行一次任务调度
 */
void task_dispatch(void)
{
   114a0:	55                   	push   %ebp
   114a1:	89 e5                	mov    %esp,%ebp
   114a3:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   114a6:	e8 b9 16 00 00       	call   12b64 <irq_enter_protection>
   114ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *to = task_next_run();
   114ae:	e8 aa ff ff ff       	call   1145d <task_next_run>
   114b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (to != task_manager.curr_task)
   114b6:	a1 00 b0 01 00       	mov    0x1b000,%eax
   114bb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   114be:	74 2a                	je     114ea <task_dispatch+0x4a>
    {
        task_t *from = task_manager.curr_task;
   114c0:	a1 00 b0 01 00       	mov    0x1b000,%eax
   114c5:	89 45 ec             	mov    %eax,-0x14(%ebp)

        task_manager.curr_task = to;
   114c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114cb:	a3 00 b0 01 00       	mov    %eax,0x1b000
        to->state = TASK_RUNNING;
   114d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114d3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from, to);
   114d9:	83 ec 08             	sub    $0x8,%esp
   114dc:	ff 75 f0             	pushl  -0x10(%ebp)
   114df:	ff 75 ec             	pushl  -0x14(%ebp)
   114e2:	e8 8d fc ff ff       	call   11174 <task_switch_from_to>
   114e7:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   114ea:	83 ec 0c             	sub    $0xc,%esp
   114ed:	ff 75 f4             	pushl  -0xc(%ebp)
   114f0:	e8 87 16 00 00       	call   12b7c <irq_leave_protection>
   114f5:	83 c4 10             	add    $0x10,%esp
}
   114f8:	90                   	nop
   114f9:	c9                   	leave  
   114fa:	c3                   	ret    

000114fb <task_time_tick>:
/**
 * @brief 时间处理
 * 该函数在中断处理函数中调用
 */
void task_time_tick(void)
{
   114fb:	55                   	push   %ebp
   114fc:	89 e5                	mov    %esp,%ebp
   114fe:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   11501:	e8 ec fe ff ff       	call   113f2 <task_current>
   11506:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_state_t state = irq_enter_protection();
   11509:	e8 56 16 00 00       	call   12b64 <irq_enter_protection>
   1150e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (--curr_task->slice_ticks == 0)
   11511:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11514:	8b 40 34             	mov    0x34(%eax),%eax
   11517:	8d 50 ff             	lea    -0x1(%eax),%edx
   1151a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1151d:	89 50 34             	mov    %edx,0x34(%eax)
   11520:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11523:	8b 40 34             	mov    0x34(%eax),%eax
   11526:	85 c0                	test   %eax,%eax
   11528:	75 28                	jne    11552 <task_time_tick+0x57>
    {
        // 时间片用完，重新加载时间片
        // 对于空闲任务，此处减未用
        curr_task->slice_ticks = curr_task->time_ticks;
   1152a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1152d:	8b 50 30             	mov    0x30(%eax),%edx
   11530:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11533:	89 50 34             	mov    %edx,0x34(%eax)

        // 调整队列的位置到尾部，不用直接操作队列
        task_set_block(curr_task);
   11536:	83 ec 0c             	sub    $0xc,%esp
   11539:	ff 75 f0             	pushl  -0x10(%ebp)
   1153c:	e8 86 fe ff ff       	call   113c7 <task_set_block>
   11541:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   11544:	83 ec 0c             	sub    $0xc,%esp
   11547:	ff 75 f0             	pushl  -0x10(%ebp)
   1154a:	e8 44 fe ff ff       	call   11393 <task_set_ready>
   1154f:	83 c4 10             	add    $0x10,%esp
    }

    // 睡眠处理
    list_node_t *curr = list_first(&task_manager.sleep_list);
   11552:	83 ec 0c             	sub    $0xc,%esp
   11555:	68 1c b0 01 00       	push   $0x1b01c
   1155a:	e8 36 f9 ff ff       	call   10e95 <list_first>
   1155f:	83 c4 10             	add    $0x10,%esp
   11562:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   11565:	eb 62                	jmp    115c9 <task_time_tick+0xce>
    {
        list_node_t *next = list_node_next(curr);
   11567:	83 ec 0c             	sub    $0xc,%esp
   1156a:	ff 75 f4             	pushl  -0xc(%ebp)
   1156d:	e8 0d f9 ff ff       	call   10e7f <list_node_next>
   11572:	83 c4 10             	add    $0x10,%esp
   11575:	89 45 e8             	mov    %eax,-0x18(%ebp)

        task_t *task = list_node_parent(curr, task_t, run_node);
   11578:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1157c:	74 08                	je     11586 <task_time_tick+0x8b>
   1157e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11581:	83 e8 38             	sub    $0x38,%eax
   11584:	eb 05                	jmp    1158b <task_time_tick+0x90>
   11586:	b8 00 00 00 00       	mov    $0x0,%eax
   1158b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (--task->sleep_ticks == 0)
   1158e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11591:	8b 40 2c             	mov    0x2c(%eax),%eax
   11594:	8d 50 ff             	lea    -0x1(%eax),%edx
   11597:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1159a:	89 50 2c             	mov    %edx,0x2c(%eax)
   1159d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   115a0:	8b 40 2c             	mov    0x2c(%eax),%eax
   115a3:	85 c0                	test   %eax,%eax
   115a5:	75 1c                	jne    115c3 <task_time_tick+0xc8>
        {
            // 延时时间到达，从睡眠队列中移除，送至就绪队列
            task_set_wakeup(task);
   115a7:	83 ec 0c             	sub    $0xc,%esp
   115aa:	ff 75 e4             	pushl  -0x1c(%ebp)
   115ad:	e8 6d 00 00 00       	call   1161f <task_set_wakeup>
   115b2:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   115b5:	83 ec 0c             	sub    $0xc,%esp
   115b8:	ff 75 e4             	pushl  -0x1c(%ebp)
   115bb:	e8 d3 fd ff ff       	call   11393 <task_set_ready>
   115c0:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   115c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   115c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   115cd:	75 98                	jne    11567 <task_time_tick+0x6c>
    }
    task_dispatch();
   115cf:	e8 cc fe ff ff       	call   114a0 <task_dispatch>
    irq_leave_protection(state);
   115d4:	83 ec 0c             	sub    $0xc,%esp
   115d7:	ff 75 ec             	pushl  -0x14(%ebp)
   115da:	e8 9d 15 00 00       	call   12b7c <irq_leave_protection>
   115df:	83 c4 10             	add    $0x10,%esp
}
   115e2:	90                   	nop
   115e3:	c9                   	leave  
   115e4:	c3                   	ret    

000115e5 <task_set_sleep>:

/**
 * @brief 将任务加入睡眠状态
 */
void task_set_sleep(task_t *task, uint32_t ticks)
{
   115e5:	55                   	push   %ebp
   115e6:	89 e5                	mov    %esp,%ebp
   115e8:	83 ec 08             	sub    $0x8,%esp
    if (ticks <= 0)
   115eb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   115ef:	74 2b                	je     1161c <task_set_sleep+0x37>
    {
        return;
    }

    task->sleep_ticks = ticks;
   115f1:	8b 55 0c             	mov    0xc(%ebp),%edx
   115f4:	8b 45 08             	mov    0x8(%ebp),%eax
   115f7:	89 50 2c             	mov    %edx,0x2c(%eax)
    task->state = TASK_SLEEP;
   115fa:	8b 45 08             	mov    0x8(%ebp),%eax
   115fd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list, &task->run_node);
   11603:	8b 45 08             	mov    0x8(%ebp),%eax
   11606:	83 c0 38             	add    $0x38,%eax
   11609:	83 ec 08             	sub    $0x8,%esp
   1160c:	50                   	push   %eax
   1160d:	68 1c b0 01 00       	push   $0x1b01c
   11612:	e8 9b 24 00 00       	call   13ab2 <list_insert_last>
   11617:	83 c4 10             	add    $0x10,%esp
   1161a:	eb 01                	jmp    1161d <task_set_sleep+0x38>
        return;
   1161c:	90                   	nop
}
   1161d:	c9                   	leave  
   1161e:	c3                   	ret    

0001161f <task_set_wakeup>:
 * @brief 将任务从延时队列移除
 *
 * @param task
 */
void task_set_wakeup(task_t *task)
{
   1161f:	55                   	push   %ebp
   11620:	89 e5                	mov    %esp,%ebp
   11622:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list, &task->run_node);
   11625:	8b 45 08             	mov    0x8(%ebp),%eax
   11628:	83 c0 38             	add    $0x38,%eax
   1162b:	83 ec 08             	sub    $0x8,%esp
   1162e:	50                   	push   %eax
   1162f:	68 1c b0 01 00       	push   $0x1b01c
   11634:	e8 55 25 00 00       	call   13b8e <list_remove>
   11639:	83 c4 10             	add    $0x10,%esp
}
   1163c:	90                   	nop
   1163d:	c9                   	leave  
   1163e:	c3                   	ret    

0001163f <sys_msleep>:
 * @brief 任务进入睡眠状态
 *
 * @param ms
 */
void sys_msleep(uint32_t ms)
{
   1163f:	55                   	push   %ebp
   11640:	89 e5                	mov    %esp,%ebp
   11642:	83 ec 18             	sub    $0x18,%esp
    // 至少延时1个tick
    if (ms < OS_TICK_MS)
   11645:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   11649:	77 07                	ja     11652 <sys_msleep+0x13>
    {
        ms = OS_TICK_MS;
   1164b:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   11652:	e8 0d 15 00 00       	call   12b64 <irq_enter_protection>
   11657:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 从就绪队列移除，加入睡眠队列
    task_set_block(task_manager.curr_task);
   1165a:	a1 00 b0 01 00       	mov    0x1b000,%eax
   1165f:	83 ec 0c             	sub    $0xc,%esp
   11662:	50                   	push   %eax
   11663:	e8 5f fd ff ff       	call   113c7 <task_set_block>
   11668:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   1166b:	8b 45 08             	mov    0x8(%ebp),%eax
   1166e:	83 c0 09             	add    $0x9,%eax
   11671:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11676:	f7 e2                	mul    %edx
   11678:	c1 ea 03             	shr    $0x3,%edx
   1167b:	a1 00 b0 01 00       	mov    0x1b000,%eax
   11680:	83 ec 08             	sub    $0x8,%esp
   11683:	52                   	push   %edx
   11684:	50                   	push   %eax
   11685:	e8 5b ff ff ff       	call   115e5 <task_set_sleep>
   1168a:	83 c4 10             	add    $0x10,%esp

    // 进行一次调度
    task_dispatch();
   1168d:	e8 0e fe ff ff       	call   114a0 <task_dispatch>

    irq_leave_protection(state);
   11692:	83 ec 0c             	sub    $0xc,%esp
   11695:	ff 75 f4             	pushl  -0xc(%ebp)
   11698:	e8 df 14 00 00       	call   12b7c <irq_leave_protection>
   1169d:	83 c4 10             	add    $0x10,%esp
}
   116a0:	90                   	nop
   116a1:	c9                   	leave  
   116a2:	c3                   	ret    

000116a3 <alloc_task>:

/**
 * @brief 分配一个任务结构
 */
static task_t *alloc_task(void)
{
   116a3:	55                   	push   %ebp
   116a4:	89 e5                	mov    %esp,%ebp
   116a6:	83 ec 18             	sub    $0x18,%esp
    task_t *task = (task_t *)0;
   116a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&task_table_mutex);
   116b0:	83 ec 0c             	sub    $0xc,%esp
   116b3:	68 c0 0f 02 00       	push   $0x20fc0
   116b8:	e8 ec 18 00 00       	call   12fa9 <mutex_lock>
   116bd:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < TASK_NR; i++)
   116c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   116c7:	eb 28                	jmp    116f1 <alloc_task+0x4e>
    {
        task_t *curr = task_table + i;
   116c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116cc:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
   116d2:	05 c0 b1 01 00       	add    $0x1b1c0,%eax
   116d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (curr->name[0] == '\0')
   116da:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116dd:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   116e1:	84 c0                	test   %al,%al
   116e3:	75 08                	jne    116ed <alloc_task+0x4a>
        {
            task = curr;
   116e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   116eb:	eb 0a                	jmp    116f7 <alloc_task+0x54>
    for (int i = 0; i < TASK_NR; i++)
   116ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   116f1:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   116f5:	7e d2                	jle    116c9 <alloc_task+0x26>
        }
    }
    mutex_unlock(&task_table_mutex);
   116f7:	83 ec 0c             	sub    $0xc,%esp
   116fa:	68 c0 0f 02 00       	push   $0x20fc0
   116ff:	e8 39 19 00 00       	call   1303d <mutex_unlock>
   11704:	83 c4 10             	add    $0x10,%esp

    return task;
   11707:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1170a:	c9                   	leave  
   1170b:	c3                   	ret    

0001170c <free_task>:

/**
 * @brief 释放任务结构
 */
static void free_task(task_t *task)
{
   1170c:	55                   	push   %ebp
   1170d:	89 e5                	mov    %esp,%ebp
   1170f:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&task_table_mutex);
   11712:	83 ec 0c             	sub    $0xc,%esp
   11715:	68 c0 0f 02 00       	push   $0x20fc0
   1171a:	e8 8a 18 00 00       	call   12fa9 <mutex_lock>
   1171f:	83 c4 10             	add    $0x10,%esp
    task->name[0] = '\0';
   11722:	8b 45 08             	mov    0x8(%ebp),%eax
   11725:	c6 40 04 00          	movb   $0x0,0x4(%eax)
    mutex_unlock(&task_table_mutex);
   11729:	83 ec 0c             	sub    $0xc,%esp
   1172c:	68 c0 0f 02 00       	push   $0x20fc0
   11731:	e8 07 19 00 00       	call   1303d <mutex_unlock>
   11736:	83 c4 10             	add    $0x10,%esp
}
   11739:	90                   	nop
   1173a:	c9                   	leave  
   1173b:	c3                   	ret    

0001173c <sys_getpid>:

/**
 * 返回任务的pid
 */
int sys_getpid(void)
{
   1173c:	55                   	push   %ebp
   1173d:	89 e5                	mov    %esp,%ebp
   1173f:	83 ec 10             	sub    $0x10,%esp
    task_t *curr_task = task_current();
   11742:	e8 ab fc ff ff       	call   113f2 <task_current>
   11747:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return curr_task->pid;
   1174a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1174d:	8b 40 24             	mov    0x24(%eax),%eax
}
   11750:	c9                   	leave  
   11751:	c3                   	ret    

00011752 <task_uninit>:

/**
 * @brief 任务初始时分配的各项资源
 */
void task_uninit(task_t *task)
{
   11752:	55                   	push   %ebp
   11753:	89 e5                	mov    %esp,%ebp
   11755:	83 ec 08             	sub    $0x8,%esp
    if (task->tss_sel)
   11758:	8b 45 08             	mov    0x8(%ebp),%eax
   1175b:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11761:	85 c0                	test   %eax,%eax
   11763:	74 15                	je     1177a <task_uninit+0x28>
    {
        gdt_free_sel(task->tss_sel);
   11765:	8b 45 08             	mov    0x8(%ebp),%eax
   11768:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1176e:	83 ec 0c             	sub    $0xc,%esp
   11771:	50                   	push   %eax
   11772:	e8 fb 08 00 00       	call   12072 <gdt_free_sel>
   11777:	83 c4 10             	add    $0x10,%esp
    }

    if (task->tss.esp0)
   1177a:	8b 45 08             	mov    0x8(%ebp),%eax
   1177d:	8b 40 54             	mov    0x54(%eax),%eax
   11780:	85 c0                	test   %eax,%eax
   11782:	74 17                	je     1179b <task_uninit+0x49>
    {
        memory_free_page(task->tss.esp0 - MEM_PAGE_SIZE);
   11784:	8b 45 08             	mov    0x8(%ebp),%eax
   11787:	8b 40 54             	mov    0x54(%eax),%eax
   1178a:	2d 00 10 00 00       	sub    $0x1000,%eax
   1178f:	83 ec 0c             	sub    $0xc,%esp
   11792:	50                   	push   %eax
   11793:	e8 7e f4 ff ff       	call   10c16 <memory_free_page>
   11798:	83 c4 10             	add    $0x10,%esp
    }

    if (task->tss.cr3)
   1179b:	8b 45 08             	mov    0x8(%ebp),%eax
   1179e:	8b 40 6c             	mov    0x6c(%eax),%eax
   117a1:	85 c0                	test   %eax,%eax
   117a3:	74 12                	je     117b7 <task_uninit+0x65>
    {
        memory_destroy_uvm(task->tss.cr3);
   117a5:	8b 45 08             	mov    0x8(%ebp),%eax
   117a8:	8b 40 6c             	mov    0x6c(%eax),%eax
   117ab:	83 ec 0c             	sub    $0xc,%esp
   117ae:	50                   	push   %eax
   117af:	e8 4f f0 ff ff       	call   10803 <memory_destroy_uvm>
   117b4:	83 c4 10             	add    $0x10,%esp
    }

    kernel_memset(task, 0, sizeof(task_t));
   117b7:	83 ec 04             	sub    $0x4,%esp
   117ba:	68 bc 00 00 00       	push   $0xbc
   117bf:	6a 00                	push   $0x0
   117c1:	ff 75 08             	pushl  0x8(%ebp)
   117c4:	e8 80 1e 00 00       	call   13649 <kernel_memset>
   117c9:	83 c4 10             	add    $0x10,%esp
}
   117cc:	90                   	nop
   117cd:	c9                   	leave  
   117ce:	c3                   	ret    

000117cf <sys_fork>:

/**
 * @brief 创建进程的副本
 */
int sys_fork(void)
{
   117cf:	55                   	push   %ebp
   117d0:	89 e5                	mov    %esp,%ebp
   117d2:	83 ec 28             	sub    $0x28,%esp
    task_t *parent_task = task_current();
   117d5:	e8 18 fc ff ff       	call   113f2 <task_current>
   117da:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *child_task = alloc_task();
   117dd:	e8 c1 fe ff ff       	call   116a3 <alloc_task>
   117e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (child_task == (task_t *)0)
   117e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   117e9:	0f 84 36 01 00 00    	je     11925 <sys_fork+0x156>
    {
        goto fork_failed;
    }
    syscall_frame_t *frame = (syscall_frame_t *)(parent_task->tss.esp0 - sizeof(syscall_frame_t)); // 拿到父进程的寄存器
   117ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f2:	8b 40 54             	mov    0x54(%eax),%eax
   117f5:	83 e8 58             	sub    $0x58,%eax
   117f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    // 对子进程进行初始化，并对必要的字段进行调整
    // 其中esp要减去系统调用的总参数字节大小，因为其是通过正常的ret返回, 而没有走系统调用处理的ret(参数个数返回)
    int err = task_init(child_task, parent_task->name, 0, frame->eip,
                        frame->esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT);
   117fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117fe:	8b 40 50             	mov    0x50(%eax),%eax
   11801:	8d 50 14             	lea    0x14(%eax),%edx
    int err = task_init(child_task, parent_task->name, 0, frame->eip,
   11804:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11807:	8b 40 34             	mov    0x34(%eax),%eax
   1180a:	89 c1                	mov    %eax,%ecx
   1180c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1180f:	83 c0 04             	add    $0x4,%eax
   11812:	83 ec 0c             	sub    $0xc,%esp
   11815:	52                   	push   %edx
   11816:	51                   	push   %ecx
   11817:	6a 00                	push   $0x0
   11819:	50                   	push   %eax
   1181a:	ff 75 f0             	pushl  -0x10(%ebp)
   1181d:	e8 45 f8 ff ff       	call   11067 <task_init>
   11822:	83 c4 20             	add    $0x20,%esp
   11825:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0)
   11828:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1182c:	0f 88 f6 00 00 00    	js     11928 <sys_fork+0x159>
    {
        goto fork_failed;
    }
    // 从父进程的栈中取部分状态，然后写入tss。
    // 注意检查esp, eip等是否在用户空间范围内，不然会造成page_fault
    tss_t *tss = &child_task->tss;
   11832:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11835:	83 c0 50             	add    $0x50,%eax
   11838:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax = 0; // 子进程返回0
   1183b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1183e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx = frame->ebx;
   11845:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11848:	8b 40 24             	mov    0x24(%eax),%eax
   1184b:	89 c2                	mov    %eax,%edx
   1184d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11850:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx = frame->ecx;
   11853:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11856:	8b 40 2c             	mov    0x2c(%eax),%eax
   11859:	89 c2                	mov    %eax,%edx
   1185b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1185e:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx = frame->edx;
   11861:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11864:	8b 40 28             	mov    0x28(%eax),%eax
   11867:	89 c2                	mov    %eax,%edx
   11869:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1186c:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi = frame->esi;
   1186f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11872:	8b 40 18             	mov    0x18(%eax),%eax
   11875:	89 c2                	mov    %eax,%edx
   11877:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1187a:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi = frame->edi;
   1187d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11880:	8b 40 14             	mov    0x14(%eax),%eax
   11883:	89 c2                	mov    %eax,%edx
   11885:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11888:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp = frame->ebp;
   1188b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1188e:	8b 40 1c             	mov    0x1c(%eax),%eax
   11891:	89 c2                	mov    %eax,%edx
   11893:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11896:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs = frame->cs;
   11899:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1189c:	8b 40 38             	mov    0x38(%eax),%eax
   1189f:	89 c2                	mov    %eax,%edx
   118a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118a4:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds = frame->ds;
   118a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118aa:	8b 40 10             	mov    0x10(%eax),%eax
   118ad:	89 c2                	mov    %eax,%edx
   118af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118b2:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es = frame->es;
   118b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118b8:	8b 40 0c             	mov    0xc(%eax),%eax
   118bb:	89 c2                	mov    %eax,%edx
   118bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118c0:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs = frame->fs;
   118c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118c6:	8b 40 08             	mov    0x8(%eax),%eax
   118c9:	89 c2                	mov    %eax,%edx
   118cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118ce:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs = frame->gs;
   118d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118d4:	8b 40 04             	mov    0x4(%eax),%eax
   118d7:	89 c2                	mov    %eax,%edx
   118d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118dc:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags = frame->eflags;
   118df:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118e2:	8b 00                	mov    (%eax),%eax
   118e4:	89 c2                	mov    %eax,%edx
   118e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118e9:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent = parent_task;
   118ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118f2:	89 50 28             	mov    %edx,0x28(%eax)
    // 复制父进程的内存空间到子进程
    if ((child_task->tss.cr3 = memory_copy_uvm(parent_task->tss.cr3)) < 0)
   118f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118f8:	8b 40 6c             	mov    0x6c(%eax),%eax
   118fb:	83 ec 0c             	sub    $0xc,%esp
   118fe:	50                   	push   %eax
   118ff:	e8 0e f0 ff ff       	call   10912 <memory_copy_uvm>
   11904:	83 c4 10             	add    $0x10,%esp
   11907:	89 c2                	mov    %eax,%edx
   11909:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1190c:	89 50 6c             	mov    %edx,0x6c(%eax)
    {
        goto fork_failed;
    }
    // 创建成功，返回子进程的pid
    task_start(child_task);
   1190f:	83 ec 0c             	sub    $0xc,%esp
   11912:	ff 75 f0             	pushl  -0x10(%ebp)
   11915:	e8 78 f8 ff ff       	call   11192 <task_start>
   1191a:	83 c4 10             	add    $0x10,%esp
    return child_task->pid;
   1191d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11920:	8b 40 24             	mov    0x24(%eax),%eax
   11923:	eb 2b                	jmp    11950 <sys_fork+0x181>
        goto fork_failed;
   11925:	90                   	nop
   11926:	eb 01                	jmp    11929 <sys_fork+0x15a>
        goto fork_failed;
   11928:	90                   	nop
fork_failed:
    if (child_task)
   11929:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1192d:	74 1c                	je     1194b <sys_fork+0x17c>
    {
        task_uninit(child_task);
   1192f:	83 ec 0c             	sub    $0xc,%esp
   11932:	ff 75 f0             	pushl  -0x10(%ebp)
   11935:	e8 18 fe ff ff       	call   11752 <task_uninit>
   1193a:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   1193d:	83 ec 0c             	sub    $0xc,%esp
   11940:	ff 75 f0             	pushl  -0x10(%ebp)
   11943:	e8 c4 fd ff ff       	call   1170c <free_task>
   11948:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1194b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11950:	c9                   	leave  
   11951:	c3                   	ret    

00011952 <load_phdr>:

/**
 * @brief 加载一个程序表头的数据到内存中
 */
static int load_phdr(int file, Elf32_Phdr *phdr, uint32_t page_dir)
{
   11952:	55                   	push   %ebp
   11953:	89 e5                	mov    %esp,%ebp
   11955:	83 ec 28             	sub    $0x28,%esp
    // 生成的ELF文件要求是页边界对齐的
    ASSERT((phdr->p_vaddr & (MEM_PAGE_SIZE - 1)) == 0);
   11958:	8b 45 0c             	mov    0xc(%ebp),%eax
   1195b:	8b 40 08             	mov    0x8(%eax),%eax
   1195e:	25 ff 0f 00 00       	and    $0xfff,%eax
   11963:	85 c0                	test   %eax,%eax
   11965:	74 1c                	je     11983 <load_phdr+0x31>
   11967:	68 98 41 01 00       	push   $0x14198
   1196c:	68 a8 42 01 00       	push   $0x142a8
   11971:	68 08 02 00 00       	push   $0x208
   11976:	68 1c 41 01 00       	push   $0x1411c
   1197b:	e8 f2 1f 00 00       	call   13972 <panic>
   11980:	83 c4 10             	add    $0x10,%esp

    // 分配空间
    int err = memory_alloc_for_page_dir(page_dir, phdr->p_vaddr, phdr->p_memsz, PTE_P | PTE_U | PTE_W);
   11983:	8b 45 0c             	mov    0xc(%ebp),%eax
   11986:	8b 50 14             	mov    0x14(%eax),%edx
   11989:	8b 45 0c             	mov    0xc(%ebp),%eax
   1198c:	8b 40 08             	mov    0x8(%eax),%eax
   1198f:	6a 07                	push   $0x7
   11991:	52                   	push   %edx
   11992:	50                   	push   %eax
   11993:	ff 75 10             	pushl  0x10(%ebp)
   11996:	e8 95 f1 ff ff       	call   10b30 <memory_alloc_for_page_dir>
   1199b:	83 c4 10             	add    $0x10,%esp
   1199e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (err < 0)
   119a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   119a5:	79 1a                	jns    119c1 <load_phdr+0x6f>
    {
        log_printf("no memory");
   119a7:	83 ec 0c             	sub    $0xc,%esp
   119aa:	68 c3 41 01 00       	push   $0x141c3
   119af:	e8 14 23 00 00       	call   13cc8 <log_printf>
   119b4:	83 c4 10             	add    $0x10,%esp
        return -1;
   119b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   119bc:	e9 b8 00 00 00       	jmp    11a79 <load_phdr+0x127>
    }

    // 调整当前的读写位置
    if (sys_lseek(file, phdr->p_offset, 0) < 0)
   119c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   119c4:	8b 40 04             	mov    0x4(%eax),%eax
   119c7:	83 ec 04             	sub    $0x4,%esp
   119ca:	6a 00                	push   $0x0
   119cc:	50                   	push   %eax
   119cd:	ff 75 08             	pushl  0x8(%ebp)
   119d0:	e8 83 14 00 00       	call   12e58 <sys_lseek>
   119d5:	83 c4 10             	add    $0x10,%esp
   119d8:	85 c0                	test   %eax,%eax
   119da:	79 1a                	jns    119f6 <load_phdr+0xa4>
    {
        log_printf("read file failed");
   119dc:	83 ec 0c             	sub    $0xc,%esp
   119df:	68 cd 41 01 00       	push   $0x141cd
   119e4:	e8 df 22 00 00       	call   13cc8 <log_printf>
   119e9:	83 c4 10             	add    $0x10,%esp
        return -1;
   119ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   119f1:	e9 83 00 00 00       	jmp    11a79 <load_phdr+0x127>
    }

    // 为段分配所有的内存空间.后续操作如果失败，将在上层释放
    // 简单起见，设置成可写模式，也许可考虑根据phdr->flags设置成只读
    // 因为没有找到该值的详细定义，所以没有加上
    uint32_t vaddr = phdr->p_vaddr; // 内存中的起始地址
   119f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   119f9:	8b 40 08             	mov    0x8(%eax),%eax
   119fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size = phdr->p_filesz; // 文件需要拷贝的数据量
   119ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a02:	8b 40 10             	mov    0x10(%eax),%eax
   11a05:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (size > 0)
   11a08:	eb 64                	jmp    11a6e <load_phdr+0x11c>
    {
        int curr_size = (size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size; // 至多copy一页的数据
   11a0a:	b8 00 10 00 00       	mov    $0x1000,%eax
   11a0f:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11a16:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11a1a:	89 45 e8             	mov    %eax,-0x18(%ebp)

        uint32_t paddr = memory_get_paddr(page_dir, vaddr); // 拿到物理地址，因为该页还没启用，不能直接copy
   11a1d:	83 ec 08             	sub    $0x8,%esp
   11a20:	ff 75 f4             	pushl  -0xc(%ebp)
   11a23:	ff 75 10             	pushl  0x10(%ebp)
   11a26:	e8 3c f0 ff ff       	call   10a67 <memory_get_paddr>
   11a2b:	83 c4 10             	add    $0x10,%esp
   11a2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        // 注意，这里用的页表仍然是当前的
        if (sys_read(file, (char *)paddr, curr_size) < curr_size)
   11a31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a34:	83 ec 04             	sub    $0x4,%esp
   11a37:	ff 75 e8             	pushl  -0x18(%ebp)
   11a3a:	50                   	push   %eax
   11a3b:	ff 75 08             	pushl  0x8(%ebp)
   11a3e:	e8 cc 13 00 00       	call   12e0f <sys_read>
   11a43:	83 c4 10             	add    $0x10,%esp
   11a46:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11a49:	7e 17                	jle    11a62 <load_phdr+0x110>
        {
            log_printf("read file failed");
   11a4b:	83 ec 0c             	sub    $0xc,%esp
   11a4e:	68 cd 41 01 00       	push   $0x141cd
   11a53:	e8 70 22 00 00       	call   13cc8 <log_printf>
   11a58:	83 c4 10             	add    $0x10,%esp
            return -1;
   11a5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11a60:	eb 17                	jmp    11a79 <load_phdr+0x127>
        }

        size -= curr_size;
   11a62:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11a65:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr += curr_size;
   11a68:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11a6b:	01 45 f4             	add    %eax,-0xc(%ebp)
    while (size > 0)
   11a6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11a72:	75 96                	jne    11a0a <load_phdr+0xb8>

    // bss区考虑由crt0和cstart自行清0，这样更简单一些
    // 如果在上边进行处理，需要考虑到有可能的跨页表填充数据，懒得写代码
    // 或者也可修改memory_alloc_for_page_dir，增加分配时清0页表，但这样开销较大
    // 所以，直接放在cstart哐crt0中直接内存填0，比较简单
    return 0;
   11a74:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11a79:	c9                   	leave  
   11a7a:	c3                   	ret    

00011a7b <load_elf_file>:

/**
 * @brief 加载elf文件到内存中
 */
static uint32_t load_elf_file(task_t *task, const char *name, uint32_t page_dir)
{
   11a7b:	55                   	push   %ebp
   11a7c:	89 e5                	mov    %esp,%ebp
   11a7e:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file = sys_open(name, 0);
   11a81:	83 ec 08             	sub    $0x8,%esp
   11a84:	6a 00                	push   $0x0
   11a86:	ff 75 0c             	pushl  0xc(%ebp)
   11a89:	e8 48 13 00 00       	call   12dd6 <sys_open>
   11a8e:	83 c4 10             	add    $0x10,%esp
   11a91:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (file < 0)
   11a94:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11a98:	79 18                	jns    11ab2 <load_elf_file+0x37>
    {
        log_printf("open failed. %s", name);
   11a9a:	83 ec 08             	sub    $0x8,%esp
   11a9d:	ff 75 0c             	pushl  0xc(%ebp)
   11aa0:	68 de 41 01 00       	push   $0x141de
   11aa5:	e8 1e 22 00 00       	call   13cc8 <log_printf>
   11aaa:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11aad:	e9 a2 01 00 00       	jmp    11c54 <load_elf_file+0x1d9>
    }
    // 先读取文件头
    int cnt = sys_read(file, (char *)&elf_hdr, sizeof(Elf32_Ehdr));
   11ab2:	83 ec 04             	sub    $0x4,%esp
   11ab5:	6a 34                	push   $0x34
   11ab7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11aba:	50                   	push   %eax
   11abb:	ff 75 ec             	pushl  -0x14(%ebp)
   11abe:	e8 4c 13 00 00       	call   12e0f <sys_read>
   11ac3:	83 c4 10             	add    $0x10,%esp
   11ac6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (cnt < sizeof(Elf32_Ehdr))
   11ac9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11acc:	83 f8 33             	cmp    $0x33,%eax
   11acf:	77 18                	ja     11ae9 <load_elf_file+0x6e>
    {
        log_printf("elf hdr too small. size=%d", cnt);
   11ad1:	83 ec 08             	sub    $0x8,%esp
   11ad4:	ff 75 e8             	pushl  -0x18(%ebp)
   11ad7:	68 ee 41 01 00       	push   $0x141ee
   11adc:	e8 e7 21 00 00       	call   13cc8 <log_printf>
   11ae1:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11ae4:	e9 6b 01 00 00       	jmp    11c54 <load_elf_file+0x1d9>
    }
    // 做点必要性的检查。当然可以再做其它检查
    if ((elf_hdr.e_ident[0] != ELF_MAGIC) || (elf_hdr.e_ident[1] != 'E') || (elf_hdr.e_ident[2] != 'L') || (elf_hdr.e_ident[3] != 'F'))
   11ae9:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11aed:	3c 7f                	cmp    $0x7f,%al
   11aef:	75 18                	jne    11b09 <load_elf_file+0x8e>
   11af1:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11af5:	3c 45                	cmp    $0x45,%al
   11af7:	75 10                	jne    11b09 <load_elf_file+0x8e>
   11af9:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11afd:	3c 4c                	cmp    $0x4c,%al
   11aff:	75 08                	jne    11b09 <load_elf_file+0x8e>
   11b01:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11b05:	3c 46                	cmp    $0x46,%al
   11b07:	74 15                	je     11b1e <load_elf_file+0xa3>
    {
        log_printf("check elf indent failed.");
   11b09:	83 ec 0c             	sub    $0xc,%esp
   11b0c:	68 09 42 01 00       	push   $0x14209
   11b11:	e8 b2 21 00 00       	call   13cc8 <log_printf>
   11b16:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11b19:	e9 36 01 00 00       	jmp    11c54 <load_elf_file+0x1d9>
    }

    // 必须是可执行文件和针对386处理器的类型，且有入口
    if ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == 0))
   11b1e:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
   11b22:	66 83 f8 02          	cmp    $0x2,%ax
   11b26:	75 11                	jne    11b39 <load_elf_file+0xbe>
   11b28:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
   11b2c:	66 83 f8 03          	cmp    $0x3,%ax
   11b30:	75 07                	jne    11b39 <load_elf_file+0xbe>
   11b32:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11b35:	85 c0                	test   %eax,%eax
   11b37:	75 15                	jne    11b4e <load_elf_file+0xd3>
    {
        log_printf("check elf type or entry failed.");
   11b39:	83 ec 0c             	sub    $0xc,%esp
   11b3c:	68 24 42 01 00       	push   $0x14224
   11b41:	e8 82 21 00 00       	call   13cc8 <log_printf>
   11b46:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11b49:	e9 06 01 00 00       	jmp    11c54 <load_elf_file+0x1d9>
    }

    // 必须有程序头部
    if ((elf_hdr.e_phentsize == 0) || (elf_hdr.e_phoff == 0))
   11b4e:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11b52:	66 85 c0             	test   %ax,%ax
   11b55:	74 07                	je     11b5e <load_elf_file+0xe3>
   11b57:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11b5a:	85 c0                	test   %eax,%eax
   11b5c:	75 15                	jne    11b73 <load_elf_file+0xf8>
    {
        log_printf("none programe header");
   11b5e:	83 ec 0c             	sub    $0xc,%esp
   11b61:	68 44 42 01 00       	push   $0x14244
   11b66:	e8 5d 21 00 00       	call   13cc8 <log_printf>
   11b6b:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11b6e:	e9 e1 00 00 00       	jmp    11c54 <load_elf_file+0x1d9>
    }

    // 然后从中加载程序头，将内容拷贝到相应的位置
    uint32_t e_phoff = elf_hdr.e_phoff;
   11b73:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11b76:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize)
   11b79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b80:	e9 ac 00 00 00       	jmp    11c31 <load_elf_file+0x1b6>
    {
        if (sys_lseek(file, e_phoff, 0) < 0)
   11b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b88:	83 ec 04             	sub    $0x4,%esp
   11b8b:	6a 00                	push   $0x0
   11b8d:	50                   	push   %eax
   11b8e:	ff 75 ec             	pushl  -0x14(%ebp)
   11b91:	e8 c2 12 00 00       	call   12e58 <sys_lseek>
   11b96:	83 c4 10             	add    $0x10,%esp
   11b99:	85 c0                	test   %eax,%eax
   11b9b:	79 15                	jns    11bb2 <load_elf_file+0x137>
        {
            log_printf("read file failed");
   11b9d:	83 ec 0c             	sub    $0xc,%esp
   11ba0:	68 cd 41 01 00       	push   $0x141cd
   11ba5:	e8 1e 21 00 00       	call   13cc8 <log_printf>
   11baa:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11bad:	e9 a2 00 00 00       	jmp    11c54 <load_elf_file+0x1d9>
        }

        // 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下
        cnt = sys_read(file, (char *)&elf_phdr, sizeof(Elf32_Phdr));
   11bb2:	83 ec 04             	sub    $0x4,%esp
   11bb5:	6a 20                	push   $0x20
   11bb7:	8d 45 90             	lea    -0x70(%ebp),%eax
   11bba:	50                   	push   %eax
   11bbb:	ff 75 ec             	pushl  -0x14(%ebp)
   11bbe:	e8 4c 12 00 00       	call   12e0f <sys_read>
   11bc3:	83 c4 10             	add    $0x10,%esp
   11bc6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (cnt < sizeof(Elf32_Phdr))
   11bc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bcc:	83 f8 1f             	cmp    $0x1f,%eax
   11bcf:	77 12                	ja     11be3 <load_elf_file+0x168>
        {
            log_printf("read file failed");
   11bd1:	83 ec 0c             	sub    $0xc,%esp
   11bd4:	68 cd 41 01 00       	push   $0x141cd
   11bd9:	e8 ea 20 00 00       	call   13cc8 <log_printf>
   11bde:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11be1:	eb 71                	jmp    11c54 <load_elf_file+0x1d9>
        }

        // 简单做一些检查，如有必要，可自行加更多
        // 主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间
        if ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr < MEMORY_TASK_BASE))
   11be3:	8b 45 90             	mov    -0x70(%ebp),%eax
   11be6:	83 f8 01             	cmp    $0x1,%eax
   11be9:	75 37                	jne    11c22 <load_elf_file+0x1a7>
   11beb:	8b 45 98             	mov    -0x68(%ebp),%eax
   11bee:	85 c0                	test   %eax,%eax
   11bf0:	79 30                	jns    11c22 <load_elf_file+0x1a7>
        {
            continue;
        }

        // 加载当前程序头
        int err = load_phdr(file, &elf_phdr, page_dir);
   11bf2:	83 ec 04             	sub    $0x4,%esp
   11bf5:	ff 75 10             	pushl  0x10(%ebp)
   11bf8:	8d 45 90             	lea    -0x70(%ebp),%eax
   11bfb:	50                   	push   %eax
   11bfc:	ff 75 ec             	pushl  -0x14(%ebp)
   11bff:	e8 4e fd ff ff       	call   11952 <load_phdr>
   11c04:	83 c4 10             	add    $0x10,%esp
   11c07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0)
   11c0a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11c0e:	79 13                	jns    11c23 <load_elf_file+0x1a8>
        {
            log_printf("load program hdr failed");
   11c10:	83 ec 0c             	sub    $0xc,%esp
   11c13:	68 59 42 01 00       	push   $0x14259
   11c18:	e8 ab 20 00 00       	call   13cc8 <log_printf>
   11c1d:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c20:	eb 32                	jmp    11c54 <load_elf_file+0x1d9>
            continue;
   11c22:	90                   	nop
    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize)
   11c23:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c27:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11c2b:	0f b7 c0             	movzwl %ax,%eax
   11c2e:	01 45 f4             	add    %eax,-0xc(%ebp)
   11c31:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11c35:	0f b7 c0             	movzwl %ax,%eax
   11c38:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c3b:	0f 8c 44 ff ff ff    	jl     11b85 <load_elf_file+0x10a>

        // 简单起见，不检查了，以最后的地址为bss的地址
        // task->heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;
        // task->heap_end = task->heap_start;
    }
    sys_close(file);
   11c41:	83 ec 0c             	sub    $0xc,%esp
   11c44:	ff 75 ec             	pushl  -0x14(%ebp)
   11c47:	e8 30 12 00 00       	call   12e7c <sys_close>
   11c4c:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11c4f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11c52:	eb 19                	jmp    11c6d <load_elf_file+0x1f2>
load_failed:
    // 文件已经打开
    if (file >= 0)
   11c54:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11c58:	78 0e                	js     11c68 <load_elf_file+0x1ed>
    {
        sys_close(file);
   11c5a:	83 ec 0c             	sub    $0xc,%esp
   11c5d:	ff 75 ec             	pushl  -0x14(%ebp)
   11c60:	e8 17 12 00 00       	call   12e7c <sys_close>
   11c65:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11c68:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11c6d:	c9                   	leave  
   11c6e:	c3                   	ret    

00011c6f <copy_args>:

/**
 * @brief 复制进程参数到栈中。注意argv和env指向的空间在另一个页表里
 */
static int copy_args(char *to, uint32_t page_dir, int argc, char **argv)
{
   11c6f:	55                   	push   %ebp
   11c70:	89 e5                	mov    %esp,%ebp
   11c72:	83 ec 38             	sub    $0x38,%esp
    // 在stack_top中依次写入argc, argv指针，参数字符串
    task_args_t task_args;
    task_args.argc = argc;
   11c75:	8b 45 10             	mov    0x10(%ebp),%eax
   11c78:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv = (char **)(to + sizeof(task_args_t));
   11c7b:	8b 45 08             	mov    0x8(%ebp),%eax
   11c7e:	83 c0 0c             	add    $0xc,%eax
   11c81:	89 45 dc             	mov    %eax,-0x24(%ebp)

    // 复制各项参数, 跳过task_args和参数表
    // 各argv参数写入的内存空间
    char *dest_arg = to + sizeof(task_args_t) + sizeof(char *) * (argc + 1); // 留出结束符
   11c84:	8b 45 10             	mov    0x10(%ebp),%eax
   11c87:	83 c0 04             	add    $0x4,%eax
   11c8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11c91:	8b 45 08             	mov    0x8(%ebp),%eax
   11c94:	01 d0                	add    %edx,%eax
   11c96:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // argv表
    char **dest_argv_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_args_t)));
   11c99:	8b 45 08             	mov    0x8(%ebp),%eax
   11c9c:	83 c0 0c             	add    $0xc,%eax
   11c9f:	83 ec 08             	sub    $0x8,%esp
   11ca2:	50                   	push   %eax
   11ca3:	ff 75 0c             	pushl  0xc(%ebp)
   11ca6:	e8 bc ed ff ff       	call   10a67 <memory_get_paddr>
   11cab:	83 c4 10             	add    $0x10,%esp
   11cae:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ASSERT(dest_argv_tb != 0);
   11cb1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11cb5:	75 1c                	jne    11cd3 <copy_args+0x64>
   11cb7:	68 71 42 01 00       	push   $0x14271
   11cbc:	68 b4 42 01 00       	push   $0x142b4
   11cc1:	68 a1 02 00 00       	push   $0x2a1
   11cc6:	68 1c 41 01 00       	push   $0x1411c
   11ccb:	e8 a2 1c 00 00       	call   13972 <panic>
   11cd0:	83 c4 10             	add    $0x10,%esp

    for (int i = 0; i < argc; i++)
   11cd3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11cda:	e9 82 00 00 00       	jmp    11d61 <copy_args+0xf2>
    {
        char *from = argv[i];
   11cdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ce2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11ce9:	8b 45 14             	mov    0x14(%ebp),%eax
   11cec:	01 d0                	add    %edx,%eax
   11cee:	8b 00                	mov    (%eax),%eax
   11cf0:	89 45 e8             	mov    %eax,-0x18(%ebp)

        // 不能用kernel_strcpy，因为to和argv不在一个页表里
        int len = kernel_strlen(from) + 1; // 包含结束符
   11cf3:	83 ec 0c             	sub    $0xc,%esp
   11cf6:	ff 75 e8             	pushl  -0x18(%ebp)
   11cf9:	e8 c1 18 00 00       	call   135bf <kernel_strlen>
   11cfe:	83 c4 10             	add    $0x10,%esp
   11d01:	83 c0 01             	add    $0x1,%eax
   11d04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = memory_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len);
   11d07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11d0a:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d10:	51                   	push   %ecx
   11d11:	52                   	push   %edx
   11d12:	ff 75 0c             	pushl  0xc(%ebp)
   11d15:	50                   	push   %eax
   11d16:	e8 92 ed ff ff       	call   10aad <memory_copy_uvm_data>
   11d1b:	83 c4 10             	add    $0x10,%esp
   11d1e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11d21:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11d25:	79 1c                	jns    11d43 <copy_args+0xd4>
   11d27:	68 83 42 01 00       	push   $0x14283
   11d2c:	68 b4 42 01 00       	push   $0x142b4
   11d31:	68 aa 02 00 00       	push   $0x2aa
   11d36:	68 1c 41 01 00       	push   $0x1411c
   11d3b:	e8 32 1c 00 00       	call   13972 <panic>
   11d40:	83 c4 10             	add    $0x10,%esp

        // 关联arg
        dest_argv_tb[i] = dest_arg;
   11d43:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d50:	01 c2                	add    %eax,%edx
   11d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d55:	89 02                	mov    %eax,(%edx)

        // 记录下位置后，复制的位置前移
        dest_arg += len;
   11d57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d5a:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < argc; i++)
   11d5d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d64:	3b 45 10             	cmp    0x10(%ebp),%eax
   11d67:	0f 8c 72 ff ff ff    	jl     11cdf <copy_args+0x70>
    }
    // 可能存在无参的情况，此时不需要写入
    if (argc)
   11d6d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11d71:	74 15                	je     11d88 <copy_args+0x119>
    {
        dest_argv_tb[argc] = '\0';
   11d73:	8b 45 10             	mov    0x10(%ebp),%eax
   11d76:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d80:	01 d0                	add    %edx,%eax
   11d82:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

    // 写入task_args
    return memory_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_args, sizeof(task_args_t));
   11d88:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d8e:	6a 0c                	push   $0xc
   11d90:	52                   	push   %edx
   11d91:	ff 75 0c             	pushl  0xc(%ebp)
   11d94:	50                   	push   %eax
   11d95:	e8 13 ed ff ff       	call   10aad <memory_copy_uvm_data>
   11d9a:	83 c4 10             	add    $0x10,%esp
}
   11d9d:	c9                   	leave  
   11d9e:	c3                   	ret    

00011d9f <sys_execve>:
 * @brief 加载一个进程
 * 这个比较复杂，argv/name/env都是原进程空间中的数据，execve中涉及到页表的切换
 * 在对argv和name进行处理时，会涉及到不同进程空间中数据的传递。
 */
int sys_execve(char *name, char **argv, char **env)
{
   11d9f:	55                   	push   %ebp
   11da0:	89 e5                	mov    %esp,%ebp
   11da2:	83 ec 28             	sub    $0x28,%esp
    task_t *task = task_current();
   11da5:	e8 48 f6 ff ff       	call   113f2 <task_current>
   11daa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // 后面会切换页表，所以先处理需要从进程空间取数据的情况
    kernel_strncpy(task->name, get_file_name(name), TASK_NAME_SIZE);
   11dad:	83 ec 0c             	sub    $0xc,%esp
   11db0:	ff 75 08             	pushl  0x8(%ebp)
   11db3:	e8 f0 1b 00 00       	call   139a8 <get_file_name>
   11db8:	83 c4 10             	add    $0x10,%esp
   11dbb:	89 c2                	mov    %eax,%edx
   11dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dc0:	83 c0 04             	add    $0x4,%eax
   11dc3:	83 ec 04             	sub    $0x4,%esp
   11dc6:	6a 20                	push   $0x20
   11dc8:	52                   	push   %edx
   11dc9:	50                   	push   %eax
   11dca:	e8 02 17 00 00       	call   134d1 <kernel_strncpy>
   11dcf:	83 c4 10             	add    $0x10,%esp
    // 现在开始加载了，先准备应用页表，由于所有操作均在内核区中进行，所以可以直接先切换到新页表
    uint32_t old_page_dir = task->tss.cr3;
   11dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dd5:	8b 40 6c             	mov    0x6c(%eax),%eax
   11dd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir = memory_create_uvm();
   11ddb:	e8 9e e9 ff ff       	call   1077e <memory_create_uvm>
   11de0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (!new_page_dir)
   11de3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11de7:	0f 84 27 01 00 00    	je     11f14 <sys_execve+0x175>
    {
        goto exec_failed;
    }
    // 加载elf文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写
    uint32_t entry = load_elf_file(task, name, new_page_dir); // 暂时置用task->name表示
   11ded:	83 ec 04             	sub    $0x4,%esp
   11df0:	ff 75 ec             	pushl  -0x14(%ebp)
   11df3:	ff 75 08             	pushl  0x8(%ebp)
   11df6:	ff 75 f4             	pushl  -0xc(%ebp)
   11df9:	e8 7d fc ff ff       	call   11a7b <load_elf_file>
   11dfe:	83 c4 10             	add    $0x10,%esp
   11e01:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (entry == 0)
   11e04:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11e08:	0f 84 09 01 00 00    	je     11f17 <sys_execve+0x178>
    {
        goto exec_failed;
    }

    // 准备用户栈空间，预留环境环境及参数的空间
    uint32_t stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE; // 预留一部分参数空间
   11e0e:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)
    int err = memory_alloc_for_page_dir(new_page_dir,
   11e15:	6a 07                	push   $0x7
   11e17:	68 00 40 1f 00       	push   $0x1f4000
   11e1c:	68 00 c0 e0 df       	push   $0xdfe0c000
   11e21:	ff 75 ec             	pushl  -0x14(%ebp)
   11e24:	e8 07 ed ff ff       	call   10b30 <memory_alloc_for_page_dir>
   11e29:	83 c4 10             	add    $0x10,%esp
   11e2c:	89 45 e0             	mov    %eax,-0x20(%ebp)
                                        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,
                                        MEM_TASK_STACK_SIZE, PTE_P | PTE_U | PTE_W);
    if (err < 0)
   11e2f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11e33:	0f 88 e1 00 00 00    	js     11f1a <sys_execve+0x17b>
    {
        goto exec_failed;
    }

    // 复制参数，写入到栈顶的后边
    int argc = strings_count(argv);
   11e39:	83 ec 0c             	sub    $0xc,%esp
   11e3c:	ff 75 0c             	pushl  0xc(%ebp)
   11e3f:	e8 aa 1b 00 00       	call   139ee <strings_count>
   11e44:	83 c4 10             	add    $0x10,%esp
   11e47:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err = copy_args((char *)stack_top, new_page_dir, argc, argv);
   11e4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e4d:	ff 75 0c             	pushl  0xc(%ebp)
   11e50:	ff 75 dc             	pushl  -0x24(%ebp)
   11e53:	ff 75 ec             	pushl  -0x14(%ebp)
   11e56:	50                   	push   %eax
   11e57:	e8 13 fe ff ff       	call   11c6f <copy_args>
   11e5c:	83 c4 10             	add    $0x10,%esp
   11e5f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (err < 0)
   11e62:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11e66:	0f 88 b1 00 00 00    	js     11f1d <sys_execve+0x17e>

    // 加载完毕，为程序的执行做必要准备
    // 注意，exec的作用是替换掉当前进程，所以只要改变当前进程的执行流即可
    // 当该进程恢复运行时，像完全重新运行一样，所以用户栈要设置成初始模式
    // 运行地址要设备成整个程序的入口地址
    syscall_frame_t *frame = (syscall_frame_t *)(task->tss.esp0 - sizeof(syscall_frame_t));
   11e6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e6f:	8b 40 54             	mov    0x54(%eax),%eax
   11e72:	83 e8 58             	sub    $0x58,%eax
   11e75:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip = entry;
   11e78:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11e7b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11e7e:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax = frame->ebx = frame->ecx = frame->edx = 0;
   11e81:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11e84:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11e8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11e8e:	8b 50 28             	mov    0x28(%eax),%edx
   11e91:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11e94:	89 50 2c             	mov    %edx,0x2c(%eax)
   11e97:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11e9a:	8b 50 2c             	mov    0x2c(%eax),%edx
   11e9d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ea0:	89 50 24             	mov    %edx,0x24(%eax)
   11ea3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ea6:	8b 50 24             	mov    0x24(%eax),%edx
   11ea9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11eac:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi = frame->edi = frame->ebp = 0;
   11eaf:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11eb2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11eb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ebc:	8b 50 1c             	mov    0x1c(%eax),%edx
   11ebf:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ec2:	89 50 14             	mov    %edx,0x14(%eax)
   11ec5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ec8:	8b 50 14             	mov    0x14(%eax),%edx
   11ecb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ece:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags = EFLAGS_DEFAULT | EFLAGS_IF; // 段寄存器无需修改
   11ed1:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ed4:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    // 内核栈不用设置，保持不变，后面调用memory_destroy_uvm并不会销毁内核栈的映射。
    // 但用户栈需要更改, 同样要加上调用门的参数压栈空间
    frame->esp = stack_top - sizeof(uint32_t) * SYSCALL_PARAM_COUNT;
   11eda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11edd:	83 e8 14             	sub    $0x14,%eax
   11ee0:	89 c2                	mov    %eax,%edx
   11ee2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ee5:	89 50 50             	mov    %edx,0x50(%eax)

    // 切换到新的页表
    task->tss.cr3 = new_page_dir;
   11ee8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11eeb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11eee:	89 50 6c             	mov    %edx,0x6c(%eax)
    mmu_set_page_dir(new_page_dir); // 切换至新的页表。由于不用访问原栈及数据，所以并无问题
   11ef1:	83 ec 0c             	sub    $0xc,%esp
   11ef4:	ff 75 ec             	pushl  -0x14(%ebp)
   11ef7:	e8 c2 ef ff ff       	call   10ebe <mmu_set_page_dir>
   11efc:	83 c4 10             	add    $0x10,%esp

    // 调整页表，切换成新的，同时释放掉之前的
    // 当前使用的是内核栈，而内核栈并未映射到进程地址空间中，所以下面的释放没有问题
    memory_destroy_uvm(old_page_dir); // 再释放掉了原进程的内容空间
   11eff:	83 ec 0c             	sub    $0xc,%esp
   11f02:	ff 75 f0             	pushl  -0x10(%ebp)
   11f05:	e8 f9 e8 ff ff       	call   10803 <memory_destroy_uvm>
   11f0a:	83 c4 10             	add    $0x10,%esp

    // 当从系统调用中返回时，将切换至新进程的入口地址运行，并且进程能够获取参数
    // 注意，如果用户栈设置不当，可能导致返回后运行出现异常。可在gdb中使用nexti单步观察运行流程
    return 0;
   11f0d:	b8 00 00 00 00       	mov    $0x0,%eax
   11f12:	eb 3a                	jmp    11f4e <sys_execve+0x1af>
        goto exec_failed;
   11f14:	90                   	nop
   11f15:	eb 07                	jmp    11f1e <sys_execve+0x17f>
        goto exec_failed;
   11f17:	90                   	nop
   11f18:	eb 04                	jmp    11f1e <sys_execve+0x17f>
        goto exec_failed;
   11f1a:	90                   	nop
   11f1b:	eb 01                	jmp    11f1e <sys_execve+0x17f>
        goto exec_failed;
   11f1d:	90                   	nop

exec_failed: // 必要的资源释放
    if (new_page_dir)
   11f1e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11f22:	74 25                	je     11f49 <sys_execve+0x1aa>
    {
        // 有页表空间切换，切换至旧页表，销毁新页表
        task->tss.cr3 = old_page_dir;
   11f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f27:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11f2a:	89 50 6c             	mov    %edx,0x6c(%eax)
        mmu_set_page_dir(old_page_dir);
   11f2d:	83 ec 0c             	sub    $0xc,%esp
   11f30:	ff 75 f0             	pushl  -0x10(%ebp)
   11f33:	e8 86 ef ff ff       	call   10ebe <mmu_set_page_dir>
   11f38:	83 c4 10             	add    $0x10,%esp
        memory_destroy_uvm(new_page_dir);
   11f3b:	83 ec 0c             	sub    $0xc,%esp
   11f3e:	ff 75 ec             	pushl  -0x14(%ebp)
   11f41:	e8 bd e8 ff ff       	call   10803 <memory_destroy_uvm>
   11f46:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11f49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11f4e:	c9                   	leave  
   11f4f:	c3                   	ret    

00011f50 <sys_yield>:

/**
 * @brief 当前任务主动放弃CPU
 */
int sys_yield(void)
{
   11f50:	55                   	push   %ebp
   11f51:	89 e5                	mov    %esp,%ebp
   11f53:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11f56:	e8 09 0c 00 00       	call   12b64 <irq_enter_protection>
   11f5b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&task_manager.ready_list) > 1)
   11f5e:	83 ec 0c             	sub    $0xc,%esp
   11f61:	68 04 b0 01 00       	push   $0x1b004
   11f66:	e8 1f ef ff ff       	call   10e8a <list_count>
   11f6b:	83 c4 10             	add    $0x10,%esp
   11f6e:	83 f8 01             	cmp    $0x1,%eax
   11f71:	7e 29                	jle    11f9c <sys_yield+0x4c>
    {
        task_t *curr_task = task_current();
   11f73:	e8 7a f4 ff ff       	call   113f2 <task_current>
   11f78:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        task_set_block(curr_task);
   11f7b:	83 ec 0c             	sub    $0xc,%esp
   11f7e:	ff 75 f0             	pushl  -0x10(%ebp)
   11f81:	e8 41 f4 ff ff       	call   113c7 <task_set_block>
   11f86:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   11f89:	83 ec 0c             	sub    $0xc,%esp
   11f8c:	ff 75 f0             	pushl  -0x10(%ebp)
   11f8f:	e8 ff f3 ff ff       	call   11393 <task_set_ready>
   11f94:	83 c4 10             	add    $0x10,%esp

        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
   11f97:	e8 04 f5 ff ff       	call   114a0 <task_dispatch>
    }
    irq_leave_protection(state);
   11f9c:	83 ec 0c             	sub    $0xc,%esp
   11f9f:	ff 75 f4             	pushl  -0xc(%ebp)
   11fa2:	e8 d5 0b 00 00       	call   12b7c <irq_leave_protection>
   11fa7:	83 c4 10             	add    $0x10,%esp

    return 0;
   11faa:	b8 00 00 00 00       	mov    $0x0,%eax
   11faf:	c9                   	leave  
   11fb0:	c3                   	ret    

00011fb1 <lgdt>:
{
   11fb1:	55                   	push   %ebp
   11fb2:	89 e5                	mov    %esp,%ebp
   11fb4:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   11fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   11fba:	c1 e8 10             	shr    $0x10,%eax
   11fbd:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   11fc1:	8b 45 08             	mov    0x8(%ebp),%eax
   11fc4:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   11fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fcb:	83 e8 01             	sub    $0x1,%eax
   11fce:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]" ::[g] "m"(gdt));
   11fd2:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   11fd6:	90                   	nop
   11fd7:	c9                   	leave  
   11fd8:	c3                   	ret    

00011fd9 <far_jump>:
{
   11fd9:	55                   	push   %ebp
   11fda:	89 e5                	mov    %esp,%ebp
   11fdc:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset, selector};
   11fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fe2:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11fe5:	8b 45 08             	mov    0x8(%ebp),%eax
   11fe8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
   11feb:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11fee:	ff 28                	ljmp   *(%eax)
}
   11ff0:	90                   	nop
   11ff1:	c9                   	leave  
   11ff2:	c3                   	ret    

00011ff3 <segment_desc_set>:

static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;

void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   11ff3:	55                   	push   %ebp
   11ff4:	89 e5                	mov    %esp,%ebp
   11ff6:	83 ec 14             	sub    $0x14,%esp
   11ff9:	8b 45 14             	mov    0x14(%ebp),%eax
   11ffc:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + (selector / sizeof(segment_desc_t)); //
   12000:	8b 45 08             	mov    0x8(%ebp),%eax
   12003:	83 e0 f8             	and    $0xfffffff8,%eax
   12006:	05 e0 0f 02 00       	add    $0x20fe0,%eax
   1200b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置limit单位为4kB
    if (limit > 0xFFFF)
   1200e:	81 7d 10 ff ff 00 00 	cmpl   $0xffff,0x10(%ebp)
   12015:	76 0f                	jbe    12026 <segment_desc_set+0x33>
    {
        attr |= SEG_G; // G 标志位
   12017:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit /= 0x1000;
   1201d:	8b 45 10             	mov    0x10(%ebp),%eax
   12020:	c1 e8 0c             	shr    $0xc,%eax
   12023:	89 45 10             	mov    %eax,0x10(%ebp)
    }

    desc->limit15_0 = limit & 0xFFFF;
   12026:	8b 45 10             	mov    0x10(%ebp),%eax
   12029:	89 c2                	mov    %eax,%edx
   1202b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1202e:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xFFFF;
   12031:	8b 45 0c             	mov    0xc(%ebp),%eax
   12034:	89 c2                	mov    %eax,%edx
   12036:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12039:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xFF;
   1203d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12040:	c1 e8 10             	shr    $0x10,%eax
   12043:	89 c2                	mov    %eax,%edx
   12045:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12048:	88 50 04             	mov    %dl,0x4(%eax)
    desc->base31_24 = (base >> 24) & 0xFF;
   1204b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1204e:	c1 e8 18             	shr    $0x18,%eax
   12051:	89 c2                	mov    %eax,%edx
   12053:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12056:	88 50 07             	mov    %dl,0x7(%eax)
    desc->attr = attr | (((limit >> 16) & 0xFF) << 8);
   12059:	8b 45 10             	mov    0x10(%ebp),%eax
   1205c:	c1 e8 10             	shr    $0x10,%eax
   1205f:	c1 e0 08             	shl    $0x8,%eax
   12062:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   12066:	89 c2                	mov    %eax,%edx
   12068:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1206b:	66 89 50 05          	mov    %dx,0x5(%eax)
}
   1206f:	90                   	nop
   12070:	c9                   	leave  
   12071:	c3                   	ret    

00012072 <gdt_free_sel>:

void gdt_free_sel(int sel)
{
   12072:	55                   	push   %ebp
   12073:	89 e5                	mov    %esp,%ebp
   12075:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   12078:	83 ec 0c             	sub    $0xc,%esp
   1207b:	68 e0 17 02 00       	push   $0x217e0
   12080:	e8 24 0f 00 00       	call   12fa9 <mutex_lock>
   12085:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel / sizeof(segment_desc_t)].attr = 0;
   12088:	8b 45 08             	mov    0x8(%ebp),%eax
   1208b:	c1 e8 03             	shr    $0x3,%eax
   1208e:	66 c7 04 c5 e5 0f 02 	movw   $0x0,0x20fe5(,%eax,8)
   12095:	00 00 00 
    mutex_unlock(&mutex);
   12098:	83 ec 0c             	sub    $0xc,%esp
   1209b:	68 e0 17 02 00       	push   $0x217e0
   120a0:	e8 98 0f 00 00       	call   1303d <mutex_unlock>
   120a5:	83 c4 10             	add    $0x10,%esp
}
   120a8:	90                   	nop
   120a9:	c9                   	leave  
   120aa:	c3                   	ret    

000120ab <get_alloc_desc>:

int get_alloc_desc()
{
   120ab:	55                   	push   %ebp
   120ac:	89 e5                	mov    %esp,%ebp
   120ae:	83 ec 18             	sub    $0x18,%esp
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   120b1:	83 ec 0c             	sub    $0xc,%esp
   120b4:	68 e0 17 02 00       	push   $0x217e0
   120b9:	e8 eb 0e 00 00       	call   12fa9 <mutex_lock>
   120be:	83 c4 10             	add    $0x10,%esp

    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   120c1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   120c8:	eb 36                	jmp    12100 <get_alloc_desc+0x55>
    {
        segment_desc_t *desc = gdt_table + i;
   120ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120cd:	c1 e0 03             	shl    $0x3,%eax
   120d0:	05 e0 0f 02 00       	add    $0x20fe0,%eax
   120d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (desc->attr == 0) // 根据属性是否为0判断
   120d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120db:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   120df:	66 85 c0             	test   %ax,%ax
   120e2:	75 18                	jne    120fc <get_alloc_desc+0x51>
        {
            // irq_leave_protection(state);
            mutex_unlock(&mutex);
   120e4:	83 ec 0c             	sub    $0xc,%esp
   120e7:	68 e0 17 02 00       	push   $0x217e0
   120ec:	e8 4c 0f 00 00       	call   1303d <mutex_unlock>
   120f1:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   120f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120f7:	c1 e0 03             	shl    $0x3,%eax
   120fa:	eb 22                	jmp    1211e <get_alloc_desc+0x73>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   120fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12100:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12107:	7e c1                	jle    120ca <get_alloc_desc+0x1f>
        }
    }
    // irq_leave_protection(state);
    mutex_unlock(&mutex);
   12109:	83 ec 0c             	sub    $0xc,%esp
   1210c:	68 e0 17 02 00       	push   $0x217e0
   12111:	e8 27 0f 00 00       	call   1303d <mutex_unlock>
   12116:	83 c4 10             	add    $0x10,%esp
    return -1;
   12119:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1211e:	c9                   	leave  
   1211f:	c3                   	ret    

00012120 <init_gdt>:

void init_gdt(void)
{
   12120:	55                   	push   %ebp
   12121:	89 e5                	mov    %esp,%ebp
   12123:	83 ec 18             	sub    $0x18,%esp
    // 全部清空
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   12126:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1212d:	eb 19                	jmp    12148 <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0); // 找到第几个GDT表项
   1212f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12132:	c1 e0 03             	shl    $0x3,%eax
   12135:	6a 00                	push   $0x0
   12137:	6a 00                	push   $0x0
   12139:	6a 00                	push   $0x0
   1213b:	50                   	push   %eax
   1213c:	e8 b2 fe ff ff       	call   11ff3 <segment_desc_set>
   12141:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   12144:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12148:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1214f:	7e de                	jle    1212f <init_gdt+0xf>
    }
    // 数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xFFFFFFFF,
   12151:	68 92 40 00 00       	push   $0x4092
   12156:	6a ff                	push   $0xffffffff
   12158:	6a 00                	push   $0x0
   1215a:	6a 10                	push   $0x10
   1215c:	e8 92 fe ff ff       	call   11ff3 <segment_desc_set>
   12161:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    // 代码段
    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xFFFFFFFF,
   12164:	68 9a 40 00 00       	push   $0x409a
   12169:	6a ff                	push   $0xffffffff
   1216b:	6a 00                	push   $0x0
   1216d:	6a 08                	push   $0x8
   1216f:	e8 7f fe ff ff       	call   11ff3 <segment_desc_set>
   12174:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);

    // 调用门
    gate_desc_set((gate_desc_t *)(gdt_table + (SELECTOR_SYSCALL >> 3)),
   12177:	ba c7 02 01 00       	mov    $0x102c7,%edx
   1217c:	b8 f8 0f 02 00       	mov    $0x20ff8,%eax
   12181:	68 05 ec 00 00       	push   $0xec05
   12186:	52                   	push   %edx
   12187:	6a 08                	push   $0x8
   12189:	50                   	push   %eax
   1218a:	e8 1c 00 00 00       	call   121ab <gate_desc_set>
   1218f:	83 c4 10             	add    $0x10,%esp
                  KERNEL_SELECTOR_CS,
                  (uint32_t)exception_handler_syscall,
                  GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT);
    // 重新加载GDT
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   12192:	b8 e0 0f 02 00       	mov    $0x20fe0,%eax
   12197:	83 ec 08             	sub    $0x8,%esp
   1219a:	68 00 08 00 00       	push   $0x800
   1219f:	50                   	push   %eax
   121a0:	e8 0c fe ff ff       	call   11fb1 <lgdt>
   121a5:	83 c4 10             	add    $0x10,%esp
}
   121a8:	90                   	nop
   121a9:	c9                   	leave  
   121aa:	c3                   	ret    

000121ab <gate_desc_set>:

void gate_desc_set(gate_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   121ab:	55                   	push   %ebp
   121ac:	89 e5                	mov    %esp,%ebp
   121ae:	83 ec 08             	sub    $0x8,%esp
   121b1:	8b 55 0c             	mov    0xc(%ebp),%edx
   121b4:	8b 45 14             	mov    0x14(%ebp),%eax
   121b7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   121bb:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0 = offset & 0xFFFF;
   121bf:	8b 45 10             	mov    0x10(%ebp),%eax
   121c2:	89 c2                	mov    %eax,%edx
   121c4:	8b 45 08             	mov    0x8(%ebp),%eax
   121c7:	66 89 10             	mov    %dx,(%eax)
    desc->selector = selector;
   121ca:	8b 45 08             	mov    0x8(%ebp),%eax
   121cd:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   121d1:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr = attr;
   121d5:	8b 45 08             	mov    0x8(%ebp),%eax
   121d8:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   121dc:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16 = (offset >> 16) & 0xFFFFF;
   121e0:	8b 45 10             	mov    0x10(%ebp),%eax
   121e3:	c1 e8 10             	shr    $0x10,%eax
   121e6:	89 c2                	mov    %eax,%edx
   121e8:	8b 45 08             	mov    0x8(%ebp),%eax
   121eb:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   121ef:	90                   	nop
   121f0:	c9                   	leave  
   121f1:	c3                   	ret    

000121f2 <cpu_init>:

void cpu_init(void)
{
   121f2:	55                   	push   %ebp
   121f3:	89 e5                	mov    %esp,%ebp
   121f5:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   121f8:	83 ec 0c             	sub    $0xc,%esp
   121fb:	68 e0 17 02 00       	push   $0x217e0
   12200:	e8 76 0d 00 00       	call   12f7b <mutex_init>
   12205:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   12208:	e8 13 ff ff ff       	call   12120 <init_gdt>
}
   1220d:	90                   	nop
   1220e:	c9                   	leave  
   1220f:	c3                   	ret    

00012210 <switch_to_tss>:

void switch_to_tss(uint32_t tss_selector)
{
   12210:	55                   	push   %ebp
   12211:	89 e5                	mov    %esp,%ebp
    far_jump(tss_selector, 0);
   12213:	6a 00                	push   $0x0
   12215:	ff 75 08             	pushl  0x8(%ebp)
   12218:	e8 bc fd ff ff       	call   11fd9 <far_jump>
   1221d:	83 c4 08             	add    $0x8,%esp
   12220:	90                   	nop
   12221:	c9                   	leave  
   12222:	c3                   	ret    

00012223 <inb>:
{
   12223:	55                   	push   %ebp
   12224:	89 e5                	mov    %esp,%ebp
   12226:	83 ec 14             	sub    $0x14,%esp
   12229:	8b 45 08             	mov    0x8(%ebp),%eax
   1222c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12230:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12234:	89 c2                	mov    %eax,%edx
   12236:	ec                   	in     (%dx),%al
   12237:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1223a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1223e:	c9                   	leave  
   1223f:	c3                   	ret    

00012240 <outb>:
{
   12240:	55                   	push   %ebp
   12241:	89 e5                	mov    %esp,%ebp
   12243:	83 ec 08             	sub    $0x8,%esp
   12246:	8b 55 08             	mov    0x8(%ebp),%edx
   12249:	8b 45 0c             	mov    0xc(%ebp),%eax
   1224c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12250:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   12253:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12257:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1225b:	ee                   	out    %al,(%dx)
}
   1225c:	90                   	nop
   1225d:	c9                   	leave  
   1225e:	c3                   	ret    

0001225f <cli>:
{
   1225f:	55                   	push   %ebp
   12260:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   12262:	fa                   	cli    
}
   12263:	90                   	nop
   12264:	5d                   	pop    %ebp
   12265:	c3                   	ret    

00012266 <sti>:
{
   12266:	55                   	push   %ebp
   12267:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   12269:	fb                   	sti    
}
   1226a:	90                   	nop
   1226b:	5d                   	pop    %ebp
   1226c:	c3                   	ret    

0001226d <lidt>:
{
   1226d:	55                   	push   %ebp
   1226e:	89 e5                	mov    %esp,%ebp
   12270:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   12273:	8b 45 08             	mov    0x8(%ebp),%eax
   12276:	c1 e8 10             	shr    $0x10,%eax
   12279:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xFFFF;
   1227d:	8b 45 08             	mov    0x8(%ebp),%eax
   12280:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   12284:	8b 45 0c             	mov    0xc(%ebp),%eax
   12287:	83 e8 01             	sub    $0x1,%eax
   1228a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[g]" ::[g] "m"(idt));
   1228e:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   12292:	90                   	nop
   12293:	c9                   	leave  
   12294:	c3                   	ret    

00012295 <read_cr2>:
{
   12295:	55                   	push   %ebp
   12296:	89 e5                	mov    %esp,%ebp
   12298:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr2, %[v]" : [v] "=r"(cr2));
   1229b:	0f 20 d0             	mov    %cr2,%eax
   1229e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr2;
   122a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   122a4:	c9                   	leave  
   122a5:	c3                   	ret    

000122a6 <hlt>:
{
   122a6:	55                   	push   %ebp
   122a7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   122a9:	f4                   	hlt    
}
   122aa:	90                   	nop
   122ab:	5d                   	pop    %ebp
   122ac:	c3                   	ret    

000122ad <read_eflags>:

static inline uint32_t read_eflags(void)
{
   122ad:	55                   	push   %ebp
   122ae:	89 e5                	mov    %esp,%ebp
   122b0:	83 ec 10             	sub    $0x10,%esp
    uint32_t eflags;

    __asm__ __volatile__("pushfl\n\tpopl %%eax" : "=a"(eflags));
   122b3:	9c                   	pushf  
   122b4:	58                   	pop    %eax
   122b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   122b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   122bb:	c9                   	leave  
   122bc:	c3                   	ret    

000122bd <write_eflags>:

static inline void write_eflags(uint32_t eflags)
{
   122bd:	55                   	push   %ebp
   122be:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("pushl %%eax\n\tpopfl" ::"a"(eflags));
   122c0:	8b 45 08             	mov    0x8(%ebp),%eax
   122c3:	50                   	push   %eax
   122c4:	9d                   	popf   
}
   122c5:	90                   	nop
   122c6:	5d                   	pop    %ebp
   122c7:	c3                   	ret    

000122c8 <dump_core_regs>:
#define IDT_TABLE_NR 128

static gate_desc_t idt_table[IDT_TABLE_NR];

static void dump_core_regs(exception_frame_t *frame)
{
   122c8:	55                   	push   %ebp
   122c9:	89 e5                	mov    %esp,%ebp
   122cb:	57                   	push   %edi
   122cc:	56                   	push   %esi
   122cd:	53                   	push   %ebx
   122ce:	83 ec 2c             	sub    $0x2c,%esp
    uint32_t esp, ss;
    if (frame->cs & 0x7)
   122d1:	8b 45 08             	mov    0x8(%ebp),%eax
   122d4:	8b 40 3c             	mov    0x3c(%eax),%eax
   122d7:	83 e0 07             	and    $0x7,%eax
   122da:	85 c0                	test   %eax,%eax
   122dc:	74 14                	je     122f2 <dump_core_regs+0x2a>
    {
        ss = frame->ds;
   122de:	8b 45 08             	mov    0x8(%ebp),%eax
   122e1:	8b 40 0c             	mov    0xc(%eax),%eax
   122e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp;
   122e7:	8b 45 08             	mov    0x8(%ebp),%eax
   122ea:	8b 40 1c             	mov    0x1c(%eax),%eax
   122ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   122f0:	eb 12                	jmp    12304 <dump_core_regs+0x3c>
    }
    else
    {
        ss = frame->ss3;
   122f2:	8b 45 08             	mov    0x8(%ebp),%eax
   122f5:	8b 40 48             	mov    0x48(%eax),%eax
   122f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp3;
   122fb:	8b 45 08             	mov    0x8(%ebp),%eax
   122fe:	8b 40 44             	mov    0x44(%eax),%eax
   12301:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }

    // 打印CPU寄存器相关内容
    log_printf("IRQ: %d, error code: %d.", frame->num, frame->err_code);
   12304:	8b 45 08             	mov    0x8(%ebp),%eax
   12307:	8b 50 34             	mov    0x34(%eax),%edx
   1230a:	8b 45 08             	mov    0x8(%ebp),%eax
   1230d:	8b 40 30             	mov    0x30(%eax),%eax
   12310:	83 ec 04             	sub    $0x4,%esp
   12313:	52                   	push   %edx
   12314:	50                   	push   %eax
   12315:	68 c0 42 01 00       	push   $0x142c0
   1231a:	e8 a9 19 00 00       	call   13cc8 <log_printf>
   1231f:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS:%d\nGS:%d",
   12322:	8b 45 08             	mov    0x8(%ebp),%eax
   12325:	8b 30                	mov    (%eax),%esi
   12327:	8b 45 08             	mov    0x8(%ebp),%eax
   1232a:	8b 58 04             	mov    0x4(%eax),%ebx
   1232d:	8b 45 08             	mov    0x8(%ebp),%eax
   12330:	8b 48 08             	mov    0x8(%eax),%ecx
   12333:	8b 45 08             	mov    0x8(%ebp),%eax
   12336:	8b 50 0c             	mov    0xc(%eax),%edx
   12339:	8b 45 08             	mov    0x8(%ebp),%eax
   1233c:	8b 40 3c             	mov    0x3c(%eax),%eax
   1233f:	83 ec 04             	sub    $0x4,%esp
   12342:	56                   	push   %esi
   12343:	53                   	push   %ebx
   12344:	ff 75 e0             	pushl  -0x20(%ebp)
   12347:	51                   	push   %ecx
   12348:	52                   	push   %edx
   12349:	50                   	push   %eax
   1234a:	68 dc 42 01 00       	push   $0x142dc
   1234f:	e8 74 19 00 00       	call   13cc8 <log_printf>
   12354:	83 c4 20             	add    $0x20,%esp
               frame->cs, frame->ds, frame->es, ss, frame->fs, frame->gs);
    log_printf("EAX:0x%x\n"
   12357:	8b 45 08             	mov    0x8(%ebp),%eax
   1235a:	8b 40 18             	mov    0x18(%eax),%eax
   1235d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   12360:	8b 45 08             	mov    0x8(%ebp),%eax
   12363:	8b 78 14             	mov    0x14(%eax),%edi
   12366:	8b 45 08             	mov    0x8(%ebp),%eax
   12369:	8b 70 10             	mov    0x10(%eax),%esi
   1236c:	8b 45 08             	mov    0x8(%ebp),%eax
   1236f:	8b 58 24             	mov    0x24(%eax),%ebx
   12372:	8b 45 08             	mov    0x8(%ebp),%eax
   12375:	8b 48 28             	mov    0x28(%eax),%ecx
   12378:	8b 45 08             	mov    0x8(%ebp),%eax
   1237b:	8b 50 20             	mov    0x20(%eax),%edx
   1237e:	8b 45 08             	mov    0x8(%ebp),%eax
   12381:	8b 40 2c             	mov    0x2c(%eax),%eax
   12384:	83 ec 0c             	sub    $0xc,%esp
   12387:	ff 75 e4             	pushl  -0x1c(%ebp)
   1238a:	ff 75 d4             	pushl  -0x2c(%ebp)
   1238d:	57                   	push   %edi
   1238e:	56                   	push   %esi
   1238f:	53                   	push   %ebx
   12390:	51                   	push   %ecx
   12391:	52                   	push   %edx
   12392:	50                   	push   %eax
   12393:	68 04 43 01 00       	push   $0x14304
   12398:	e8 2b 19 00 00       	call   13cc8 <log_printf>
   1239d:	83 c4 30             	add    $0x30,%esp
               "ESI:0x%x\n"
               "EBP:0x%x\n"
               "ESP:0x%x\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, esp);
    log_printf("EIP:0x%x\nEFLAGS:0x%x\n", frame->eip, frame->eflags);
   123a0:	8b 45 08             	mov    0x8(%ebp),%eax
   123a3:	8b 50 40             	mov    0x40(%eax),%edx
   123a6:	8b 45 08             	mov    0x8(%ebp),%eax
   123a9:	8b 40 38             	mov    0x38(%eax),%eax
   123ac:	83 ec 04             	sub    $0x4,%esp
   123af:	52                   	push   %edx
   123b0:	50                   	push   %eax
   123b1:	68 4d 43 01 00       	push   $0x1434d
   123b6:	e8 0d 19 00 00       	call   13cc8 <log_printf>
   123bb:	83 c4 10             	add    $0x10,%esp
}
   123be:	90                   	nop
   123bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
   123c2:	5b                   	pop    %ebx
   123c3:	5e                   	pop    %esi
   123c4:	5f                   	pop    %edi
   123c5:	5d                   	pop    %ebp
   123c6:	c3                   	ret    

000123c7 <do_default_handler>:

static void do_default_handler(exception_frame_t *frame, const char *msg)
{
   123c7:	55                   	push   %ebp
   123c8:	89 e5                	mov    %esp,%ebp
   123ca:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   123cd:	83 ec 0c             	sub    $0xc,%esp
   123d0:	68 64 43 01 00       	push   $0x14364
   123d5:	e8 ee 18 00 00       	call   13cc8 <log_printf>
   123da:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s.", msg);
   123dd:	83 ec 08             	sub    $0x8,%esp
   123e0:	ff 75 0c             	pushl  0xc(%ebp)
   123e3:	68 85 43 01 00       	push   $0x14385
   123e8:	e8 db 18 00 00       	call   13cc8 <log_printf>
   123ed:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame); // 打印寄存器
   123f0:	83 ec 0c             	sub    $0xc,%esp
   123f3:	ff 75 08             	pushl  0x8(%ebp)
   123f6:	e8 cd fe ff ff       	call   122c8 <dump_core_regs>
   123fb:	83 c4 10             	add    $0x10,%esp
    log_printf("--------------------------------");
   123fe:	83 ec 0c             	sub    $0xc,%esp
   12401:	68 64 43 01 00       	push   $0x14364
   12406:	e8 bd 18 00 00       	call   13cc8 <log_printf>
   1240b:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   1240e:	e8 93 fe ff ff       	call   122a6 <hlt>
   12413:	eb f9                	jmp    1240e <do_default_handler+0x47>

00012415 <do_handler_unknown>:
    }
}

void do_handler_unknown(exception_frame_t *frame)
{
   12415:	55                   	push   %ebp
   12416:	89 e5                	mov    %esp,%ebp
   12418:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "unknown exception");
   1241b:	83 ec 08             	sub    $0x8,%esp
   1241e:	68 a0 43 01 00       	push   $0x143a0
   12423:	ff 75 08             	pushl  0x8(%ebp)
   12426:	e8 9c ff ff ff       	call   123c7 <do_default_handler>
   1242b:	83 c4 10             	add    $0x10,%esp
}
   1242e:	90                   	nop
   1242f:	c9                   	leave  
   12430:	c3                   	ret    

00012431 <do_handler_divider>:

void do_handler_divider(exception_frame_t *frame)
{
   12431:	55                   	push   %ebp
   12432:	89 e5                	mov    %esp,%ebp
   12434:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "divider exception");
   12437:	83 ec 08             	sub    $0x8,%esp
   1243a:	68 b2 43 01 00       	push   $0x143b2
   1243f:	ff 75 08             	pushl  0x8(%ebp)
   12442:	e8 80 ff ff ff       	call   123c7 <do_default_handler>
   12447:	83 c4 10             	add    $0x10,%esp
}
   1244a:	90                   	nop
   1244b:	c9                   	leave  
   1244c:	c3                   	ret    

0001244d <do_handler_Debug>:

void do_handler_Debug(exception_frame_t *frame)
{
   1244d:	55                   	push   %ebp
   1244e:	89 e5                	mov    %esp,%ebp
   12450:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Debug Exception");
   12453:	83 ec 08             	sub    $0x8,%esp
   12456:	68 c4 43 01 00       	push   $0x143c4
   1245b:	ff 75 08             	pushl  0x8(%ebp)
   1245e:	e8 64 ff ff ff       	call   123c7 <do_default_handler>
   12463:	83 c4 10             	add    $0x10,%esp
}
   12466:	90                   	nop
   12467:	c9                   	leave  
   12468:	c3                   	ret    

00012469 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t *frame)
{
   12469:	55                   	push   %ebp
   1246a:	89 e5                	mov    %esp,%ebp
   1246c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "NMI Interrupt.");
   1246f:	83 ec 08             	sub    $0x8,%esp
   12472:	68 d4 43 01 00       	push   $0x143d4
   12477:	ff 75 08             	pushl  0x8(%ebp)
   1247a:	e8 48 ff ff ff       	call   123c7 <do_default_handler>
   1247f:	83 c4 10             	add    $0x10,%esp
}
   12482:	90                   	nop
   12483:	c9                   	leave  
   12484:	c3                   	ret    

00012485 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t *frame)
{
   12485:	55                   	push   %ebp
   12486:	89 e5                	mov    %esp,%ebp
   12488:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Breakpoint.");
   1248b:	83 ec 08             	sub    $0x8,%esp
   1248e:	68 e3 43 01 00       	push   $0x143e3
   12493:	ff 75 08             	pushl  0x8(%ebp)
   12496:	e8 2c ff ff ff       	call   123c7 <do_default_handler>
   1249b:	83 c4 10             	add    $0x10,%esp
}
   1249e:	90                   	nop
   1249f:	c9                   	leave  
   124a0:	c3                   	ret    

000124a1 <do_handler_overflow>:

void do_handler_overflow(exception_frame_t *frame)
{
   124a1:	55                   	push   %ebp
   124a2:	89 e5                	mov    %esp,%ebp
   124a4:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Overflow.");
   124a7:	83 ec 08             	sub    $0x8,%esp
   124aa:	68 ef 43 01 00       	push   $0x143ef
   124af:	ff 75 08             	pushl  0x8(%ebp)
   124b2:	e8 10 ff ff ff       	call   123c7 <do_default_handler>
   124b7:	83 c4 10             	add    $0x10,%esp
}
   124ba:	90                   	nop
   124bb:	c9                   	leave  
   124bc:	c3                   	ret    

000124bd <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t *frame)
{
   124bd:	55                   	push   %ebp
   124be:	89 e5                	mov    %esp,%ebp
   124c0:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "BOUND Range Exceeded.");
   124c3:	83 ec 08             	sub    $0x8,%esp
   124c6:	68 f9 43 01 00       	push   $0x143f9
   124cb:	ff 75 08             	pushl  0x8(%ebp)
   124ce:	e8 f4 fe ff ff       	call   123c7 <do_default_handler>
   124d3:	83 c4 10             	add    $0x10,%esp
}
   124d6:	90                   	nop
   124d7:	c9                   	leave  
   124d8:	c3                   	ret    

000124d9 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t *frame)
{
   124d9:	55                   	push   %ebp
   124da:	89 e5                	mov    %esp,%ebp
   124dc:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid Opcode.");
   124df:	83 ec 08             	sub    $0x8,%esp
   124e2:	68 0f 44 01 00       	push   $0x1440f
   124e7:	ff 75 08             	pushl  0x8(%ebp)
   124ea:	e8 d8 fe ff ff       	call   123c7 <do_default_handler>
   124ef:	83 c4 10             	add    $0x10,%esp
}
   124f2:	90                   	nop
   124f3:	c9                   	leave  
   124f4:	c3                   	ret    

000124f5 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t *frame)
{
   124f5:	55                   	push   %ebp
   124f6:	89 e5                	mov    %esp,%ebp
   124f8:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Device Not Available.");
   124fb:	83 ec 08             	sub    $0x8,%esp
   124fe:	68 1f 44 01 00       	push   $0x1441f
   12503:	ff 75 08             	pushl  0x8(%ebp)
   12506:	e8 bc fe ff ff       	call   123c7 <do_default_handler>
   1250b:	83 c4 10             	add    $0x10,%esp
}
   1250e:	90                   	nop
   1250f:	c9                   	leave  
   12510:	c3                   	ret    

00012511 <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t *frame)
{
   12511:	55                   	push   %ebp
   12512:	89 e5                	mov    %esp,%ebp
   12514:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Double Fault.");
   12517:	83 ec 08             	sub    $0x8,%esp
   1251a:	68 35 44 01 00       	push   $0x14435
   1251f:	ff 75 08             	pushl  0x8(%ebp)
   12522:	e8 a0 fe ff ff       	call   123c7 <do_default_handler>
   12527:	83 c4 10             	add    $0x10,%esp
}
   1252a:	90                   	nop
   1252b:	c9                   	leave  
   1252c:	c3                   	ret    

0001252d <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t *frame)
{
   1252d:	55                   	push   %ebp
   1252e:	89 e5                	mov    %esp,%ebp
   12530:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid TSS");
   12533:	83 ec 08             	sub    $0x8,%esp
   12536:	68 43 44 01 00       	push   $0x14443
   1253b:	ff 75 08             	pushl  0x8(%ebp)
   1253e:	e8 84 fe ff ff       	call   123c7 <do_default_handler>
   12543:	83 c4 10             	add    $0x10,%esp
}
   12546:	90                   	nop
   12547:	c9                   	leave  
   12548:	c3                   	ret    

00012549 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t *frame)
{
   12549:	55                   	push   %ebp
   1254a:	89 e5                	mov    %esp,%ebp
   1254c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Segment Not Present.");
   1254f:	83 ec 08             	sub    $0x8,%esp
   12552:	68 4f 44 01 00       	push   $0x1444f
   12557:	ff 75 08             	pushl  0x8(%ebp)
   1255a:	e8 68 fe ff ff       	call   123c7 <do_default_handler>
   1255f:	83 c4 10             	add    $0x10,%esp
}
   12562:	90                   	nop
   12563:	c9                   	leave  
   12564:	c3                   	ret    

00012565 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   12565:	55                   	push   %ebp
   12566:	89 e5                	mov    %esp,%ebp
   12568:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Stack-Segment Fault.");
   1256b:	83 ec 08             	sub    $0x8,%esp
   1256e:	68 64 44 01 00       	push   $0x14464
   12573:	ff 75 08             	pushl  0x8(%ebp)
   12576:	e8 4c fe ff ff       	call   123c7 <do_default_handler>
   1257b:	83 c4 10             	add    $0x10,%esp
}
   1257e:	90                   	nop
   1257f:	c9                   	leave  
   12580:	c3                   	ret    

00012581 <do_handler_fpu_error>:

void do_handler_fpu_error(exception_frame_t *frame)
{
   12581:	55                   	push   %ebp
   12582:	89 e5                	mov    %esp,%ebp
   12584:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "X87 FPU Floating Point Error.");
   12587:	83 ec 08             	sub    $0x8,%esp
   1258a:	68 79 44 01 00       	push   $0x14479
   1258f:	ff 75 08             	pushl  0x8(%ebp)
   12592:	e8 30 fe ff ff       	call   123c7 <do_default_handler>
   12597:	83 c4 10             	add    $0x10,%esp
}
   1259a:	90                   	nop
   1259b:	c9                   	leave  
   1259c:	c3                   	ret    

0001259d <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t *frame)
{
   1259d:	55                   	push   %ebp
   1259e:	89 e5                	mov    %esp,%ebp
   125a0:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Alignment Check.");
   125a3:	83 ec 08             	sub    $0x8,%esp
   125a6:	68 97 44 01 00       	push   $0x14497
   125ab:	ff 75 08             	pushl  0x8(%ebp)
   125ae:	e8 14 fe ff ff       	call   123c7 <do_default_handler>
   125b3:	83 c4 10             	add    $0x10,%esp
}
   125b6:	90                   	nop
   125b7:	c9                   	leave  
   125b8:	c3                   	ret    

000125b9 <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t *frame)
{
   125b9:	55                   	push   %ebp
   125ba:	89 e5                	mov    %esp,%ebp
   125bc:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Machine Check.");
   125bf:	83 ec 08             	sub    $0x8,%esp
   125c2:	68 a8 44 01 00       	push   $0x144a8
   125c7:	ff 75 08             	pushl  0x8(%ebp)
   125ca:	e8 f8 fd ff ff       	call   123c7 <do_default_handler>
   125cf:	83 c4 10             	add    $0x10,%esp
}
   125d2:	90                   	nop
   125d3:	c9                   	leave  
   125d4:	c3                   	ret    

000125d5 <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t *frame)
{
   125d5:	55                   	push   %ebp
   125d6:	89 e5                	mov    %esp,%ebp
   125d8:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "SIMD Floating Point Exception.");
   125db:	83 ec 08             	sub    $0x8,%esp
   125de:	68 b8 44 01 00       	push   $0x144b8
   125e3:	ff 75 08             	pushl  0x8(%ebp)
   125e6:	e8 dc fd ff ff       	call   123c7 <do_default_handler>
   125eb:	83 c4 10             	add    $0x10,%esp
}
   125ee:	90                   	nop
   125ef:	c9                   	leave  
   125f0:	c3                   	ret    

000125f1 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t *frame)
{
   125f1:	55                   	push   %ebp
   125f2:	89 e5                	mov    %esp,%ebp
   125f4:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Virtualization Exception.");
   125f7:	83 ec 08             	sub    $0x8,%esp
   125fa:	68 d7 44 01 00       	push   $0x144d7
   125ff:	ff 75 08             	pushl  0x8(%ebp)
   12602:	e8 c0 fd ff ff       	call   123c7 <do_default_handler>
   12607:	83 c4 10             	add    $0x10,%esp
}
   1260a:	90                   	nop
   1260b:	c9                   	leave  
   1260c:	c3                   	ret    

0001260d <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t *frame)
{
   1260d:	55                   	push   %ebp
   1260e:	89 e5                	mov    %esp,%ebp
   12610:	83 ec 08             	sub    $0x8,%esp
    // do_default_handler(frame, "General_protection Exception.");
    log_printf("--------------------------------");
   12613:	83 ec 0c             	sub    $0xc,%esp
   12616:	68 64 43 01 00       	push   $0x14364
   1261b:	e8 a8 16 00 00       	call   13cc8 <log_printf>
   12620:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   12623:	83 ec 0c             	sub    $0xc,%esp
   12626:	68 f4 44 01 00       	push   $0x144f4
   1262b:	e8 98 16 00 00       	call   13cc8 <log_printf>
   12630:	83 c4 10             	add    $0x10,%esp
    if (frame->err_code & ERR_EXT)
   12633:	8b 45 08             	mov    0x8(%ebp),%eax
   12636:	8b 40 34             	mov    0x34(%eax),%eax
   12639:	83 e0 01             	and    $0x1,%eax
   1263c:	85 c0                	test   %eax,%eax
   1263e:	74 12                	je     12652 <do_handler_general_protection+0x45>
    {
        log_printf("the exception occurred during delivery of an "
   12640:	83 ec 0c             	sub    $0xc,%esp
   12643:	68 20 45 01 00       	push   $0x14520
   12648:	e8 7b 16 00 00       	call   13cc8 <log_printf>
   1264d:	83 c4 10             	add    $0x10,%esp
   12650:	eb 10                	jmp    12662 <do_handler_general_protection+0x55>
                   "event external to the program, such as an interrupt"
                   "or an earlier exception.");
    }
    else
    {
        log_printf("the exception occurred during delivery of a"
   12652:	83 ec 0c             	sub    $0xc,%esp
   12655:	68 9c 45 01 00       	push   $0x1459c
   1265a:	e8 69 16 00 00       	call   13cc8 <log_printf>
   1265f:	83 c4 10             	add    $0x10,%esp
                   "software interrupt (INT n, INT3, or INTO).");
    }

    if (frame->err_code & ERR_IDT)
   12662:	8b 45 08             	mov    0x8(%ebp),%eax
   12665:	8b 40 34             	mov    0x34(%eax),%eax
   12668:	83 e0 02             	and    $0x2,%eax
   1266b:	85 c0                	test   %eax,%eax
   1266d:	74 12                	je     12681 <do_handler_general_protection+0x74>
    {
        log_printf("the index portion of the error code refers "
   1266f:	83 ec 0c             	sub    $0xc,%esp
   12672:	68 f4 45 01 00       	push   $0x145f4
   12677:	e8 4c 16 00 00       	call   13cc8 <log_printf>
   1267c:	83 c4 10             	add    $0x10,%esp
   1267f:	eb 10                	jmp    12691 <do_handler_general_protection+0x84>
                   "to a gate descriptor in the IDT");
    }
    else
    {
        log_printf("the index refers to a descriptor in the GDT");
   12681:	83 ec 0c             	sub    $0xc,%esp
   12684:	68 40 46 01 00       	push   $0x14640
   12689:	e8 3a 16 00 00       	call   13cc8 <log_printf>
   1268e:	83 c4 10             	add    $0x10,%esp
    }

    log_printf("segment index: %d", frame->err_code & 0xFFF8);
   12691:	8b 45 08             	mov    0x8(%ebp),%eax
   12694:	8b 40 34             	mov    0x34(%eax),%eax
   12697:	25 f8 ff 00 00       	and    $0xfff8,%eax
   1269c:	83 ec 08             	sub    $0x8,%esp
   1269f:	50                   	push   %eax
   126a0:	68 6c 46 01 00       	push   $0x1466c
   126a5:	e8 1e 16 00 00       	call   13cc8 <log_printf>
   126aa:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   126ad:	83 ec 0c             	sub    $0xc,%esp
   126b0:	ff 75 08             	pushl  0x8(%ebp)
   126b3:	e8 10 fc ff ff       	call   122c8 <dump_core_regs>
   126b8:	83 c4 10             	add    $0x10,%esp
    while (1)
    {
        hlt();
   126bb:	e8 e6 fb ff ff       	call   122a6 <hlt>
   126c0:	eb f9                	jmp    126bb <do_handler_general_protection+0xae>

000126c2 <do_handler_page_fault>:
    //     }
    // }
}

void do_handler_page_fault(exception_frame_t *frame)
{
   126c2:	55                   	push   %ebp
   126c3:	89 e5                	mov    %esp,%ebp
   126c5:	83 ec 08             	sub    $0x8,%esp

    log_printf("--------------------------------");
   126c8:	83 ec 0c             	sub    $0xc,%esp
   126cb:	68 64 43 01 00       	push   $0x14364
   126d0:	e8 f3 15 00 00       	call   13cc8 <log_printf>
   126d5:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   126d8:	83 ec 0c             	sub    $0xc,%esp
   126db:	68 80 46 01 00       	push   $0x14680
   126e0:	e8 e3 15 00 00       	call   13cc8 <log_printf>
   126e5:	83 c4 10             	add    $0x10,%esp
    // do_default_handler(frame, "Page_fault Exception.");
    if (frame->err_code & ERR_PAGE_P)
   126e8:	8b 45 08             	mov    0x8(%ebp),%eax
   126eb:	8b 40 34             	mov    0x34(%eax),%eax
   126ee:	83 e0 01             	and    $0x1,%eax
   126f1:	85 c0                	test   %eax,%eax
   126f3:	74 18                	je     1270d <do_handler_page_fault+0x4b>
    {
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   126f5:	e8 9b fb ff ff       	call   12295 <read_cr2>
   126fa:	83 ec 08             	sub    $0x8,%esp
   126fd:	50                   	push   %eax
   126fe:	68 a4 46 01 00       	push   $0x146a4
   12703:	e8 c0 15 00 00       	call   13cc8 <log_printf>
   12708:	83 c4 10             	add    $0x10,%esp
   1270b:	eb 16                	jmp    12723 <do_handler_page_fault+0x61>
    }
    else
    {
        log_printf("\tPage doesn't present 0x%x", read_cr2());
   1270d:	e8 83 fb ff ff       	call   12295 <read_cr2>
   12712:	83 ec 08             	sub    $0x8,%esp
   12715:	50                   	push   %eax
   12716:	68 cc 46 01 00       	push   $0x146cc
   1271b:	e8 a8 15 00 00       	call   13cc8 <log_printf>
   12720:	83 c4 10             	add    $0x10,%esp
    }

    if (frame->err_code & ERR_PAGE_WR)
   12723:	8b 45 08             	mov    0x8(%ebp),%eax
   12726:	8b 40 34             	mov    0x34(%eax),%eax
   12729:	83 e0 02             	and    $0x2,%eax
   1272c:	85 c0                	test   %eax,%eax
   1272e:	74 12                	je     12742 <do_handler_page_fault+0x80>
    {
        log_printf("\tThe access causing the fault was a read.");
   12730:	83 ec 0c             	sub    $0xc,%esp
   12733:	68 e8 46 01 00       	push   $0x146e8
   12738:	e8 8b 15 00 00       	call   13cc8 <log_printf>
   1273d:	83 c4 10             	add    $0x10,%esp
   12740:	eb 10                	jmp    12752 <do_handler_page_fault+0x90>
    }
    else
    {
        log_printf("\tThe access causing the fault was a write.");
   12742:	83 ec 0c             	sub    $0xc,%esp
   12745:	68 14 47 01 00       	push   $0x14714
   1274a:	e8 79 15 00 00       	call   13cc8 <log_printf>
   1274f:	83 c4 10             	add    $0x10,%esp
    }

    if (frame->err_code & ERR_PAGE_US)
   12752:	8b 45 08             	mov    0x8(%ebp),%eax
   12755:	8b 40 34             	mov    0x34(%eax),%eax
   12758:	83 e0 02             	and    $0x2,%eax
   1275b:	85 c0                	test   %eax,%eax
   1275d:	74 12                	je     12771 <do_handler_page_fault+0xaf>
    {
        log_printf("\tA supervisor-mode access caused the fault.");
   1275f:	83 ec 0c             	sub    $0xc,%esp
   12762:	68 40 47 01 00       	push   $0x14740
   12767:	e8 5c 15 00 00       	call   13cc8 <log_printf>
   1276c:	83 c4 10             	add    $0x10,%esp
   1276f:	eb 10                	jmp    12781 <do_handler_page_fault+0xbf>
    }
    else
    {
        log_printf("\tA user-mode access caused the fault.");
   12771:	83 ec 0c             	sub    $0xc,%esp
   12774:	68 6c 47 01 00       	push   $0x1476c
   12779:	e8 4a 15 00 00       	call   13cc8 <log_printf>
   1277e:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12781:	83 ec 0c             	sub    $0xc,%esp
   12784:	ff 75 08             	pushl  0x8(%ebp)
   12787:	e8 3c fb ff ff       	call   122c8 <dump_core_regs>
   1278c:	83 c4 10             	add    $0x10,%esp
    while (1)
    {
        hlt();
   1278f:	e8 12 fb ff ff       	call   122a6 <hlt>
   12794:	eb f9                	jmp    1278f <do_handler_page_fault+0xcd>

00012796 <init_pic>:
    //     }
    // }
}

static void init_pic(void)
{
   12796:	55                   	push   %ebp
   12797:	89 e5                	mov    %esp,%ebp
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   12799:	6a 11                	push   $0x11
   1279b:	6a 20                	push   $0x20
   1279d:	e8 9e fa ff ff       	call   12240 <outb>
   127a2:	83 c4 08             	add    $0x8,%esp
    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
   127a5:	6a 20                	push   $0x20
   127a7:	6a 21                	push   $0x21
   127a9:	e8 92 fa ff ff       	call   12240 <outb>
   127ae:	83 c4 08             	add    $0x8,%esp
    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
   127b1:	6a 04                	push   $0x4
   127b3:	6a 21                	push   $0x21
   127b5:	e8 86 fa ff ff       	call   12240 <outb>
   127ba:	83 c4 08             	add    $0x8,%esp
    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086);
   127bd:	6a 01                	push   $0x1
   127bf:	6a 21                	push   $0x21
   127c1:	e8 7a fa ff ff       	call   12240 <outb>
   127c6:	83 c4 08             	add    $0x8,%esp

    // 第二块芯片
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   127c9:	6a 11                	push   $0x11
   127cb:	68 a0 00 00 00       	push   $0xa0
   127d0:	e8 6b fa ff ff       	call   12240 <outb>
   127d5:	83 c4 08             	add    $0x8,%esp

    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   127d8:	6a 28                	push   $0x28
   127da:	68 a1 00 00 00       	push   $0xa1
   127df:	e8 5c fa ff ff       	call   12240 <outb>
   127e4:	83 c4 08             	add    $0x8,%esp

    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
   127e7:	6a 02                	push   $0x2
   127e9:	68 a1 00 00 00       	push   $0xa1
   127ee:	e8 4d fa ff ff       	call   12240 <outb>
   127f3:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
   127f6:	6a 01                	push   $0x1
   127f8:	68 a1 00 00 00       	push   $0xa1
   127fd:	e8 3e fa ff ff       	call   12240 <outb>
   12802:	83 c4 08             	add    $0x8,%esp

    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   12805:	68 fb 00 00 00       	push   $0xfb
   1280a:	6a 21                	push   $0x21
   1280c:	e8 2f fa ff ff       	call   12240 <outb>
   12811:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   12814:	68 ff 00 00 00       	push   $0xff
   12819:	68 a1 00 00 00       	push   $0xa1
   1281e:	e8 1d fa ff ff       	call   12240 <outb>
   12823:	83 c4 08             	add    $0x8,%esp
}
   12826:	90                   	nop
   12827:	c9                   	leave  
   12828:	c3                   	ret    

00012829 <irq_init>:

void irq_init(void)
{
   12829:	55                   	push   %ebp
   1282a:	89 e5                	mov    %esp,%ebp
   1282c:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   1282f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12836:	eb 25                	jmp    1285d <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   12838:	ba 35 00 01 00       	mov    $0x10035,%edx
   1283d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12840:	c1 e0 03             	shl    $0x3,%eax
   12843:	05 00 18 02 00       	add    $0x21800,%eax
   12848:	68 00 8e 00 00       	push   $0x8e00
   1284d:	52                   	push   %edx
   1284e:	6a 08                	push   $0x8
   12850:	50                   	push   %eax
   12851:	e8 55 f9 ff ff       	call   121ab <gate_desc_set>
   12856:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   12859:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1285d:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   12861:	7e d5                	jle    12838 <irq_init+0xf>
    }
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   12863:	83 ec 08             	sub    $0x8,%esp
   12866:	68 54 00 01 00       	push   $0x10054
   1286b:	6a 00                	push   $0x0
   1286d:	e8 65 01 00 00       	call   129d7 <irq_install>
   12872:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   12875:	83 ec 08             	sub    $0x8,%esp
   12878:	68 73 00 01 00       	push   $0x10073
   1287d:	6a 01                	push   $0x1
   1287f:	e8 53 01 00 00       	call   129d7 <irq_install>
   12884:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   12887:	83 ec 08             	sub    $0x8,%esp
   1288a:	68 92 00 01 00       	push   $0x10092
   1288f:	6a 02                	push   $0x2
   12891:	e8 41 01 00 00       	call   129d7 <irq_install>
   12896:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   12899:	83 ec 08             	sub    $0x8,%esp
   1289c:	68 b1 00 01 00       	push   $0x100b1
   128a1:	6a 03                	push   $0x3
   128a3:	e8 2f 01 00 00       	call   129d7 <irq_install>
   128a8:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   128ab:	83 ec 08             	sub    $0x8,%esp
   128ae:	68 d0 00 01 00       	push   $0x100d0
   128b3:	6a 04                	push   $0x4
   128b5:	e8 1d 01 00 00       	call   129d7 <irq_install>
   128ba:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   128bd:	83 ec 08             	sub    $0x8,%esp
   128c0:	68 ef 00 01 00       	push   $0x100ef
   128c5:	6a 05                	push   $0x5
   128c7:	e8 0b 01 00 00       	call   129d7 <irq_install>
   128cc:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   128cf:	83 ec 08             	sub    $0x8,%esp
   128d2:	68 0e 01 01 00       	push   $0x1010e
   128d7:	6a 06                	push   $0x6
   128d9:	e8 f9 00 00 00       	call   129d7 <irq_install>
   128de:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   128e1:	83 ec 08             	sub    $0x8,%esp
   128e4:	68 2d 01 01 00       	push   $0x1012d
   128e9:	6a 07                	push   $0x7
   128eb:	e8 e7 00 00 00       	call   129d7 <irq_install>
   128f0:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   128f3:	83 ec 08             	sub    $0x8,%esp
   128f6:	68 4c 01 01 00       	push   $0x1014c
   128fb:	6a 08                	push   $0x8
   128fd:	e8 d5 00 00 00       	call   129d7 <irq_install>
   12902:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   12905:	83 ec 08             	sub    $0x8,%esp
   12908:	68 69 01 01 00       	push   $0x10169
   1290d:	6a 0a                	push   $0xa
   1290f:	e8 c3 00 00 00       	call   129d7 <irq_install>
   12914:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   12917:	83 ec 08             	sub    $0x8,%esp
   1291a:	68 86 01 01 00       	push   $0x10186
   1291f:	6a 0b                	push   $0xb
   12921:	e8 b1 00 00 00       	call   129d7 <irq_install>
   12926:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   12929:	83 ec 08             	sub    $0x8,%esp
   1292c:	68 a3 01 01 00       	push   $0x101a3
   12931:	6a 0c                	push   $0xc
   12933:	e8 9f 00 00 00       	call   129d7 <irq_install>
   12938:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   1293b:	83 ec 08             	sub    $0x8,%esp
   1293e:	68 c0 01 01 00       	push   $0x101c0
   12943:	6a 0d                	push   $0xd
   12945:	e8 8d 00 00 00       	call   129d7 <irq_install>
   1294a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   1294d:	83 ec 08             	sub    $0x8,%esp
   12950:	68 dd 01 01 00       	push   $0x101dd
   12955:	6a 0e                	push   $0xe
   12957:	e8 7b 00 00 00       	call   129d7 <irq_install>
   1295c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   1295f:	83 ec 08             	sub    $0x8,%esp
   12962:	68 fa 01 01 00       	push   $0x101fa
   12967:	6a 10                	push   $0x10
   12969:	e8 69 00 00 00       	call   129d7 <irq_install>
   1296e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   12971:	83 ec 08             	sub    $0x8,%esp
   12974:	68 19 02 01 00       	push   $0x10219
   12979:	6a 11                	push   $0x11
   1297b:	e8 57 00 00 00       	call   129d7 <irq_install>
   12980:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   12983:	83 ec 08             	sub    $0x8,%esp
   12986:	68 36 02 01 00       	push   $0x10236
   1298b:	6a 12                	push   $0x12
   1298d:	e8 45 00 00 00       	call   129d7 <irq_install>
   12992:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   12995:	83 ec 08             	sub    $0x8,%esp
   12998:	68 55 02 01 00       	push   $0x10255
   1299d:	6a 13                	push   $0x13
   1299f:	e8 33 00 00 00       	call   129d7 <irq_install>
   129a4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   129a7:	83 ec 08             	sub    $0x8,%esp
   129aa:	68 74 02 01 00       	push   $0x10274
   129af:	6a 14                	push   $0x14
   129b1:	e8 21 00 00 00       	call   129d7 <irq_install>
   129b6:	83 c4 10             	add    $0x10,%esp
    lidt((uint32_t)idt_table, sizeof(idt_table));
   129b9:	b8 00 18 02 00       	mov    $0x21800,%eax
   129be:	83 ec 08             	sub    $0x8,%esp
   129c1:	68 00 04 00 00       	push   $0x400
   129c6:	50                   	push   %eax
   129c7:	e8 a1 f8 ff ff       	call   1226d <lidt>
   129cc:	83 c4 10             	add    $0x10,%esp

    init_pic();
   129cf:	e8 c2 fd ff ff       	call   12796 <init_pic>
}
   129d4:	90                   	nop
   129d5:	c9                   	leave  
   129d6:	c3                   	ret    

000129d7 <irq_install>:

int irq_install(int irq_num, irq_handler_t handler)
{
   129d7:	55                   	push   %ebp
   129d8:	89 e5                	mov    %esp,%ebp
   129da:	83 ec 08             	sub    $0x8,%esp
    if (irq_num >= IDT_TABLE_NR)
   129dd:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   129e1:	7e 07                	jle    129ea <irq_install+0x13>
    {
        return -1;
   129e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   129e8:	eb 25                	jmp    12a0f <irq_install+0x38>
    }

    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   129ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   129ed:	8b 55 08             	mov    0x8(%ebp),%edx
   129f0:	c1 e2 03             	shl    $0x3,%edx
   129f3:	81 c2 00 18 02 00    	add    $0x21800,%edx
   129f9:	68 00 8e 00 00       	push   $0x8e00
   129fe:	50                   	push   %eax
   129ff:	6a 08                	push   $0x8
   12a01:	52                   	push   %edx
   12a02:	e8 a4 f7 ff ff       	call   121ab <gate_desc_set>
   12a07:	83 c4 10             	add    $0x10,%esp
    return 0;
   12a0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12a0f:	c9                   	leave  
   12a10:	c3                   	ret    

00012a11 <irq_enable>:

void irq_enable(int irq_num)
{
   12a11:	55                   	push   %ebp
   12a12:	89 e5                	mov    %esp,%ebp
   12a14:	53                   	push   %ebx
   12a15:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   12a18:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12a1c:	7e 78                	jle    12a96 <irq_enable+0x85>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   12a1e:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   12a22:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12a26:	7f 32                	jg     12a5a <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   12a28:	6a 21                	push   $0x21
   12a2a:	e8 f4 f7 ff ff       	call   12223 <inb>
   12a2f:	83 c4 04             	add    $0x4,%esp
   12a32:	89 c2                	mov    %eax,%edx
   12a34:	8b 45 08             	mov    0x8(%ebp),%eax
   12a37:	bb 01 00 00 00       	mov    $0x1,%ebx
   12a3c:	89 c1                	mov    %eax,%ecx
   12a3e:	d3 e3                	shl    %cl,%ebx
   12a40:	89 d8                	mov    %ebx,%eax
   12a42:	f7 d0                	not    %eax
   12a44:	21 d0                	and    %edx,%eax
   12a46:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   12a49:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12a4d:	50                   	push   %eax
   12a4e:	6a 21                	push   $0x21
   12a50:	e8 eb f7 ff ff       	call   12240 <outb>
   12a55:	83 c4 08             	add    $0x8,%esp
   12a58:	eb 3d                	jmp    12a97 <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   12a5a:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   12a5e:	68 a1 00 00 00       	push   $0xa1
   12a63:	e8 bb f7 ff ff       	call   12223 <inb>
   12a68:	83 c4 04             	add    $0x4,%esp
   12a6b:	89 c2                	mov    %eax,%edx
   12a6d:	8b 45 08             	mov    0x8(%ebp),%eax
   12a70:	bb 01 00 00 00       	mov    $0x1,%ebx
   12a75:	89 c1                	mov    %eax,%ecx
   12a77:	d3 e3                	shl    %cl,%ebx
   12a79:	89 d8                	mov    %ebx,%eax
   12a7b:	f7 d0                	not    %eax
   12a7d:	21 d0                	and    %edx,%eax
   12a7f:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   12a82:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12a86:	50                   	push   %eax
   12a87:	68 a1 00 00 00       	push   $0xa1
   12a8c:	e8 af f7 ff ff       	call   12240 <outb>
   12a91:	83 c4 08             	add    $0x8,%esp
   12a94:	eb 01                	jmp    12a97 <irq_enable+0x86>
        return;
   12a96:	90                   	nop
    }
}
   12a97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12a9a:	c9                   	leave  
   12a9b:	c3                   	ret    

00012a9c <irq_disable>:

void irq_disable(int irq_num)
{
   12a9c:	55                   	push   %ebp
   12a9d:	89 e5                	mov    %esp,%ebp
   12a9f:	53                   	push   %ebx
   12aa0:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   12aa3:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12aa7:	7e 74                	jle    12b1d <irq_disable+0x81>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   12aa9:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   12aad:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12ab1:	7f 30                	jg     12ae3 <irq_disable+0x47>
    {
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   12ab3:	6a 21                	push   $0x21
   12ab5:	e8 69 f7 ff ff       	call   12223 <inb>
   12aba:	83 c4 04             	add    $0x4,%esp
   12abd:	89 c3                	mov    %eax,%ebx
   12abf:	8b 45 08             	mov    0x8(%ebp),%eax
   12ac2:	ba 01 00 00 00       	mov    $0x1,%edx
   12ac7:	89 c1                	mov    %eax,%ecx
   12ac9:	d3 e2                	shl    %cl,%edx
   12acb:	89 d0                	mov    %edx,%eax
   12acd:	09 d8                	or     %ebx,%eax
   12acf:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   12ad2:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12ad6:	50                   	push   %eax
   12ad7:	6a 21                	push   $0x21
   12ad9:	e8 62 f7 ff ff       	call   12240 <outb>
   12ade:	83 c4 08             	add    $0x8,%esp
   12ae1:	eb 3b                	jmp    12b1e <irq_disable+0x82>
    }
    else
    {
        irq_num -= 8;
   12ae3:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   12ae7:	68 a1 00 00 00       	push   $0xa1
   12aec:	e8 32 f7 ff ff       	call   12223 <inb>
   12af1:	83 c4 04             	add    $0x4,%esp
   12af4:	89 c3                	mov    %eax,%ebx
   12af6:	8b 45 08             	mov    0x8(%ebp),%eax
   12af9:	ba 01 00 00 00       	mov    $0x1,%edx
   12afe:	89 c1                	mov    %eax,%ecx
   12b00:	d3 e2                	shl    %cl,%edx
   12b02:	89 d0                	mov    %edx,%eax
   12b04:	09 d8                	or     %ebx,%eax
   12b06:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   12b09:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12b0d:	50                   	push   %eax
   12b0e:	68 a1 00 00 00       	push   $0xa1
   12b13:	e8 28 f7 ff ff       	call   12240 <outb>
   12b18:	83 c4 08             	add    $0x8,%esp
   12b1b:	eb 01                	jmp    12b1e <irq_disable+0x82>
        return;
   12b1d:	90                   	nop
    }
}
   12b1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12b21:	c9                   	leave  
   12b22:	c3                   	ret    

00012b23 <irq_disable_global>:

void irq_disable_global(void)
{
   12b23:	55                   	push   %ebp
   12b24:	89 e5                	mov    %esp,%ebp
    cli();
   12b26:	e8 34 f7 ff ff       	call   1225f <cli>
}
   12b2b:	90                   	nop
   12b2c:	5d                   	pop    %ebp
   12b2d:	c3                   	ret    

00012b2e <irq_enable_global>:

void irq_enable_global(void)
{
   12b2e:	55                   	push   %ebp
   12b2f:	89 e5                	mov    %esp,%ebp
    sti();
   12b31:	e8 30 f7 ff ff       	call   12266 <sti>
}
   12b36:	90                   	nop
   12b37:	5d                   	pop    %ebp
   12b38:	c3                   	ret    

00012b39 <pic_send_eoi>:

void pic_send_eoi(int irq_num)
{
   12b39:	55                   	push   %ebp
   12b3a:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   12b3c:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    // 从片也可能需要发送EOI
    if (irq_num >= 8)
   12b40:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12b44:	7e 0f                	jle    12b55 <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   12b46:	6a 20                	push   $0x20
   12b48:	68 a0 00 00 00       	push   $0xa0
   12b4d:	e8 ee f6 ff ff       	call   12240 <outb>
   12b52:	83 c4 08             	add    $0x8,%esp
    }

    outb(PIC0_OCW2, PIC_OCW2_EOI);
   12b55:	6a 20                	push   $0x20
   12b57:	6a 20                	push   $0x20
   12b59:	e8 e2 f6 ff ff       	call   12240 <outb>
   12b5e:	83 c4 08             	add    $0x8,%esp
}
   12b61:	90                   	nop
   12b62:	c9                   	leave  
   12b63:	c3                   	ret    

00012b64 <irq_enter_protection>:

/**
 * @brief 进入中断保护
 */
irq_state_t irq_enter_protection(void)
{
   12b64:	55                   	push   %ebp
   12b65:	89 e5                	mov    %esp,%ebp
   12b67:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags(); // 保存之前的中断状态
   12b6a:	e8 3e f7 ff ff       	call   122ad <read_eflags>
   12b6f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   12b72:	e8 ac ff ff ff       	call   12b23 <irq_disable_global>
    return state;
   12b77:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12b7a:	c9                   	leave  
   12b7b:	c3                   	ret    

00012b7c <irq_leave_protection>:

/**
 * @brief 退出中断保护
 */
void irq_leave_protection(irq_state_t state)
{
   12b7c:	55                   	push   %ebp
   12b7d:	89 e5                	mov    %esp,%ebp
    write_eflags(state); // 恢复之前的中断状态
   12b7f:	ff 75 08             	pushl  0x8(%ebp)
   12b82:	e8 36 f7 ff ff       	call   122bd <write_eflags>
   12b87:	83 c4 04             	add    $0x4,%esp
   12b8a:	90                   	nop
   12b8b:	c9                   	leave  
   12b8c:	c3                   	ret    

00012b8d <outb>:
{
   12b8d:	55                   	push   %ebp
   12b8e:	89 e5                	mov    %esp,%ebp
   12b90:	83 ec 08             	sub    $0x8,%esp
   12b93:	8b 55 08             	mov    0x8(%ebp),%edx
   12b96:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b99:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12b9d:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   12ba0:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12ba4:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12ba8:	ee                   	out    %al,(%dx)
}
   12ba9:	90                   	nop
   12baa:	c9                   	leave  
   12bab:	c3                   	ret    

00012bac <init_pic>:
#include "cpu/irq.h"
#include "os_cfg.h"
#include "comm/cpu_instr.h"
static uint32_t sys_tick;
static void init_pic(void)
{
   12bac:	55                   	push   %ebp
   12bad:	89 e5                	mov    %esp,%ebp
   12baf:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS); // 每隔10ms+1
   12bb2:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
   12bb9:	6a 36                	push   $0x36
   12bbb:	6a 43                	push   $0x43
   12bbd:	e8 cb ff ff ff       	call   12b8d <outb>
   12bc2:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);        // 加载低8位
   12bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12bc8:	0f b6 c0             	movzbl %al,%eax
   12bcb:	50                   	push   %eax
   12bcc:	6a 40                	push   $0x40
   12bce:	e8 ba ff ff ff       	call   12b8d <outb>
   12bd3:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   12bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12bd9:	c1 e8 08             	shr    $0x8,%eax
   12bdc:	0f b6 c0             	movzbl %al,%eax
   12bdf:	50                   	push   %eax
   12be0:	6a 40                	push   $0x40
   12be2:	e8 a6 ff ff ff       	call   12b8d <outb>
   12be7:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_timer);
   12bea:	83 ec 08             	sub    $0x8,%esp
   12bed:	68 93 02 01 00       	push   $0x10293
   12bf2:	6a 20                	push   $0x20
   12bf4:	e8 de fd ff ff       	call   129d7 <irq_install>
   12bf9:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   12bfc:	83 ec 0c             	sub    $0xc,%esp
   12bff:	6a 20                	push   $0x20
   12c01:	e8 0b fe ff ff       	call   12a11 <irq_enable>
   12c06:	83 c4 10             	add    $0x10,%esp
}
   12c09:	90                   	nop
   12c0a:	c9                   	leave  
   12c0b:	c3                   	ret    

00012c0c <do_handler_timer>:
void do_handler_timer(exception_frame_t *frame)
{
   12c0c:	55                   	push   %ebp
   12c0d:	89 e5                	mov    %esp,%ebp
   12c0f:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   12c12:	a1 00 1c 02 00       	mov    0x21c00,%eax
   12c17:	83 c0 01             	add    $0x1,%eax
   12c1a:	a3 00 1c 02 00       	mov    %eax,0x21c00
    // 先发EOI，而不是放在最后
    // 放最后将从任务中切换出去之后，除非任务再切换回来才能继续响应
    pic_send_eoi(IRQ0_TIMER);
   12c1f:	83 ec 0c             	sub    $0xc,%esp
   12c22:	6a 20                	push   $0x20
   12c24:	e8 10 ff ff ff       	call   12b39 <pic_send_eoi>
   12c29:	83 c4 10             	add    $0x10,%esp

    task_time_tick();
   12c2c:	e8 ca e8 ff ff       	call   114fb <task_time_tick>
}
   12c31:	90                   	nop
   12c32:	c9                   	leave  
   12c33:	c3                   	ret    

00012c34 <time_init>:
void time_init(void)
{
   12c34:	55                   	push   %ebp
   12c35:	89 e5                	mov    %esp,%ebp
   12c37:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   12c3a:	c7 05 00 1c 02 00 00 	movl   $0x0,0x21c00
   12c41:	00 00 00 
    init_pic();
   12c44:	e8 63 ff ff ff       	call   12bac <init_pic>
   12c49:	90                   	nop
   12c4a:	c9                   	leave  
   12c4b:	c3                   	ret    

00012c4c <inb>:
{
   12c4c:	55                   	push   %ebp
   12c4d:	89 e5                	mov    %esp,%ebp
   12c4f:	83 ec 14             	sub    $0x14,%esp
   12c52:	8b 45 08             	mov    0x8(%ebp),%eax
   12c55:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12c59:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12c5d:	89 c2                	mov    %eax,%edx
   12c5f:	ec                   	in     (%dx),%al
   12c60:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12c63:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12c67:	c9                   	leave  
   12c68:	c3                   	ret    

00012c69 <inw>:
{
   12c69:	55                   	push   %ebp
   12c6a:	89 e5                	mov    %esp,%ebp
   12c6c:	83 ec 14             	sub    $0x14,%esp
   12c6f:	8b 45 08             	mov    0x8(%ebp),%eax
   12c72:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("in %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12c76:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12c7a:	89 c2                	mov    %eax,%edx
   12c7c:	66 ed                	in     (%dx),%ax
   12c7e:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   12c82:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   12c86:	c9                   	leave  
   12c87:	c3                   	ret    

00012c88 <outb>:
{
   12c88:	55                   	push   %ebp
   12c89:	89 e5                	mov    %esp,%ebp
   12c8b:	83 ec 08             	sub    $0x8,%esp
   12c8e:	8b 55 08             	mov    0x8(%ebp),%edx
   12c91:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c94:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12c98:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   12c9b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12c9f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12ca3:	ee                   	out    %al,(%dx)
}
   12ca4:	90                   	nop
   12ca5:	c9                   	leave  
   12ca6:	c3                   	ret    

00012ca7 <read_disk>:
static uint8_t TEMP_ADDR[100 * 1024];
static uint8_t *temp_pos;
#define TEMP_FILE_ID 100

static void read_disk(int sector, int sector_count, uint8_t *buf)
{
   12ca7:	55                   	push   %ebp
   12ca8:	89 e5                	mov    %esp,%ebp
   12caa:	53                   	push   %ebx
   12cab:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t)(0xE0)); // 选择磁盘
   12cae:	68 e0 00 00 00       	push   $0xe0
   12cb3:	68 f6 01 00 00       	push   $0x1f6
   12cb8:	e8 cb ff ff ff       	call   12c88 <outb>
   12cbd:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t)(sector_count >> 8));
   12cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cc3:	c1 f8 08             	sar    $0x8,%eax
   12cc6:	0f b6 c0             	movzbl %al,%eax
   12cc9:	50                   	push   %eax
   12cca:	68 f2 01 00 00       	push   $0x1f2
   12ccf:	e8 b4 ff ff ff       	call   12c88 <outb>
   12cd4:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t)(sector >> 24));
   12cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   12cda:	c1 f8 18             	sar    $0x18,%eax
   12cdd:	0f b6 c0             	movzbl %al,%eax
   12ce0:	50                   	push   %eax
   12ce1:	68 f3 01 00 00       	push   $0x1f3
   12ce6:	e8 9d ff ff ff       	call   12c88 <outb>
   12ceb:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t)(0));
   12cee:	6a 00                	push   $0x0
   12cf0:	68 f4 01 00 00       	push   $0x1f4
   12cf5:	e8 8e ff ff ff       	call   12c88 <outb>
   12cfa:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t)(0));
   12cfd:	6a 00                	push   $0x0
   12cff:	68 f5 01 00 00       	push   $0x1f5
   12d04:	e8 7f ff ff ff       	call   12c88 <outb>
   12d09:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t)(sector_count));
   12d0c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d0f:	0f b6 c0             	movzbl %al,%eax
   12d12:	50                   	push   %eax
   12d13:	68 f2 01 00 00       	push   $0x1f2
   12d18:	e8 6b ff ff ff       	call   12c88 <outb>
   12d1d:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t)(sector));
   12d20:	8b 45 08             	mov    0x8(%ebp),%eax
   12d23:	0f b6 c0             	movzbl %al,%eax
   12d26:	50                   	push   %eax
   12d27:	68 f3 01 00 00       	push   $0x1f3
   12d2c:	e8 57 ff ff ff       	call   12c88 <outb>
   12d31:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t)(sector >> 8));
   12d34:	8b 45 08             	mov    0x8(%ebp),%eax
   12d37:	c1 f8 08             	sar    $0x8,%eax
   12d3a:	0f b6 c0             	movzbl %al,%eax
   12d3d:	50                   	push   %eax
   12d3e:	68 f4 01 00 00       	push   $0x1f4
   12d43:	e8 40 ff ff ff       	call   12c88 <outb>
   12d48:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t)(sector >> 16));
   12d4b:	8b 45 08             	mov    0x8(%ebp),%eax
   12d4e:	c1 f8 10             	sar    $0x10,%eax
   12d51:	0f b6 c0             	movzbl %al,%eax
   12d54:	50                   	push   %eax
   12d55:	68 f5 01 00 00       	push   $0x1f5
   12d5a:	e8 29 ff ff ff       	call   12c88 <outb>
   12d5f:	83 c4 08             	add    $0x8,%esp

    outb(0x1F7, (uint8_t)(0x24));
   12d62:	6a 24                	push   $0x24
   12d64:	68 f7 01 00 00       	push   $0x1f7
   12d69:	e8 1a ff ff ff       	call   12c88 <outb>
   12d6e:	83 c4 08             	add    $0x8,%esp

    uint16_t *data_buf = (uint16_t *)buf;
   12d71:	8b 45 10             	mov    0x10(%ebp),%eax
   12d74:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (sector_count-- > 0)
   12d77:	eb 4a                	jmp    12dc3 <read_disk+0x11c>
    {
        while ((inb(0x1F7) & 0x88) != 0x8)
   12d79:	90                   	nop
   12d7a:	68 f7 01 00 00       	push   $0x1f7
   12d7f:	e8 c8 fe ff ff       	call   12c4c <inb>
   12d84:	83 c4 04             	add    $0x4,%esp
   12d87:	0f b6 c0             	movzbl %al,%eax
   12d8a:	25 88 00 00 00       	and    $0x88,%eax
   12d8f:	83 f8 08             	cmp    $0x8,%eax
   12d92:	75 e6                	jne    12d7a <read_disk+0xd3>
        {
            /* code */
        }
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
   12d94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12d9b:	eb 1d                	jmp    12dba <read_disk+0x113>
        {
            *data_buf++ = inw(0x1F0);
   12d9d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   12da0:	8d 43 02             	lea    0x2(%ebx),%eax
   12da3:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12da6:	68 f0 01 00 00       	push   $0x1f0
   12dab:	e8 b9 fe ff ff       	call   12c69 <inw>
   12db0:	83 c4 04             	add    $0x4,%esp
   12db3:	66 89 03             	mov    %ax,(%ebx)
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
   12db6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12dba:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12dc1:	7e da                	jle    12d9d <read_disk+0xf6>
    while (sector_count-- > 0)
   12dc3:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dc6:	8d 50 ff             	lea    -0x1(%eax),%edx
   12dc9:	89 55 0c             	mov    %edx,0xc(%ebp)
   12dcc:	85 c0                	test   %eax,%eax
   12dce:	7f a9                	jg     12d79 <read_disk+0xd2>
            /* code */
        }
    }
}
   12dd0:	90                   	nop
   12dd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12dd4:	c9                   	leave  
   12dd5:	c3                   	ret    

00012dd6 <sys_open>:

int sys_open(const char *name, int flags, ...)
{
   12dd6:	55                   	push   %ebp
   12dd7:	89 e5                	mov    %esp,%ebp
    if (name[0] == '/')
   12dd9:	8b 45 08             	mov    0x8(%ebp),%eax
   12ddc:	0f b6 00             	movzbl (%eax),%eax
   12ddf:	3c 2f                	cmp    $0x2f,%al
   12de1:	75 25                	jne    12e08 <sys_open+0x32>
    {
        read_disk(5000, 80, (uint8_t *)TEMP_ADDR);
   12de3:	68 20 1c 02 00       	push   $0x21c20
   12de8:	6a 50                	push   $0x50
   12dea:	68 88 13 00 00       	push   $0x1388
   12def:	e8 b3 fe ff ff       	call   12ca7 <read_disk>
   12df4:	83 c4 0c             	add    $0xc,%esp
        temp_pos = (uint8_t *)TEMP_ADDR;
   12df7:	c7 05 20 ac 03 00 20 	movl   $0x21c20,0x3ac20
   12dfe:	1c 02 00 
        return TEMP_FILE_ID;
   12e01:	b8 64 00 00 00       	mov    $0x64,%eax
   12e06:	eb 05                	jmp    12e0d <sys_open+0x37>
    }
    return -1;
   12e08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12e0d:	c9                   	leave  
   12e0e:	c3                   	ret    

00012e0f <sys_read>:

int sys_read(int file, char *ptr, int len)
{
   12e0f:	55                   	push   %ebp
   12e10:	89 e5                	mov    %esp,%ebp
   12e12:	83 ec 08             	sub    $0x8,%esp
    if (file == TEMP_FILE_ID)
   12e15:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   12e19:	75 2c                	jne    12e47 <sys_read+0x38>
    {
        kernel_memcpy(ptr, temp_pos, len);
   12e1b:	a1 20 ac 03 00       	mov    0x3ac20,%eax
   12e20:	83 ec 04             	sub    $0x4,%esp
   12e23:	ff 75 10             	pushl  0x10(%ebp)
   12e26:	50                   	push   %eax
   12e27:	ff 75 0c             	pushl  0xc(%ebp)
   12e2a:	e8 cb 07 00 00       	call   135fa <kernel_memcpy>
   12e2f:	83 c4 10             	add    $0x10,%esp
        temp_pos += len;
   12e32:	8b 15 20 ac 03 00    	mov    0x3ac20,%edx
   12e38:	8b 45 10             	mov    0x10(%ebp),%eax
   12e3b:	01 d0                	add    %edx,%eax
   12e3d:	a3 20 ac 03 00       	mov    %eax,0x3ac20
        return len;
   12e42:	8b 45 10             	mov    0x10(%ebp),%eax
   12e45:	eb 05                	jmp    12e4c <sys_read+0x3d>
    }
    return -1;
   12e47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12e4c:	c9                   	leave  
   12e4d:	c3                   	ret    

00012e4e <sys_write>:

int sys_write(int file, char *ptr, int len)
{
   12e4e:	55                   	push   %ebp
   12e4f:	89 e5                	mov    %esp,%ebp
    return -1;
   12e51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12e56:	5d                   	pop    %ebp
   12e57:	c3                   	ret    

00012e58 <sys_lseek>:

int sys_lseek(int file, int ptr, int dir)
{
   12e58:	55                   	push   %ebp
   12e59:	89 e5                	mov    %esp,%ebp
    if (file == TEMP_FILE_ID)
   12e5b:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   12e5f:	75 14                	jne    12e75 <sys_lseek+0x1d>
    {
        temp_pos = (uint8_t *)(TEMP_ADDR + ptr);
   12e61:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e64:	05 20 1c 02 00       	add    $0x21c20,%eax
   12e69:	a3 20 ac 03 00       	mov    %eax,0x3ac20
        return 0;
   12e6e:	b8 00 00 00 00       	mov    $0x0,%eax
   12e73:	eb 05                	jmp    12e7a <sys_lseek+0x22>
    }
    return -1;
   12e75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12e7a:	5d                   	pop    %ebp
   12e7b:	c3                   	ret    

00012e7c <sys_close>:

int sys_close(int file)
{
   12e7c:	55                   	push   %ebp
   12e7d:	89 e5                	mov    %esp,%ebp
    return 0;
   12e7f:	b8 00 00 00 00       	mov    $0x0,%eax
   12e84:	5d                   	pop    %ebp
   12e85:	c3                   	ret    

00012e86 <kernel_init>:
#include "comm/cpu_instr.h"
#include "ipc/sem.h"
#include "core/memory.h"

void kernel_init(boot_info_t *boot_info)
{
   12e86:	55                   	push   %ebp
   12e87:	89 e5                	mov    %esp,%ebp
   12e89:	83 ec 08             	sub    $0x8,%esp
    cpu_init();
   12e8c:	e8 61 f3 ff ff       	call   121f2 <cpu_init>
    log_init();
   12e91:	e8 b9 0d 00 00       	call   13c4f <log_init>
    irq_init();
   12e96:	e8 8e f9 ff ff       	call   12829 <irq_init>

    // 内存初始化要放前面一点，因为后面的代码可能需要内存分配
    memory_init(boot_info);
   12e9b:	83 ec 0c             	sub    $0xc,%esp
   12e9e:	ff 75 08             	pushl  0x8(%ebp)
   12ea1:	e8 2b de ff ff       	call   10cd1 <memory_init>
   12ea6:	83 c4 10             	add    $0x10,%esp
    time_init();
   12ea9:	e8 86 fd ff ff       	call   12c34 <time_init>

    task_manager_init();
   12eae:	e8 f6 e3 ff ff       	call   112a9 <task_manager_init>
}
   12eb3:	90                   	nop
   12eb4:	c9                   	leave  
   12eb5:	c3                   	ret    

00012eb6 <move_to_first_task>:

/**
 * @brief 移至第一个进程运行
 */
void move_to_first_task(void)
{
   12eb6:	55                   	push   %ebp
   12eb7:	89 e5                	mov    %esp,%ebp
   12eb9:	56                   	push   %esi
   12eba:	53                   	push   %ebx
   12ebb:	83 ec 10             	sub    $0x10,%esp
    // 不能直接用Jmp far进入，因为当前特权级0，不能跳到低特权级的代码
    // 下面的iret后，还需要手动加载ds, fs, es等寄存器值，iret不会自动加载
    // 注意，运行下面的代码可能会产生异常：段保护异常或页保护异常。
    // 可根据产生的异常类型和错误码，并结合手册来找到问题所在
    task_t *curr = task_current();
   12ebe:	e8 2f e5 ff ff       	call   113f2 <task_current>
   12ec3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr != 0);
   12ec6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12eca:	75 19                	jne    12ee5 <move_to_first_task+0x2f>
   12ecc:	68 0c 48 01 00       	push   $0x1480c
   12ed1:	68 88 48 01 00       	push   $0x14888
   12ed6:	6a 53                	push   $0x53
   12ed8:	68 18 48 01 00       	push   $0x14818
   12edd:	e8 90 0a 00 00       	call   13972 <panic>
   12ee2:	83 c4 10             	add    $0x10,%esp

    tss_t *tss = &(curr->tss);
   12ee5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ee8:	83 c0 50             	add    $0x50,%eax
   12eeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[ss]\n\t"     // SS
        "push %[esp]\n\t"    // ESP
        "push %[eflags]\n\t" // EFLAGS
        "push %[cs]\n\t"     // CS
        "push %[eip]\n\t"    // ip
        "iret\n\t" ::[ss] "r"(tss->ss),
   12eee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12ef1:	8b 40 50             	mov    0x50(%eax),%eax
        [esp] "r"(tss->esp), [eflags] "r"(tss->eflags),
   12ef4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12ef7:	8b 52 38             	mov    0x38(%edx),%edx
   12efa:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12efd:	8b 49 24             	mov    0x24(%ecx),%ecx
        [cs] "r"(tss->cs), [eip] "r"(tss->eip));
   12f00:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   12f03:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
   12f06:	8b 75 f0             	mov    -0x10(%ebp),%esi
   12f09:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   12f0c:	50                   	push   %eax
   12f0d:	52                   	push   %edx
   12f0e:	51                   	push   %ecx
   12f0f:	53                   	push   %ebx
   12f10:	56                   	push   %esi
   12f11:	cf                   	iret   
}
   12f12:	90                   	nop
   12f13:	8d 65 f8             	lea    -0x8(%ebp),%esp
   12f16:	5b                   	pop    %ebx
   12f17:	5e                   	pop    %esi
   12f18:	5d                   	pop    %ebp
   12f19:	c3                   	ret    

00012f1a <init_main>:

void init_main(void)
{
   12f1a:	55                   	push   %ebp
   12f1b:	89 e5                	mov    %esp,%ebp
   12f1d:	83 ec 08             	sub    $0x8,%esp
    // list_test();

    log_printf("Kernel is running...");
   12f20:	83 ec 0c             	sub    $0xc,%esp
   12f23:	68 52 48 01 00       	push   $0x14852
   12f28:	e8 9b 0d 00 00       	call   13cc8 <log_printf>
   12f2d:	83 c4 10             	add    $0x10,%esp
    log_printf("Version: %s", OS_VERSION);
   12f30:	83 ec 08             	sub    $0x8,%esp
   12f33:	68 67 48 01 00       	push   $0x14867
   12f38:	68 6d 48 01 00       	push   $0x1486d
   12f3d:	e8 86 0d 00 00       	call   13cc8 <log_printf>
   12f42:	83 c4 10             	add    $0x10,%esp
    log_printf("%d %d %x %c", 123456, -123, 0x123456, 'a');
   12f45:	83 ec 0c             	sub    $0xc,%esp
   12f48:	6a 61                	push   $0x61
   12f4a:	68 56 34 12 00       	push   $0x123456
   12f4f:	6a 85                	push   $0xffffff85
   12f51:	68 40 e2 01 00       	push   $0x1e240
   12f56:	68 79 48 01 00       	push   $0x14879
   12f5b:	e8 68 0d 00 00       	call   13cc8 <log_printf>
   12f60:	83 c4 20             	add    $0x20,%esp

    // task_init(&init_task, "init task", (uint32_t)init_task_entry, (uint32_t)&init_task_stack[1024]); // 压栈先-4再入栈
    task_first_init();
   12f63:	e8 57 e2 ff ff       	call   111bf <task_first_init>
    move_to_first_task();
   12f68:	e8 49 ff ff ff       	call   12eb6 <move_to_first_task>
    //     sem_notify(&sem);
    //     // sys_msleep(1000);
    //     // task_switch_from_to(task_first_task(), &init_task);
    //     // sys_sched_yield();
    // }
   12f6d:	90                   	nop
   12f6e:	c9                   	leave  
   12f6f:	c3                   	ret    

00012f70 <list_count>:
{
   12f70:	55                   	push   %ebp
   12f71:	89 e5                	mov    %esp,%ebp
    return list->count;
   12f73:	8b 45 08             	mov    0x8(%ebp),%eax
   12f76:	8b 40 08             	mov    0x8(%eax),%eax
}
   12f79:	5d                   	pop    %ebp
   12f7a:	c3                   	ret    

00012f7b <mutex_init>:

/**
 * 锁初始化
 */
void mutex_init(mutex_t *mutex)
{
   12f7b:	55                   	push   %ebp
   12f7c:	89 e5                	mov    %esp,%ebp
   12f7e:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count = 0;
   12f81:	8b 45 08             	mov    0x8(%ebp),%eax
   12f84:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner = (task_t *)0;
   12f8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12f8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   12f94:	8b 45 08             	mov    0x8(%ebp),%eax
   12f97:	83 c0 08             	add    $0x8,%eax
   12f9a:	83 ec 0c             	sub    $0xc,%esp
   12f9d:	50                   	push   %eax
   12f9e:	e8 8b 0a 00 00       	call   13a2e <list_init>
   12fa3:	83 c4 10             	add    $0x10,%esp
}
   12fa6:	90                   	nop
   12fa7:	c9                   	leave  
   12fa8:	c3                   	ret    

00012fa9 <mutex_lock>:

/**
 * 申请锁
 */
void mutex_lock(mutex_t *mutex)
{
   12fa9:	55                   	push   %ebp
   12faa:	89 e5                	mov    %esp,%ebp
   12fac:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   12faf:	e8 b0 fb ff ff       	call   12b64 <irq_enter_protection>
   12fb4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *curr = task_current();
   12fb7:	e8 36 e4 ff ff       	call   113f2 <task_current>
   12fbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->locked_count == 0)
   12fbf:	8b 45 08             	mov    0x8(%ebp),%eax
   12fc2:	8b 40 04             	mov    0x4(%eax),%eax
   12fc5:	85 c0                	test   %eax,%eax
   12fc7:	75 14                	jne    12fdd <mutex_lock+0x34>
    {
        // 没有任务占用，占用之
        mutex->locked_count = 1;
   12fc9:	8b 45 08             	mov    0x8(%ebp),%eax
   12fcc:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner = curr;
   12fd3:	8b 45 08             	mov    0x8(%ebp),%eax
   12fd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12fd9:	89 10                	mov    %edx,(%eax)
   12fdb:	eb 4f                	jmp    1302c <mutex_lock+0x83>
    }
    else if (mutex->owner == curr)
   12fdd:	8b 45 08             	mov    0x8(%ebp),%eax
   12fe0:	8b 00                	mov    (%eax),%eax
   12fe2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12fe5:	75 11                	jne    12ff8 <mutex_lock+0x4f>
    {
        // 已经为当前任务所有，只增加计数
        mutex->locked_count++;
   12fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   12fea:	8b 40 04             	mov    0x4(%eax),%eax
   12fed:	8d 50 01             	lea    0x1(%eax),%edx
   12ff0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ff3:	89 50 04             	mov    %edx,0x4(%eax)
   12ff6:	eb 34                	jmp    1302c <mutex_lock+0x83>
    }
    else
    {
        // 有其它任务占用，则进入队列等待
        task_t *curr = task_current();
   12ff8:	e8 f5 e3 ff ff       	call   113f2 <task_current>
   12ffd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr);
   13000:	83 ec 0c             	sub    $0xc,%esp
   13003:	ff 75 ec             	pushl  -0x14(%ebp)
   13006:	e8 bc e3 ff ff       	call   113c7 <task_set_block>
   1300b:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   1300e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13011:	8d 50 40             	lea    0x40(%eax),%edx
   13014:	8b 45 08             	mov    0x8(%ebp),%eax
   13017:	83 c0 08             	add    $0x8,%eax
   1301a:	83 ec 08             	sub    $0x8,%esp
   1301d:	52                   	push   %edx
   1301e:	50                   	push   %eax
   1301f:	e8 8e 0a 00 00       	call   13ab2 <list_insert_last>
   13024:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   13027:	e8 74 e4 ff ff       	call   114a0 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   1302c:	83 ec 0c             	sub    $0xc,%esp
   1302f:	ff 75 f4             	pushl  -0xc(%ebp)
   13032:	e8 45 fb ff ff       	call   12b7c <irq_leave_protection>
   13037:	83 c4 10             	add    $0x10,%esp
}
   1303a:	90                   	nop
   1303b:	c9                   	leave  
   1303c:	c3                   	ret    

0001303d <mutex_unlock>:

/**
 * 释放锁
 */
void mutex_unlock(mutex_t *mutex)
{
   1303d:	55                   	push   %ebp
   1303e:	89 e5                	mov    %esp,%ebp
   13040:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   13043:	e8 1c fb ff ff       	call   12b64 <irq_enter_protection>
   13048:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 只有锁的拥有者才能释放锁
    task_t *curr = task_current();
   1304b:	e8 a2 e3 ff ff       	call   113f2 <task_current>
   13050:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->owner == curr)
   13053:	8b 45 08             	mov    0x8(%ebp),%eax
   13056:	8b 00                	mov    (%eax),%eax
   13058:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1305b:	0f 85 88 00 00 00    	jne    130e9 <mutex_unlock+0xac>
    {
        if (--mutex->locked_count == 0)
   13061:	8b 45 08             	mov    0x8(%ebp),%eax
   13064:	8b 40 04             	mov    0x4(%eax),%eax
   13067:	8d 50 ff             	lea    -0x1(%eax),%edx
   1306a:	8b 45 08             	mov    0x8(%ebp),%eax
   1306d:	89 50 04             	mov    %edx,0x4(%eax)
   13070:	8b 45 08             	mov    0x8(%ebp),%eax
   13073:	8b 40 04             	mov    0x4(%eax),%eax
   13076:	85 c0                	test   %eax,%eax
   13078:	75 6f                	jne    130e9 <mutex_unlock+0xac>
        {
            // 减到0，释放锁
            mutex->owner = (task_t *)0;
   1307a:	8b 45 08             	mov    0x8(%ebp),%eax
   1307d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            // 如果队列中有任务等待，则立即唤醒并占用锁
            if (list_count(&mutex->wait_list))
   13083:	8b 45 08             	mov    0x8(%ebp),%eax
   13086:	83 c0 08             	add    $0x8,%eax
   13089:	83 ec 0c             	sub    $0xc,%esp
   1308c:	50                   	push   %eax
   1308d:	e8 de fe ff ff       	call   12f70 <list_count>
   13092:	83 c4 10             	add    $0x10,%esp
   13095:	85 c0                	test   %eax,%eax
   13097:	74 50                	je     130e9 <mutex_unlock+0xac>
            {
                list_node_t *task_node = list_remove_first(&mutex->wait_list);
   13099:	8b 45 08             	mov    0x8(%ebp),%eax
   1309c:	83 c0 08             	add    $0x8,%eax
   1309f:	83 ec 0c             	sub    $0xc,%esp
   130a2:	50                   	push   %eax
   130a3:	e8 6e 0a 00 00       	call   13b16 <list_remove_first>
   130a8:	83 c4 10             	add    $0x10,%esp
   130ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t *task = list_node_parent(task_node, task_t, wait_node);
   130ae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   130b2:	74 08                	je     130bc <mutex_unlock+0x7f>
   130b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   130b7:	83 e8 40             	sub    $0x40,%eax
   130ba:	eb 05                	jmp    130c1 <mutex_unlock+0x84>
   130bc:	b8 00 00 00 00       	mov    $0x0,%eax
   130c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   130c4:	83 ec 0c             	sub    $0xc,%esp
   130c7:	ff 75 e8             	pushl  -0x18(%ebp)
   130ca:	e8 c4 e2 ff ff       	call   11393 <task_set_ready>
   130cf:	83 c4 10             	add    $0x10,%esp

                // 在这里占用，而不是在任务醒后占用，因为可能抢不到
                mutex->locked_count = 1;
   130d2:	8b 45 08             	mov    0x8(%ebp),%eax
   130d5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner = task;
   130dc:	8b 45 08             	mov    0x8(%ebp),%eax
   130df:	8b 55 e8             	mov    -0x18(%ebp),%edx
   130e2:	89 10                	mov    %edx,(%eax)

                task_dispatch();
   130e4:	e8 b7 e3 ff ff       	call   114a0 <task_dispatch>
            }
        }
    }

    irq_leave_protection(irq_state);
   130e9:	83 ec 0c             	sub    $0xc,%esp
   130ec:	ff 75 f4             	pushl  -0xc(%ebp)
   130ef:	e8 88 fa ff ff       	call   12b7c <irq_leave_protection>
   130f4:	83 c4 10             	add    $0x10,%esp
   130f7:	90                   	nop
   130f8:	c9                   	leave  
   130f9:	c3                   	ret    

000130fa <list_count>:
{
   130fa:	55                   	push   %ebp
   130fb:	89 e5                	mov    %esp,%ebp
    return list->count;
   130fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13100:	8b 40 08             	mov    0x8(%eax),%eax
}
   13103:	5d                   	pop    %ebp
   13104:	c3                   	ret    

00013105 <sem_init>:

/**
 * 信号量初始化
 */
void sem_init(sem_t *sem, int init_count)
{
   13105:	55                   	push   %ebp
   13106:	89 e5                	mov    %esp,%ebp
   13108:	83 ec 08             	sub    $0x8,%esp
    sem->count = init_count;
   1310b:	8b 45 08             	mov    0x8(%ebp),%eax
   1310e:	8b 55 0c             	mov    0xc(%ebp),%edx
   13111:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   13113:	8b 45 08             	mov    0x8(%ebp),%eax
   13116:	83 c0 04             	add    $0x4,%eax
   13119:	83 ec 0c             	sub    $0xc,%esp
   1311c:	50                   	push   %eax
   1311d:	e8 0c 09 00 00       	call   13a2e <list_init>
   13122:	83 c4 10             	add    $0x10,%esp
}
   13125:	90                   	nop
   13126:	c9                   	leave  
   13127:	c3                   	ret    

00013128 <sem_wait>:

/**
 * 申请信号量
 */
void sem_wait(sem_t *sem)
{
   13128:	55                   	push   %ebp
   13129:	89 e5                	mov    %esp,%ebp
   1312b:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   1312e:	e8 31 fa ff ff       	call   12b64 <irq_enter_protection>
   13133:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (sem->count > 0)
   13136:	8b 45 08             	mov    0x8(%ebp),%eax
   13139:	8b 00                	mov    (%eax),%eax
   1313b:	85 c0                	test   %eax,%eax
   1313d:	7e 0f                	jle    1314e <sem_wait+0x26>
    {
        sem->count--;
   1313f:	8b 45 08             	mov    0x8(%ebp),%eax
   13142:	8b 00                	mov    (%eax),%eax
   13144:	8d 50 ff             	lea    -0x1(%eax),%edx
   13147:	8b 45 08             	mov    0x8(%ebp),%eax
   1314a:	89 10                	mov    %edx,(%eax)
   1314c:	eb 34                	jmp    13182 <sem_wait+0x5a>
    }
    else
    {
        // 从就绪队列中移除，然后加入信号量的等待队列
        task_t *curr = task_current();
   1314e:	e8 9f e2 ff ff       	call   113f2 <task_current>
   13153:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   13156:	83 ec 0c             	sub    $0xc,%esp
   13159:	ff 75 f0             	pushl  -0x10(%ebp)
   1315c:	e8 66 e2 ff ff       	call   113c7 <task_set_block>
   13161:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &curr->wait_node);
   13164:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13167:	8d 50 40             	lea    0x40(%eax),%edx
   1316a:	8b 45 08             	mov    0x8(%ebp),%eax
   1316d:	83 c0 04             	add    $0x4,%eax
   13170:	83 ec 08             	sub    $0x8,%esp
   13173:	52                   	push   %edx
   13174:	50                   	push   %eax
   13175:	e8 38 09 00 00       	call   13ab2 <list_insert_last>
   1317a:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   1317d:	e8 1e e3 ff ff       	call   114a0 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   13182:	83 ec 0c             	sub    $0xc,%esp
   13185:	ff 75 f4             	pushl  -0xc(%ebp)
   13188:	e8 ef f9 ff ff       	call   12b7c <irq_leave_protection>
   1318d:	83 c4 10             	add    $0x10,%esp
}
   13190:	90                   	nop
   13191:	c9                   	leave  
   13192:	c3                   	ret    

00013193 <sem_notify>:

/**
 * 释放信号量
 */
void sem_notify(sem_t *sem)
{
   13193:	55                   	push   %ebp
   13194:	89 e5                	mov    %esp,%ebp
   13196:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   13199:	e8 c6 f9 ff ff       	call   12b64 <irq_enter_protection>
   1319e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&sem->wait_list))
   131a1:	8b 45 08             	mov    0x8(%ebp),%eax
   131a4:	83 c0 04             	add    $0x4,%eax
   131a7:	83 ec 0c             	sub    $0xc,%esp
   131aa:	50                   	push   %eax
   131ab:	e8 4a ff ff ff       	call   130fa <list_count>
   131b0:	83 c4 10             	add    $0x10,%esp
   131b3:	85 c0                	test   %eax,%eax
   131b5:	74 40                	je     131f7 <sem_notify+0x64>
    {
        // 有进程等待，则唤醒加入就绪队列
        list_node_t *node = list_remove_first(&sem->wait_list);
   131b7:	8b 45 08             	mov    0x8(%ebp),%eax
   131ba:	83 c0 04             	add    $0x4,%eax
   131bd:	83 ec 0c             	sub    $0xc,%esp
   131c0:	50                   	push   %eax
   131c1:	e8 50 09 00 00       	call   13b16 <list_remove_first>
   131c6:	83 c4 10             	add    $0x10,%esp
   131c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node, task_t, wait_node);
   131cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   131d0:	74 08                	je     131da <sem_notify+0x47>
   131d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131d5:	83 e8 40             	sub    $0x40,%eax
   131d8:	eb 05                	jmp    131df <sem_notify+0x4c>
   131da:	b8 00 00 00 00       	mov    $0x0,%eax
   131df:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   131e2:	83 ec 0c             	sub    $0xc,%esp
   131e5:	ff 75 ec             	pushl  -0x14(%ebp)
   131e8:	e8 a6 e1 ff ff       	call   11393 <task_set_ready>
   131ed:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   131f0:	e8 ab e2 ff ff       	call   114a0 <task_dispatch>
   131f5:	eb 0d                	jmp    13204 <sem_notify+0x71>
    }
    else
    {
        sem->count++;
   131f7:	8b 45 08             	mov    0x8(%ebp),%eax
   131fa:	8b 00                	mov    (%eax),%eax
   131fc:	8d 50 01             	lea    0x1(%eax),%edx
   131ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13202:	89 10                	mov    %edx,(%eax)
    }

    irq_leave_protection(irq_state);
   13204:	83 ec 0c             	sub    $0xc,%esp
   13207:	ff 75 f4             	pushl  -0xc(%ebp)
   1320a:	e8 6d f9 ff ff       	call   12b7c <irq_leave_protection>
   1320f:	83 c4 10             	add    $0x10,%esp
}
   13212:	90                   	nop
   13213:	c9                   	leave  
   13214:	c3                   	ret    

00013215 <sem_count>:

/**
 * 获取信号量的当前值
 */
int sem_count(sem_t *sem)
{
   13215:	55                   	push   %ebp
   13216:	89 e5                	mov    %esp,%ebp
   13218:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   1321b:	e8 44 f9 ff ff       	call   12b64 <irq_enter_protection>
   13220:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   13223:	8b 45 08             	mov    0x8(%ebp),%eax
   13226:	8b 00                	mov    (%eax),%eax
   13228:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(irq_state);
   1322b:	83 ec 0c             	sub    $0xc,%esp
   1322e:	ff 75 f4             	pushl  -0xc(%ebp)
   13231:	e8 46 f9 ff ff       	call   12b7c <irq_leave_protection>
   13236:	83 c4 10             	add    $0x10,%esp
    return count;
   13239:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1323c:	c9                   	leave  
   1323d:	c3                   	ret    

0001323e <bitmap_byte_count>:

/**
 * @brief 获取所需要的字节数量
 */
int bitmap_byte_count(int bit_count)
{
   1323e:	55                   	push   %ebp
   1323f:	89 e5                	mov    %esp,%ebp
    return (bit_count + 8 - 1) / 8; // 向上取整
   13241:	8b 45 08             	mov    0x8(%ebp),%eax
   13244:	83 c0 07             	add    $0x7,%eax
   13247:	8d 50 07             	lea    0x7(%eax),%edx
   1324a:	85 c0                	test   %eax,%eax
   1324c:	0f 48 c2             	cmovs  %edx,%eax
   1324f:	c1 f8 03             	sar    $0x3,%eax
}
   13252:	5d                   	pop    %ebp
   13253:	c3                   	ret    

00013254 <bitmap_init>:

/**
 * @brief 位图初始化
 */
void bitmap_init(bitmap_t *bitmap, uint8_t *bits, int count, int init_bit)
{
   13254:	55                   	push   %ebp
   13255:	89 e5                	mov    %esp,%ebp
   13257:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count = count;
   1325a:	8b 45 08             	mov    0x8(%ebp),%eax
   1325d:	8b 55 10             	mov    0x10(%ebp),%edx
   13260:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   13262:	8b 45 08             	mov    0x8(%ebp),%eax
   13265:	8b 55 0c             	mov    0xc(%ebp),%edx
   13268:	89 50 04             	mov    %edx,0x4(%eax)

    int bytes = bitmap_byte_count(bitmap->bit_count);
   1326b:	8b 45 08             	mov    0x8(%ebp),%eax
   1326e:	8b 00                	mov    (%eax),%eax
   13270:	50                   	push   %eax
   13271:	e8 c8 ff ff ff       	call   1323e <bitmap_byte_count>
   13276:	83 c4 04             	add    $0x4,%esp
   13279:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits, init_bit ? 0xFF : 0, bytes); // 将bitmap置位
   1327c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   13280:	74 07                	je     13289 <bitmap_init+0x35>
   13282:	ba ff 00 00 00       	mov    $0xff,%edx
   13287:	eb 05                	jmp    1328e <bitmap_init+0x3a>
   13289:	ba 00 00 00 00       	mov    $0x0,%edx
   1328e:	8b 45 08             	mov    0x8(%ebp),%eax
   13291:	8b 40 04             	mov    0x4(%eax),%eax
   13294:	83 ec 04             	sub    $0x4,%esp
   13297:	ff 75 f4             	pushl  -0xc(%ebp)
   1329a:	52                   	push   %edx
   1329b:	50                   	push   %eax
   1329c:	e8 a8 03 00 00       	call   13649 <kernel_memset>
   132a1:	83 c4 10             	add    $0x10,%esp
}
   132a4:	90                   	nop
   132a5:	c9                   	leave  
   132a6:	c3                   	ret    

000132a7 <bitmap_set_bit>:

/**
 * @brief 连续设置N个位
 */
void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit)
{
   132a7:	55                   	push   %ebp
   132a8:	89 e5                	mov    %esp,%ebp
   132aa:	56                   	push   %esi
   132ab:	53                   	push   %ebx
   132ac:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   132af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   132b6:	e9 a2 00 00 00       	jmp    1335d <bitmap_set_bit+0xb6>
    {
        // 可以考虑进行一定程序的优化!!
        if (bit)
   132bb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   132bf:	74 4a                	je     1330b <bitmap_set_bit+0x64>
        {
            bitmap->bits[index / 8] |= 1 << (index % 8);
   132c1:	8b 45 08             	mov    0x8(%ebp),%eax
   132c4:	8b 50 04             	mov    0x4(%eax),%edx
   132c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   132ca:	8d 48 07             	lea    0x7(%eax),%ecx
   132cd:	85 c0                	test   %eax,%eax
   132cf:	0f 48 c1             	cmovs  %ecx,%eax
   132d2:	c1 f8 03             	sar    $0x3,%eax
   132d5:	89 c3                	mov    %eax,%ebx
   132d7:	89 d8                	mov    %ebx,%eax
   132d9:	01 d0                	add    %edx,%eax
   132db:	0f b6 00             	movzbl (%eax),%eax
   132de:	89 c6                	mov    %eax,%esi
   132e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   132e3:	99                   	cltd   
   132e4:	c1 ea 1d             	shr    $0x1d,%edx
   132e7:	01 d0                	add    %edx,%eax
   132e9:	83 e0 07             	and    $0x7,%eax
   132ec:	29 d0                	sub    %edx,%eax
   132ee:	ba 01 00 00 00       	mov    $0x1,%edx
   132f3:	89 c1                	mov    %eax,%ecx
   132f5:	d3 e2                	shl    %cl,%edx
   132f7:	89 d0                	mov    %edx,%eax
   132f9:	89 f2                	mov    %esi,%edx
   132fb:	09 c2                	or     %eax,%edx
   132fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13300:	8b 40 04             	mov    0x4(%eax),%eax
   13303:	89 d9                	mov    %ebx,%ecx
   13305:	01 c8                	add    %ecx,%eax
   13307:	88 10                	mov    %dl,(%eax)
   13309:	eb 4a                	jmp    13355 <bitmap_set_bit+0xae>
        }
        else
        {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
   1330b:	8b 45 08             	mov    0x8(%ebp),%eax
   1330e:	8b 50 04             	mov    0x4(%eax),%edx
   13311:	8b 45 0c             	mov    0xc(%ebp),%eax
   13314:	8d 48 07             	lea    0x7(%eax),%ecx
   13317:	85 c0                	test   %eax,%eax
   13319:	0f 48 c1             	cmovs  %ecx,%eax
   1331c:	c1 f8 03             	sar    $0x3,%eax
   1331f:	89 c3                	mov    %eax,%ebx
   13321:	89 d8                	mov    %ebx,%eax
   13323:	01 d0                	add    %edx,%eax
   13325:	0f b6 00             	movzbl (%eax),%eax
   13328:	89 c6                	mov    %eax,%esi
   1332a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1332d:	99                   	cltd   
   1332e:	c1 ea 1d             	shr    $0x1d,%edx
   13331:	01 d0                	add    %edx,%eax
   13333:	83 e0 07             	and    $0x7,%eax
   13336:	29 d0                	sub    %edx,%eax
   13338:	ba 01 00 00 00       	mov    $0x1,%edx
   1333d:	89 c1                	mov    %eax,%ecx
   1333f:	d3 e2                	shl    %cl,%edx
   13341:	89 d0                	mov    %edx,%eax
   13343:	f7 d0                	not    %eax
   13345:	89 f2                	mov    %esi,%edx
   13347:	21 c2                	and    %eax,%edx
   13349:	8b 45 08             	mov    0x8(%ebp),%eax
   1334c:	8b 40 04             	mov    0x4(%eax),%eax
   1334f:	89 d9                	mov    %ebx,%ecx
   13351:	01 c8                	add    %ecx,%eax
   13353:	88 10                	mov    %dl,(%eax)
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   13355:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13359:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   1335d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13360:	3b 45 10             	cmp    0x10(%ebp),%eax
   13363:	7d 0e                	jge    13373 <bitmap_set_bit+0xcc>
   13365:	8b 45 08             	mov    0x8(%ebp),%eax
   13368:	8b 00                	mov    (%eax),%eax
   1336a:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1336d:	0f 8c 48 ff ff ff    	jl     132bb <bitmap_set_bit+0x14>
        }
    }
}
   13373:	90                   	nop
   13374:	83 c4 10             	add    $0x10,%esp
   13377:	5b                   	pop    %ebx
   13378:	5e                   	pop    %esi
   13379:	5d                   	pop    %ebp
   1337a:	c3                   	ret    

0001337b <bitmap_get_bit>:

/**
 * @brief 获取指定位的状态
 */
int bitmap_get_bit(bitmap_t *bitmap, int index)
{
   1337b:	55                   	push   %ebp
   1337c:	89 e5                	mov    %esp,%ebp
   1337e:	53                   	push   %ebx
    // return bitmap->bits[index / 8] & (1 << (index % 8));
    //  2023-3-9 这里应该返回0或者1
    return (bitmap->bits[index / 8] & (1 << (index % 8))) ? 1 : 0;
   1337f:	8b 45 08             	mov    0x8(%ebp),%eax
   13382:	8b 50 04             	mov    0x4(%eax),%edx
   13385:	8b 45 0c             	mov    0xc(%ebp),%eax
   13388:	8d 48 07             	lea    0x7(%eax),%ecx
   1338b:	85 c0                	test   %eax,%eax
   1338d:	0f 48 c1             	cmovs  %ecx,%eax
   13390:	c1 f8 03             	sar    $0x3,%eax
   13393:	01 d0                	add    %edx,%eax
   13395:	0f b6 00             	movzbl (%eax),%eax
   13398:	0f b6 d8             	movzbl %al,%ebx
   1339b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1339e:	99                   	cltd   
   1339f:	c1 ea 1d             	shr    $0x1d,%edx
   133a2:	01 d0                	add    %edx,%eax
   133a4:	83 e0 07             	and    $0x7,%eax
   133a7:	29 d0                	sub    %edx,%eax
   133a9:	89 c1                	mov    %eax,%ecx
   133ab:	d3 fb                	sar    %cl,%ebx
   133ad:	89 d8                	mov    %ebx,%eax
   133af:	83 e0 01             	and    $0x1,%eax
}
   133b2:	5b                   	pop    %ebx
   133b3:	5d                   	pop    %ebp
   133b4:	c3                   	ret    

000133b5 <bitmap_is_set>:

/**
 * @brief 检查指定位是否置1
 */
int bitmap_is_set(bitmap_t *bitmap, int index)
{
   133b5:	55                   	push   %ebp
   133b6:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
   133b8:	ff 75 0c             	pushl  0xc(%ebp)
   133bb:	ff 75 08             	pushl  0x8(%ebp)
   133be:	e8 b8 ff ff ff       	call   1337b <bitmap_get_bit>
   133c3:	83 c4 08             	add    $0x8,%esp
   133c6:	85 c0                	test   %eax,%eax
   133c8:	0f 95 c0             	setne  %al
   133cb:	0f b6 c0             	movzbl %al,%eax
}
   133ce:	c9                   	leave  
   133cf:	c3                   	ret    

000133d0 <bitmap_alloc_nbits>:

/**
 * @brief 连续分配若干指定比特位，返回起始索引
 */
int bitmap_alloc_nbits(bitmap_t *bitmap, int bit, int count)
{
   133d0:	55                   	push   %ebp
   133d1:	89 e5                	mov    %esp,%ebp
   133d3:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   133d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   133dd:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count)
   133e4:	e9 85 00 00 00       	jmp    1346e <bitmap_alloc_nbits+0x9e>
    {
        // 定位到第一个相同的索引处
        if (bitmap_get_bit(bitmap, search_idx) != bit)
   133e9:	ff 75 fc             	pushl  -0x4(%ebp)
   133ec:	ff 75 08             	pushl  0x8(%ebp)
   133ef:	e8 87 ff ff ff       	call   1337b <bitmap_get_bit>
   133f4:	83 c4 08             	add    $0x8,%esp
   133f7:	39 45 0c             	cmp    %eax,0xc(%ebp)
   133fa:	74 06                	je     13402 <bitmap_alloc_nbits+0x32>
        {
            // 不同，继续寻找起始的bit
            search_idx++;
   133fc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   13400:	eb 6c                	jmp    1346e <bitmap_alloc_nbits+0x9e>
        }

        // 记录起始索引
        ok_idx = search_idx;
   13402:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13405:	89 45 f8             	mov    %eax,-0x8(%ebp)

        // 继续计算下一部分
        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++)
   13408:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   1340f:	eb 27                	jmp    13438 <bitmap_alloc_nbits+0x68>
        {
            if (bitmap_get_bit(bitmap, search_idx++) != bit)
   13411:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13414:	8d 50 01             	lea    0x1(%eax),%edx
   13417:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1341a:	50                   	push   %eax
   1341b:	ff 75 08             	pushl  0x8(%ebp)
   1341e:	e8 58 ff ff ff       	call   1337b <bitmap_get_bit>
   13423:	83 c4 08             	add    $0x8,%esp
   13426:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13429:	74 09                	je     13434 <bitmap_alloc_nbits+0x64>
            {
                // 不足count个，退出，重新进行最外层的比较
                ok_idx = -1;
   1342b:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   13432:	eb 16                	jmp    1344a <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++)
   13434:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13438:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1343b:	3b 45 10             	cmp    0x10(%ebp),%eax
   1343e:	7d 0a                	jge    1344a <bitmap_alloc_nbits+0x7a>
   13440:	8b 45 08             	mov    0x8(%ebp),%eax
   13443:	8b 00                	mov    (%eax),%eax
   13445:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13448:	7c c7                	jl     13411 <bitmap_alloc_nbits+0x41>
            }
        }

        // 找到，设置各位，然后退出
        if (i >= count)
   1344a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1344d:	3b 45 10             	cmp    0x10(%ebp),%eax
   13450:	7c 1c                	jl     1346e <bitmap_alloc_nbits+0x9e>
        {
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   13452:	8b 45 0c             	mov    0xc(%ebp),%eax
   13455:	f7 d0                	not    %eax
   13457:	50                   	push   %eax
   13458:	ff 75 10             	pushl  0x10(%ebp)
   1345b:	ff 75 f8             	pushl  -0x8(%ebp)
   1345e:	ff 75 08             	pushl  0x8(%ebp)
   13461:	e8 41 fe ff ff       	call   132a7 <bitmap_set_bit>
   13466:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   13469:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1346c:	eb 13                	jmp    13481 <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count)
   1346e:	8b 45 08             	mov    0x8(%ebp),%eax
   13471:	8b 00                	mov    (%eax),%eax
   13473:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13476:	0f 8c 6d ff ff ff    	jl     133e9 <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   1347c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13481:	c9                   	leave  
   13482:	c3                   	ret    

00013483 <hlt>:
{
   13483:	55                   	push   %ebp
   13484:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   13486:	f4                   	hlt    
}
   13487:	90                   	nop
   13488:	5d                   	pop    %ebp
   13489:	c3                   	ret    

0001348a <kernel_strcpy>:
#include "tools/klib.h"
#include "comm/types.h"
#include "comm/cpu_instr.h"

void kernel_strcpy(char *dest, const char *src)
{
   1348a:	55                   	push   %ebp
   1348b:	89 e5                	mov    %esp,%ebp
    if (!dest || !src)
   1348d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13491:	74 3b                	je     134ce <kernel_strcpy+0x44>
   13493:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13497:	74 35                	je     134ce <kernel_strcpy+0x44>
    {
        return;
    }

    while (*dest && *src)
   13499:	eb 17                	jmp    134b2 <kernel_strcpy+0x28>
    {
        *dest++ = *src++;
   1349b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1349e:	8d 42 01             	lea    0x1(%edx),%eax
   134a1:	89 45 0c             	mov    %eax,0xc(%ebp)
   134a4:	8b 45 08             	mov    0x8(%ebp),%eax
   134a7:	8d 48 01             	lea    0x1(%eax),%ecx
   134aa:	89 4d 08             	mov    %ecx,0x8(%ebp)
   134ad:	0f b6 12             	movzbl (%edx),%edx
   134b0:	88 10                	mov    %dl,(%eax)
    while (*dest && *src)
   134b2:	8b 45 08             	mov    0x8(%ebp),%eax
   134b5:	0f b6 00             	movzbl (%eax),%eax
   134b8:	84 c0                	test   %al,%al
   134ba:	74 0a                	je     134c6 <kernel_strcpy+0x3c>
   134bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   134bf:	0f b6 00             	movzbl (%eax),%eax
   134c2:	84 c0                	test   %al,%al
   134c4:	75 d5                	jne    1349b <kernel_strcpy+0x11>
    }
    *dest = '\0';
   134c6:	8b 45 08             	mov    0x8(%ebp),%eax
   134c9:	c6 00 00             	movb   $0x0,(%eax)
   134cc:	eb 01                	jmp    134cf <kernel_strcpy+0x45>
        return;
   134ce:	90                   	nop
}
   134cf:	5d                   	pop    %ebp
   134d0:	c3                   	ret    

000134d1 <kernel_strncpy>:

void kernel_strncpy(char *dest, const char *src, int size)
{
   134d1:	55                   	push   %ebp
   134d2:	89 e5                	mov    %esp,%ebp
   134d4:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   134d7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   134db:	74 61                	je     1353e <kernel_strncpy+0x6d>
   134dd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   134e1:	74 5b                	je     1353e <kernel_strncpy+0x6d>
   134e3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   134e7:	74 55                	je     1353e <kernel_strncpy+0x6d>
    {
        return;
    }

    char *d = dest;
   134e9:	8b 45 08             	mov    0x8(%ebp),%eax
   134ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   134ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   134f2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while ((size-- > 0) && (*s))
   134f5:	eb 17                	jmp    1350e <kernel_strncpy+0x3d>
    {
        *d++ = *s++;
   134f7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   134fa:	8d 42 01             	lea    0x1(%edx),%eax
   134fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
   13500:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13503:	8d 48 01             	lea    0x1(%eax),%ecx
   13506:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   13509:	0f b6 12             	movzbl (%edx),%edx
   1350c:	88 10                	mov    %dl,(%eax)
    while ((size-- > 0) && (*s))
   1350e:	8b 45 10             	mov    0x10(%ebp),%eax
   13511:	8d 50 ff             	lea    -0x1(%eax),%edx
   13514:	89 55 10             	mov    %edx,0x10(%ebp)
   13517:	85 c0                	test   %eax,%eax
   13519:	7e 0a                	jle    13525 <kernel_strncpy+0x54>
   1351b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1351e:	0f b6 00             	movzbl (%eax),%eax
   13521:	84 c0                	test   %al,%al
   13523:	75 d2                	jne    134f7 <kernel_strncpy+0x26>
    }
    if (size == 0)
   13525:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   13529:	75 0b                	jne    13536 <kernel_strncpy+0x65>
    {
        *(d - 1) = '\0';
   1352b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1352e:	83 e8 01             	sub    $0x1,%eax
   13531:	c6 00 00             	movb   $0x0,(%eax)
   13534:	eb 09                	jmp    1353f <kernel_strncpy+0x6e>
    }
    else
    {
        *d = '\0';
   13536:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13539:	c6 00 00             	movb   $0x0,(%eax)
   1353c:	eb 01                	jmp    1353f <kernel_strncpy+0x6e>
        return;
   1353e:	90                   	nop
    }
}
   1353f:	c9                   	leave  
   13540:	c3                   	ret    

00013541 <kernel_strncmp>:

int kernel_strncmp(const char *s1, const char *s2, int size)
{
   13541:	55                   	push   %ebp
   13542:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2)
   13544:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13548:	74 06                	je     13550 <kernel_strncmp+0xf>
   1354a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1354e:	75 13                	jne    13563 <kernel_strncmp+0x22>
    {
        return -1;
   13550:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13555:	eb 66                	jmp    135bd <kernel_strncmp+0x7c>
    }

    while (*s1 && *s2 && (*s1 == *s2) && size)
    {
        s1++;
   13557:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   1355b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        size--;
   1355f:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    while (*s1 && *s2 && (*s1 == *s2) && size)
   13563:	8b 45 08             	mov    0x8(%ebp),%eax
   13566:	0f b6 00             	movzbl (%eax),%eax
   13569:	84 c0                	test   %al,%al
   1356b:	74 20                	je     1358d <kernel_strncmp+0x4c>
   1356d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13570:	0f b6 00             	movzbl (%eax),%eax
   13573:	84 c0                	test   %al,%al
   13575:	74 16                	je     1358d <kernel_strncmp+0x4c>
   13577:	8b 45 08             	mov    0x8(%ebp),%eax
   1357a:	0f b6 10             	movzbl (%eax),%edx
   1357d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13580:	0f b6 00             	movzbl (%eax),%eax
   13583:	38 c2                	cmp    %al,%dl
   13585:	75 06                	jne    1358d <kernel_strncmp+0x4c>
   13587:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1358b:	75 ca                	jne    13557 <kernel_strncmp+0x16>
    }
    // 相等返回0
    // s1="abc",s2="abcdef" 也属于相等
    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   1358d:	8b 45 08             	mov    0x8(%ebp),%eax
   13590:	0f b6 00             	movzbl (%eax),%eax
   13593:	84 c0                	test   %al,%al
   13595:	74 21                	je     135b8 <kernel_strncmp+0x77>
   13597:	8b 45 0c             	mov    0xc(%ebp),%eax
   1359a:	0f b6 00             	movzbl (%eax),%eax
   1359d:	84 c0                	test   %al,%al
   1359f:	74 17                	je     135b8 <kernel_strncmp+0x77>
   135a1:	8b 45 08             	mov    0x8(%ebp),%eax
   135a4:	0f b6 10             	movzbl (%eax),%edx
   135a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   135aa:	0f b6 00             	movzbl (%eax),%eax
   135ad:	38 c2                	cmp    %al,%dl
   135af:	74 07                	je     135b8 <kernel_strncmp+0x77>
   135b1:	b8 01 00 00 00       	mov    $0x1,%eax
   135b6:	eb 05                	jmp    135bd <kernel_strncmp+0x7c>
   135b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   135bd:	5d                   	pop    %ebp
   135be:	c3                   	ret    

000135bf <kernel_strlen>:

int kernel_strlen(const char *str)
{
   135bf:	55                   	push   %ebp
   135c0:	89 e5                	mov    %esp,%ebp
   135c2:	83 ec 10             	sub    $0x10,%esp
    if (str == (const char *)0)
   135c5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   135c9:	75 07                	jne    135d2 <kernel_strlen+0x13>
    {
        return 0;
   135cb:	b8 00 00 00 00       	mov    $0x0,%eax
   135d0:	eb 26                	jmp    135f8 <kernel_strlen+0x39>
    }

    const char *c = str;
   135d2:	8b 45 08             	mov    0x8(%ebp),%eax
   135d5:	89 45 fc             	mov    %eax,-0x4(%ebp)

    int len = 0;
   135d8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (*c++)
   135df:	eb 04                	jmp    135e5 <kernel_strlen+0x26>
    {
        len++;
   135e1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (*c++)
   135e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   135e8:	8d 50 01             	lea    0x1(%eax),%edx
   135eb:	89 55 fc             	mov    %edx,-0x4(%ebp)
   135ee:	0f b6 00             	movzbl (%eax),%eax
   135f1:	84 c0                	test   %al,%al
   135f3:	75 ec                	jne    135e1 <kernel_strlen+0x22>
    }

    return len;
   135f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   135f8:	c9                   	leave  
   135f9:	c3                   	ret    

000135fa <kernel_memcpy>:

void kernel_memcpy(void *dest, void *src, int size)
{
   135fa:	55                   	push   %ebp
   135fb:	89 e5                	mov    %esp,%ebp
   135fd:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   13600:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13604:	74 40                	je     13646 <kernel_memcpy+0x4c>
   13606:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1360a:	74 3a                	je     13646 <kernel_memcpy+0x4c>
   1360c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   13610:	74 34                	je     13646 <kernel_memcpy+0x4c>
    {
        return;
    }

    uint8_t *s = (uint8_t *)src;
   13612:	8b 45 0c             	mov    0xc(%ebp),%eax
   13615:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *d = (uint8_t *)dest;
   13618:	8b 45 08             	mov    0x8(%ebp),%eax
   1361b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   1361e:	eb 17                	jmp    13637 <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   13620:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13623:	8d 42 01             	lea    0x1(%edx),%eax
   13626:	89 45 fc             	mov    %eax,-0x4(%ebp)
   13629:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1362c:	8d 48 01             	lea    0x1(%eax),%ecx
   1362f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   13632:	0f b6 12             	movzbl (%edx),%edx
   13635:	88 10                	mov    %dl,(%eax)
    while (size--)
   13637:	8b 45 10             	mov    0x10(%ebp),%eax
   1363a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1363d:	89 55 10             	mov    %edx,0x10(%ebp)
   13640:	85 c0                	test   %eax,%eax
   13642:	75 dc                	jne    13620 <kernel_memcpy+0x26>
   13644:	eb 01                	jmp    13647 <kernel_memcpy+0x4d>
        return;
   13646:	90                   	nop
    }
}
   13647:	c9                   	leave  
   13648:	c3                   	ret    

00013649 <kernel_memset>:

// 内存逐字节设置v
void kernel_memset(void *dest, uint8_t v, int size)
{
   13649:	55                   	push   %ebp
   1364a:	89 e5                	mov    %esp,%ebp
   1364c:	83 ec 14             	sub    $0x14,%esp
   1364f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13652:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (!dest || !size)
   13655:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13659:	74 2c                	je     13687 <kernel_memset+0x3e>
   1365b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1365f:	74 26                	je     13687 <kernel_memset+0x3e>
    {
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   13661:	8b 45 08             	mov    0x8(%ebp),%eax
   13664:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (size--)
   13667:	eb 0f                	jmp    13678 <kernel_memset+0x2f>
    {
        *d++ = v;
   13669:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1366c:	8d 50 01             	lea    0x1(%eax),%edx
   1366f:	89 55 fc             	mov    %edx,-0x4(%ebp)
   13672:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   13676:	88 10                	mov    %dl,(%eax)
    while (size--)
   13678:	8b 45 10             	mov    0x10(%ebp),%eax
   1367b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1367e:	89 55 10             	mov    %edx,0x10(%ebp)
   13681:	85 c0                	test   %eax,%eax
   13683:	75 e4                	jne    13669 <kernel_memset+0x20>
   13685:	eb 01                	jmp    13688 <kernel_memset+0x3f>
        return;
   13687:	90                   	nop
    }
}
   13688:	c9                   	leave  
   13689:	c3                   	ret    

0001368a <kernel_memcmp>:

int kernel_memcmp(void *d1, void *d2, int size)
{
   1368a:	55                   	push   %ebp
   1368b:	89 e5                	mov    %esp,%ebp
   1368d:	83 ec 10             	sub    $0x10,%esp
    if (!d1 || !d2)
   13690:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13694:	74 06                	je     1369c <kernel_memcmp+0x12>
   13696:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1369a:	75 07                	jne    136a3 <kernel_memcmp+0x19>
    {
        return 1;
   1369c:	b8 01 00 00 00       	mov    $0x1,%eax
   136a1:	eb 43                	jmp    136e6 <kernel_memcmp+0x5c>
    }

    uint8_t *p_d1 = (uint8_t *)d1;
   136a3:	8b 45 08             	mov    0x8(%ebp),%eax
   136a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2 = (uint8_t *)d2;
   136a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   136ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   136af:	eb 23                	jmp    136d4 <kernel_memcmp+0x4a>
    {
        if (*p_d1++ != *p_d2++)
   136b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   136b4:	8d 50 01             	lea    0x1(%eax),%edx
   136b7:	89 55 fc             	mov    %edx,-0x4(%ebp)
   136ba:	0f b6 08             	movzbl (%eax),%ecx
   136bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   136c0:	8d 50 01             	lea    0x1(%eax),%edx
   136c3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   136c6:	0f b6 00             	movzbl (%eax),%eax
   136c9:	38 c1                	cmp    %al,%cl
   136cb:	74 07                	je     136d4 <kernel_memcmp+0x4a>
        {
            return 1;
   136cd:	b8 01 00 00 00       	mov    $0x1,%eax
   136d2:	eb 12                	jmp    136e6 <kernel_memcmp+0x5c>
    while (size--)
   136d4:	8b 45 10             	mov    0x10(%ebp),%eax
   136d7:	8d 50 ff             	lea    -0x1(%eax),%edx
   136da:	89 55 10             	mov    %edx,0x10(%ebp)
   136dd:	85 c0                	test   %eax,%eax
   136df:	75 d0                	jne    136b1 <kernel_memcmp+0x27>
        }
    }

    // 内存一样返回0
    return 0;
   136e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   136e6:	c9                   	leave  
   136e7:	c3                   	ret    

000136e8 <kernel_itoa>:

void kernel_itoa(char *buf, int num, int base)
{
   136e8:	55                   	push   %ebp
   136e9:	89 e5                	mov    %esp,%ebp
   136eb:	53                   	push   %ebx
   136ec:	83 ec 20             	sub    $0x20,%esp
    // 转换字符索引[-15, -14, ...-1, 0, 1, ...., 14, 15]
    static const char *num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char *p = buf;
   136ef:	8b 45 08             	mov    0x8(%ebp),%eax
   136f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   136f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   136f8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 仅支持部分进制
    if ((base != 2) && (base != 8) && (base != 10) && (base != 16))
   136fb:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   136ff:	74 1d                	je     1371e <kernel_itoa+0x36>
   13701:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   13705:	74 17                	je     1371e <kernel_itoa+0x36>
   13707:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1370b:	74 11                	je     1371e <kernel_itoa+0x36>
   1370d:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   13711:	74 0b                	je     1371e <kernel_itoa+0x36>
    {
        *p = '\0';
   13713:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13716:	c6 00 00             	movb   $0x0,(%eax)
        return;
   13719:	e9 03 01 00 00       	jmp    13821 <kernel_itoa+0x139>
    }

    // 只支持十进制负数
    int signed_num = 0;
   1371e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10))
   13725:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13729:	79 19                	jns    13744 <kernel_itoa+0x5c>
   1372b:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1372f:	75 13                	jne    13744 <kernel_itoa+0x5c>
    {
        *p++ = '-';
   13731:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13734:	8d 50 01             	lea    0x1(%eax),%edx
   13737:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1373a:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   1373d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num)
   13744:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13748:	74 3b                	je     13785 <kernel_itoa+0x9d>
    {
        do
        {
            char ch = num2ch[num % base + 15];
   1374a:	8b 0d 40 50 01 00    	mov    0x15040,%ecx
   13750:	8b 45 0c             	mov    0xc(%ebp),%eax
   13753:	99                   	cltd   
   13754:	f7 7d 10             	idivl  0x10(%ebp)
   13757:	89 d0                	mov    %edx,%eax
   13759:	83 c0 0f             	add    $0xf,%eax
   1375c:	01 c8                	add    %ecx,%eax
   1375e:	0f b6 00             	movzbl (%eax),%eax
   13761:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   13764:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13767:	8d 50 01             	lea    0x1(%eax),%edx
   1376a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1376d:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   13771:	88 10                	mov    %dl,(%eax)
            num /= base;
   13773:	8b 45 0c             	mov    0xc(%ebp),%eax
   13776:	99                   	cltd   
   13777:	f7 7d 10             	idivl  0x10(%ebp)
   1377a:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   1377d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13781:	75 c7                	jne    1374a <kernel_itoa+0x62>
   13783:	eb 4b                	jmp    137d0 <kernel_itoa+0xe8>
    }
    else
    {
        uint32_t u_num = (uint32_t)num;
   13785:	8b 45 0c             	mov    0xc(%ebp),%eax
   13788:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do
        {
            char ch = num2ch[u_num % base + 15];
   1378b:	8b 0d 40 50 01 00    	mov    0x15040,%ecx
   13791:	8b 5d 10             	mov    0x10(%ebp),%ebx
   13794:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13797:	ba 00 00 00 00       	mov    $0x0,%edx
   1379c:	f7 f3                	div    %ebx
   1379e:	89 d0                	mov    %edx,%eax
   137a0:	83 c0 0f             	add    $0xf,%eax
   137a3:	01 c8                	add    %ecx,%eax
   137a5:	0f b6 00             	movzbl (%eax),%eax
   137a8:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   137ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
   137ae:	8d 50 01             	lea    0x1(%eax),%edx
   137b1:	89 55 f8             	mov    %edx,-0x8(%ebp)
   137b4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   137b8:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   137ba:	8b 5d 10             	mov    0x10(%ebp),%ebx
   137bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137c0:	ba 00 00 00 00       	mov    $0x0,%edx
   137c5:	f7 f3                	div    %ebx
   137c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   137ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   137ce:	75 bb                	jne    1378b <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   137d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   137d3:	8d 50 ff             	lea    -0x1(%eax),%edx
   137d6:	89 55 f8             	mov    %edx,-0x8(%ebp)
   137d9:	c6 00 00             	movb   $0x0,(%eax)

    // 将转换结果逆序，生成最终的结果
    char *start = (!signed_num) ? buf : buf + 1;
   137dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   137e0:	74 08                	je     137ea <kernel_itoa+0x102>
   137e2:	8b 45 08             	mov    0x8(%ebp),%eax
   137e5:	83 c0 01             	add    $0x1,%eax
   137e8:	eb 03                	jmp    137ed <kernel_itoa+0x105>
   137ea:	8b 45 08             	mov    0x8(%ebp),%eax
   137ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p)
   137f0:	eb 27                	jmp    13819 <kernel_itoa+0x131>
    {
        char ch = *start;
   137f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   137f5:	0f b6 00             	movzbl (%eax),%eax
   137f8:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   137fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   137fe:	0f b6 10             	movzbl (%eax),%edx
   13801:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13804:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   13806:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13809:	8d 50 ff             	lea    -0x1(%eax),%edx
   1380c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1380f:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   13813:	88 10                	mov    %dl,(%eax)
        start++;
   13815:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p)
   13819:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1381c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1381f:	72 d1                	jb     137f2 <kernel_itoa+0x10a>
    }
}
   13821:	83 c4 20             	add    $0x20,%esp
   13824:	5b                   	pop    %ebx
   13825:	5d                   	pop    %ebp
   13826:	c3                   	ret    

00013827 <kernel_vsprintf>:
// buf 为最终显示的目标
// fmt 为整个字符串
// args 为va_list 可变变量
void kernel_vsprintf(char *buf, const char *fmt, va_list args)
{
   13827:	55                   	push   %ebp
   13828:	89 e5                	mov    %esp,%ebp
   1382a:	83 ec 20             	sub    $0x20,%esp
    enum
    {
        NORMAL,
        READ_FMT
    } state = NORMAL;
   1382d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char ch;
    char *curr = buf;
   13834:	8b 45 08             	mov    0x8(%ebp),%eax
   13837:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while ((ch = *fmt++))
   1383a:	e9 17 01 00 00       	jmp    13956 <kernel_vsprintf+0x12f>
    {
        switch (state)
   1383f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13842:	85 c0                	test   %eax,%eax
   13844:	74 0a                	je     13850 <kernel_vsprintf+0x29>
   13846:	83 f8 01             	cmp    $0x1,%eax
   13849:	74 2b                	je     13876 <kernel_vsprintf+0x4f>
   1384b:	e9 06 01 00 00       	jmp    13956 <kernel_vsprintf+0x12f>
        {
        // 普通字符
        case NORMAL:
            if (ch == '%')
   13850:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   13854:	75 0c                	jne    13862 <kernel_vsprintf+0x3b>
            {
                state = READ_FMT;
   13856:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   1385d:	e9 f4 00 00 00       	jmp    13956 <kernel_vsprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   13862:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13865:	8d 50 01             	lea    0x1(%eax),%edx
   13868:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1386b:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   1386f:	88 10                	mov    %dl,(%eax)
            }
            break;
   13871:	e9 e0 00 00 00       	jmp    13956 <kernel_vsprintf+0x12f>
        // 格式化控制字符，只支持部分
        case READ_FMT:
            if (ch == 'd')
   13876:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   1387a:	75 31                	jne    138ad <kernel_vsprintf+0x86>
            {
                int num = va_arg(args, int);
   1387c:	8b 45 10             	mov    0x10(%ebp),%eax
   1387f:	8d 50 04             	lea    0x4(%eax),%edx
   13882:	89 55 10             	mov    %edx,0x10(%ebp)
   13885:	8b 00                	mov    (%eax),%eax
   13887:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr, num, 10);
   1388a:	6a 0a                	push   $0xa
   1388c:	ff 75 e4             	pushl  -0x1c(%ebp)
   1388f:	ff 75 f8             	pushl  -0x8(%ebp)
   13892:	e8 51 fe ff ff       	call   136e8 <kernel_itoa>
   13897:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr); // 移动到下一个
   1389a:	ff 75 f8             	pushl  -0x8(%ebp)
   1389d:	e8 1d fd ff ff       	call   135bf <kernel_strlen>
   138a2:	83 c4 04             	add    $0x4,%esp
   138a5:	01 45 f8             	add    %eax,-0x8(%ebp)
   138a8:	e9 a1 00 00 00       	jmp    1394e <kernel_vsprintf+0x127>
            }
            else if (ch == 'x')
   138ad:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   138b1:	75 2e                	jne    138e1 <kernel_vsprintf+0xba>
            {
                int num = va_arg(args, int);
   138b3:	8b 45 10             	mov    0x10(%ebp),%eax
   138b6:	8d 50 04             	lea    0x4(%eax),%edx
   138b9:	89 55 10             	mov    %edx,0x10(%ebp)
   138bc:	8b 00                	mov    (%eax),%eax
   138be:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr, num, 16);
   138c1:	6a 10                	push   $0x10
   138c3:	ff 75 e8             	pushl  -0x18(%ebp)
   138c6:	ff 75 f8             	pushl  -0x8(%ebp)
   138c9:	e8 1a fe ff ff       	call   136e8 <kernel_itoa>
   138ce:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   138d1:	ff 75 f8             	pushl  -0x8(%ebp)
   138d4:	e8 e6 fc ff ff       	call   135bf <kernel_strlen>
   138d9:	83 c4 04             	add    $0x4,%esp
   138dc:	01 45 f8             	add    %eax,-0x8(%ebp)
   138df:	eb 6d                	jmp    1394e <kernel_vsprintf+0x127>
            }
            else if (ch == 'c')
   138e1:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   138e5:	75 1f                	jne    13906 <kernel_vsprintf+0xdf>
            {
                char c = va_arg(args, int);
   138e7:	8b 45 10             	mov    0x10(%ebp),%eax
   138ea:	8d 50 04             	lea    0x4(%eax),%edx
   138ed:	89 55 10             	mov    %edx,0x10(%ebp)
   138f0:	8b 00                	mov    (%eax),%eax
   138f2:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = c;
   138f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   138f8:	8d 50 01             	lea    0x1(%eax),%edx
   138fb:	89 55 f8             	mov    %edx,-0x8(%ebp)
   138fe:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   13902:	88 10                	mov    %dl,(%eax)
   13904:	eb 48                	jmp    1394e <kernel_vsprintf+0x127>
            }
            else if (ch == 's')
   13906:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   1390a:	75 42                	jne    1394e <kernel_vsprintf+0x127>
            {
                const char *str = va_arg(args, char *);
   1390c:	8b 45 10             	mov    0x10(%ebp),%eax
   1390f:	8d 50 04             	lea    0x4(%eax),%edx
   13912:	89 55 10             	mov    %edx,0x10(%ebp)
   13915:	8b 00                	mov    (%eax),%eax
   13917:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   1391a:	ff 75 f4             	pushl  -0xc(%ebp)
   1391d:	e8 9d fc ff ff       	call   135bf <kernel_strlen>
   13922:	83 c4 04             	add    $0x4,%esp
   13925:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while (len--)
   13928:	eb 17                	jmp    13941 <kernel_vsprintf+0x11a>
                {
                    *curr++ = *str++;
   1392a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1392d:	8d 42 01             	lea    0x1(%edx),%eax
   13930:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13933:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13936:	8d 48 01             	lea    0x1(%eax),%ecx
   13939:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   1393c:	0f b6 12             	movzbl (%edx),%edx
   1393f:	88 10                	mov    %dl,(%eax)
                while (len--)
   13941:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13944:	8d 50 ff             	lea    -0x1(%eax),%edx
   13947:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1394a:	85 c0                	test   %eax,%eax
   1394c:	75 dc                	jne    1392a <kernel_vsprintf+0x103>
                }
            }
            state = NORMAL;
   1394e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   13955:	90                   	nop
    while ((ch = *fmt++))
   13956:	8b 45 0c             	mov    0xc(%ebp),%eax
   13959:	8d 50 01             	lea    0x1(%eax),%edx
   1395c:	89 55 0c             	mov    %edx,0xc(%ebp)
   1395f:	0f b6 00             	movzbl (%eax),%eax
   13962:	88 45 ef             	mov    %al,-0x11(%ebp)
   13965:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   13969:	0f 85 d0 fe ff ff    	jne    1383f <kernel_vsprintf+0x18>
        }
    }
}
   1396f:	90                   	nop
   13970:	c9                   	leave  
   13971:	c3                   	ret    

00013972 <panic>:

void panic(const char *file, int line, const char *func, const char *cond)
{
   13972:	55                   	push   %ebp
   13973:	89 e5                	mov    %esp,%ebp
   13975:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed! %s", cond);
   13978:	83 ec 08             	sub    $0x8,%esp
   1397b:	ff 75 14             	pushl  0x14(%ebp)
   1397e:	68 9c 48 01 00       	push   $0x1489c
   13983:	e8 40 03 00 00       	call   13cc8 <log_printf>
   13988:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline %d\nfunc: %s\n", file, line, func);
   1398b:	ff 75 10             	pushl  0x10(%ebp)
   1398e:	ff 75 0c             	pushl  0xc(%ebp)
   13991:	ff 75 08             	pushl  0x8(%ebp)
   13994:	68 ae 48 01 00       	push   $0x148ae
   13999:	e8 2a 03 00 00       	call   13cc8 <log_printf>
   1399e:	83 c4 10             	add    $0x10,%esp

    for (;;)
    {
        hlt();
   139a1:	e8 dd fa ff ff       	call   13483 <hlt>
   139a6:	eb f9                	jmp    139a1 <panic+0x2f>

000139a8 <get_file_name>:

/**
 * @brief 从路径中解释文件名
 */
char *get_file_name(char *name)
{
   139a8:	55                   	push   %ebp
   139a9:	89 e5                	mov    %esp,%ebp
   139ab:	83 ec 10             	sub    $0x10,%esp
    char *s = name;
   139ae:	8b 45 08             	mov    0x8(%ebp),%eax
   139b1:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 定位到结束符
    while (*s != '\0')
   139b4:	eb 04                	jmp    139ba <get_file_name+0x12>
    {
        s++;
   139b6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (*s != '\0')
   139ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139bd:	0f b6 00             	movzbl (%eax),%eax
   139c0:	84 c0                	test   %al,%al
   139c2:	75 f2                	jne    139b6 <get_file_name+0xe>
    }

    // 反向搜索，直到找到反斜杆或者到文件开头
    while ((*s != '\\') && (*s != '/') && (s >= name))
   139c4:	eb 04                	jmp    139ca <get_file_name+0x22>
    {
        s--;
   139c6:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while ((*s != '\\') && (*s != '/') && (s >= name))
   139ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139cd:	0f b6 00             	movzbl (%eax),%eax
   139d0:	3c 5c                	cmp    $0x5c,%al
   139d2:	74 12                	je     139e6 <get_file_name+0x3e>
   139d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139d7:	0f b6 00             	movzbl (%eax),%eax
   139da:	3c 2f                	cmp    $0x2f,%al
   139dc:	74 08                	je     139e6 <get_file_name+0x3e>
   139de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139e1:	3b 45 08             	cmp    0x8(%ebp),%eax
   139e4:	73 e0                	jae    139c6 <get_file_name+0x1e>
    }
    return s + 1;
   139e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139e9:	83 c0 01             	add    $0x1,%eax
}
   139ec:	c9                   	leave  
   139ed:	c3                   	ret    

000139ee <strings_count>:

/**
 * @brief 计算字符串的数量
 */
int strings_count(char **start)
{
   139ee:	55                   	push   %ebp
   139ef:	89 e5                	mov    %esp,%ebp
   139f1:	83 ec 10             	sub    $0x10,%esp
    int count = 0;
   139f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if (start)
   139fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   139ff:	74 15                	je     13a16 <strings_count+0x28>
    {
        while (*start++)
   13a01:	eb 04                	jmp    13a07 <strings_count+0x19>
        {
            count++;
   13a03:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while (*start++)
   13a07:	8b 45 08             	mov    0x8(%ebp),%eax
   13a0a:	8d 50 04             	lea    0x4(%eax),%edx
   13a0d:	89 55 08             	mov    %edx,0x8(%ebp)
   13a10:	8b 00                	mov    (%eax),%eax
   13a12:	85 c0                	test   %eax,%eax
   13a14:	75 ed                	jne    13a03 <strings_count+0x15>
        }
    }
    return count;
   13a16:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a19:	c9                   	leave  
   13a1a:	c3                   	ret    

00013a1b <list_is_empty>:
{
   13a1b:	55                   	push   %ebp
   13a1c:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   13a1e:	8b 45 08             	mov    0x8(%ebp),%eax
   13a21:	8b 40 08             	mov    0x8(%eax),%eax
   13a24:	85 c0                	test   %eax,%eax
   13a26:	0f 94 c0             	sete   %al
   13a29:	0f b6 c0             	movzbl %al,%eax
}
   13a2c:	5d                   	pop    %ebp
   13a2d:	c3                   	ret    

00013a2e <list_init>:
/**
 * 初始化链表
 * @param list 待初始化的链表
 */
void list_init(list_t *list)
{
   13a2e:	55                   	push   %ebp
   13a2f:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   13a31:	8b 45 08             	mov    0x8(%ebp),%eax
   13a34:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   13a3b:	8b 45 08             	mov    0x8(%ebp),%eax
   13a3e:	8b 50 04             	mov    0x4(%eax),%edx
   13a41:	8b 45 08             	mov    0x8(%ebp),%eax
   13a44:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   13a46:	8b 45 08             	mov    0x8(%ebp),%eax
   13a49:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   13a50:	90                   	nop
   13a51:	5d                   	pop    %ebp
   13a52:	c3                   	ret    

00013a53 <list_insert_first>:
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node)
{
   13a53:	55                   	push   %ebp
   13a54:	89 e5                	mov    %esp,%ebp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
   13a56:	8b 45 08             	mov    0x8(%ebp),%eax
   13a59:	8b 10                	mov    (%eax),%edx
   13a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   13a5e:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   13a61:	8b 45 0c             	mov    0xc(%ebp),%eax
   13a64:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list))
   13a6a:	ff 75 08             	pushl  0x8(%ebp)
   13a6d:	e8 a9 ff ff ff       	call   13a1b <list_is_empty>
   13a72:	83 c4 04             	add    $0x4,%esp
   13a75:	85 c0                	test   %eax,%eax
   13a77:	74 15                	je     13a8e <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   13a79:	8b 45 08             	mov    0x8(%ebp),%eax
   13a7c:	8b 55 0c             	mov    0xc(%ebp),%edx
   13a7f:	89 10                	mov    %edx,(%eax)
   13a81:	8b 45 08             	mov    0x8(%ebp),%eax
   13a84:	8b 10                	mov    (%eax),%edx
   13a86:	8b 45 08             	mov    0x8(%ebp),%eax
   13a89:	89 50 04             	mov    %edx,0x4(%eax)
   13a8c:	eb 12                	jmp    13aa0 <list_insert_first+0x4d>
    }
    else
    {
        // 否则，设置好原本第一个结点的pre
        list->first->pre = node;
   13a8e:	8b 45 08             	mov    0x8(%ebp),%eax
   13a91:	8b 00                	mov    (%eax),%eax
   13a93:	8b 55 0c             	mov    0xc(%ebp),%edx
   13a96:	89 10                	mov    %edx,(%eax)

        // 调整first指向
        list->first = node;
   13a98:	8b 45 08             	mov    0x8(%ebp),%eax
   13a9b:	8b 55 0c             	mov    0xc(%ebp),%edx
   13a9e:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   13aa0:	8b 45 08             	mov    0x8(%ebp),%eax
   13aa3:	8b 40 08             	mov    0x8(%eax),%eax
   13aa6:	8d 50 01             	lea    0x1(%eax),%edx
   13aa9:	8b 45 08             	mov    0x8(%ebp),%eax
   13aac:	89 50 08             	mov    %edx,0x8(%eax)
}
   13aaf:	90                   	nop
   13ab0:	c9                   	leave  
   13ab1:	c3                   	ret    

00013ab2 <list_insert_last>:
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node)
{
   13ab2:	55                   	push   %ebp
   13ab3:	89 e5                	mov    %esp,%ebp
    // 设置好结点本身
    node->pre = list->last;
   13ab5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ab8:	8b 50 04             	mov    0x4(%eax),%edx
   13abb:	8b 45 0c             	mov    0xc(%ebp),%eax
   13abe:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t *)0;
   13ac0:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ac3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list))
   13aca:	ff 75 08             	pushl  0x8(%ebp)
   13acd:	e8 49 ff ff ff       	call   13a1b <list_is_empty>
   13ad2:	83 c4 04             	add    $0x4,%esp
   13ad5:	85 c0                	test   %eax,%eax
   13ad7:	74 16                	je     13aef <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   13ad9:	8b 45 08             	mov    0x8(%ebp),%eax
   13adc:	8b 55 0c             	mov    0xc(%ebp),%edx
   13adf:	89 50 04             	mov    %edx,0x4(%eax)
   13ae2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ae5:	8b 50 04             	mov    0x4(%eax),%edx
   13ae8:	8b 45 08             	mov    0x8(%ebp),%eax
   13aeb:	89 10                	mov    %edx,(%eax)
   13aed:	eb 15                	jmp    13b04 <list_insert_last+0x52>
    }
    else
    {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
   13aef:	8b 45 08             	mov    0x8(%ebp),%eax
   13af2:	8b 40 04             	mov    0x4(%eax),%eax
   13af5:	8b 55 0c             	mov    0xc(%ebp),%edx
   13af8:	89 50 04             	mov    %edx,0x4(%eax)

        // node变成了新的后继结点
        list->last = node;
   13afb:	8b 45 08             	mov    0x8(%ebp),%eax
   13afe:	8b 55 0c             	mov    0xc(%ebp),%edx
   13b01:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   13b04:	8b 45 08             	mov    0x8(%ebp),%eax
   13b07:	8b 40 08             	mov    0x8(%eax),%eax
   13b0a:	8d 50 01             	lea    0x1(%eax),%edx
   13b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   13b10:	89 50 08             	mov    %edx,0x8(%eax)
}
   13b13:	90                   	nop
   13b14:	c9                   	leave  
   13b15:	c3                   	ret    

00013b16 <list_remove_first>:
 * 移除指定链表的头部
 * @param list 操作的链表
 * @return 链表的第一个结点
 */
list_node_t *list_remove_first(list_t *list)
{
   13b16:	55                   	push   %ebp
   13b17:	89 e5                	mov    %esp,%ebp
   13b19:	83 ec 10             	sub    $0x10,%esp
    // 表项为空，返回空
    if (list_is_empty(list))
   13b1c:	ff 75 08             	pushl  0x8(%ebp)
   13b1f:	e8 f7 fe ff ff       	call   13a1b <list_is_empty>
   13b24:	83 c4 04             	add    $0x4,%esp
   13b27:	85 c0                	test   %eax,%eax
   13b29:	74 07                	je     13b32 <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   13b2b:	b8 00 00 00 00       	mov    $0x0,%eax
   13b30:	eb 5a                	jmp    13b8c <list_remove_first+0x76>
    }

    // 取第一个结点
    list_node_t *remove_node = list->first;
   13b32:	8b 45 08             	mov    0x8(%ebp),%eax
   13b35:	8b 00                	mov    (%eax),%eax
   13b37:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 将first往表尾移1个，跳过刚才移过的那个，如果没有后继，则first=0
    list->first = remove_node->next;
   13b3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13b3d:	8b 50 04             	mov    0x4(%eax),%edx
   13b40:	8b 45 08             	mov    0x8(%ebp),%eax
   13b43:	89 10                	mov    %edx,(%eax)
    if (list->first == (list_node_t *)0)
   13b45:	8b 45 08             	mov    0x8(%ebp),%eax
   13b48:	8b 00                	mov    (%eax),%eax
   13b4a:	85 c0                	test   %eax,%eax
   13b4c:	75 0c                	jne    13b5a <list_remove_first+0x44>
    {
        // node为最后一个结点
        list->last = (list_node_t *)0;
   13b4e:	8b 45 08             	mov    0x8(%ebp),%eax
   13b51:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   13b58:	eb 0c                	jmp    13b66 <list_remove_first+0x50>
    }
    else
    {
        // 非最后一结点，将后继的前驱清0
        remove_node->next->pre = (list_node_t *)0;
   13b5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13b5d:	8b 40 04             	mov    0x4(%eax),%eax
   13b60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

    // 调整node自己，置0，因为没有后继结点
    remove_node->next = remove_node->pre = (list_node_t *)0;
   13b66:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13b69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   13b6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13b72:	8b 10                	mov    (%eax),%edx
   13b74:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13b77:	89 50 04             	mov    %edx,0x4(%eax)

    // 同时调整计数值
    list->count--;
   13b7a:	8b 45 08             	mov    0x8(%ebp),%eax
   13b7d:	8b 40 08             	mov    0x8(%eax),%eax
   13b80:	8d 50 ff             	lea    -0x1(%eax),%edx
   13b83:	8b 45 08             	mov    0x8(%ebp),%eax
   13b86:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   13b89:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13b8c:	c9                   	leave  
   13b8d:	c3                   	ret    

00013b8e <list_remove>:
/**
 * 移除指定链表的中的表项
 * 不检查node是否在结点中
 */
list_node_t *list_remove(list_t *list, list_node_t *remove_node)
{
   13b8e:	55                   	push   %ebp
   13b8f:	89 e5                	mov    %esp,%ebp
    // 如果是头，头往前移
    if (remove_node == list->first)
   13b91:	8b 45 08             	mov    0x8(%ebp),%eax
   13b94:	8b 00                	mov    (%eax),%eax
   13b96:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13b99:	75 0b                	jne    13ba6 <list_remove+0x18>
    {
        list->first = remove_node->next;
   13b9b:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b9e:	8b 50 04             	mov    0x4(%eax),%edx
   13ba1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ba4:	89 10                	mov    %edx,(%eax)
    }

    // 如果是尾，则尾往回移
    if (remove_node == list->last)
   13ba6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ba9:	8b 40 04             	mov    0x4(%eax),%eax
   13bac:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13baf:	75 0b                	jne    13bbc <list_remove+0x2e>
    {
        list->last = remove_node->pre;
   13bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bb4:	8b 10                	mov    (%eax),%edx
   13bb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13bb9:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有前，则调整前的后继
    if (remove_node->pre)
   13bbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bbf:	8b 00                	mov    (%eax),%eax
   13bc1:	85 c0                	test   %eax,%eax
   13bc3:	74 0e                	je     13bd3 <list_remove+0x45>
    {
        remove_node->pre->next = remove_node->next;
   13bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bc8:	8b 00                	mov    (%eax),%eax
   13bca:	8b 55 0c             	mov    0xc(%ebp),%edx
   13bcd:	8b 52 04             	mov    0x4(%edx),%edx
   13bd0:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有后，则调整后往前的
    if (remove_node->next)
   13bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bd6:	8b 40 04             	mov    0x4(%eax),%eax
   13bd9:	85 c0                	test   %eax,%eax
   13bdb:	74 0d                	je     13bea <list_remove+0x5c>
    {
        remove_node->next->pre = remove_node->pre;
   13bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
   13be0:	8b 40 04             	mov    0x4(%eax),%eax
   13be3:	8b 55 0c             	mov    0xc(%ebp),%edx
   13be6:	8b 12                	mov    (%edx),%edx
   13be8:	89 10                	mov    %edx,(%eax)
    }

    // 清空node指向
    remove_node->pre = remove_node->next = (list_node_t *)0;
   13bea:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   13bf4:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bf7:	8b 50 04             	mov    0x4(%eax),%edx
   13bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bfd:	89 10                	mov    %edx,(%eax)
    --list->count;
   13bff:	8b 45 08             	mov    0x8(%ebp),%eax
   13c02:	8b 40 08             	mov    0x8(%eax),%eax
   13c05:	8d 50 ff             	lea    -0x1(%eax),%edx
   13c08:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0b:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   13c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   13c11:	5d                   	pop    %ebp
   13c12:	c3                   	ret    

00013c13 <inb>:
{
   13c13:	55                   	push   %ebp
   13c14:	89 e5                	mov    %esp,%ebp
   13c16:	83 ec 14             	sub    $0x14,%esp
   13c19:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   13c20:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13c24:	89 c2                	mov    %eax,%edx
   13c26:	ec                   	in     (%dx),%al
   13c27:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   13c2a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   13c2e:	c9                   	leave  
   13c2f:	c3                   	ret    

00013c30 <outb>:
{
   13c30:	55                   	push   %ebp
   13c31:	89 e5                	mov    %esp,%ebp
   13c33:	83 ec 08             	sub    $0x8,%esp
   13c36:	8b 55 08             	mov    0x8(%ebp),%edx
   13c39:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c3c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13c40:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   13c43:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13c47:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13c4b:	ee                   	out    %al,(%dx)
}
   13c4c:	90                   	nop
   13c4d:	c9                   	leave  
   13c4e:	c3                   	ret    

00013c4f <log_init>:
#define COM1_PORT 0x3F8 // RS232端口0初始化

static mutex_t mutex;

void log_init(void)
{
   13c4f:	55                   	push   %ebp
   13c50:	89 e5                	mov    %esp,%ebp
   13c52:	83 ec 08             	sub    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); // Disable all interrupts
   13c55:	6a 00                	push   $0x0
   13c57:	68 f9 03 00 00       	push   $0x3f9
   13c5c:	e8 cf ff ff ff       	call   13c30 <outb>
   13c61:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor)
   13c64:	68 80 00 00 00       	push   $0x80
   13c69:	68 fb 03 00 00       	push   $0x3fb
   13c6e:	e8 bd ff ff ff       	call   13c30 <outb>
   13c73:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud
   13c76:	6a 03                	push   $0x3
   13c78:	68 f8 03 00 00       	push   $0x3f8
   13c7d:	e8 ae ff ff ff       	call   13c30 <outb>
   13c82:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); //                  (hi byte)
   13c85:	6a 00                	push   $0x0
   13c87:	68 f9 03 00 00       	push   $0x3f9
   13c8c:	e8 9f ff ff ff       	call   13c30 <outb>
   13c91:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x03); // 8 bits, no parity, one stop bit
   13c94:	6a 03                	push   $0x3
   13c96:	68 fb 03 00 00       	push   $0x3fb
   13c9b:	e8 90 ff ff ff       	call   13c30 <outb>
   13ca0:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 2, 0xC7); // Enable FIFO, clear them, with 14-byte threshold
   13ca3:	68 c7 00 00 00       	push   $0xc7
   13ca8:	68 fa 03 00 00       	push   $0x3fa
   13cad:	e8 7e ff ff ff       	call   13c30 <outb>
   13cb2:	83 c4 08             	add    $0x8,%esp
    mutex_init(&mutex);
   13cb5:	83 ec 0c             	sub    $0xc,%esp
   13cb8:	68 24 ac 03 00       	push   $0x3ac24
   13cbd:	e8 b9 f2 ff ff       	call   12f7b <mutex_init>
   13cc2:	83 c4 10             	add    $0x10,%esp
}
   13cc5:	90                   	nop
   13cc6:	c9                   	leave  
   13cc7:	c3                   	ret    

00013cc8 <log_printf>:

void log_printf(const char *fmt, ...)
{
   13cc8:	55                   	push   %ebp
   13cc9:	89 e5                	mov    %esp,%ebp
   13ccb:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf, '\0', sizeof(str_buf));
   13cd1:	83 ec 04             	sub    $0x4,%esp
   13cd4:	68 80 00 00 00       	push   $0x80
   13cd9:	6a 00                	push   $0x0
   13cdb:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   13ce1:	50                   	push   %eax
   13ce2:	e8 62 f9 ff ff       	call   13649 <kernel_memset>
   13ce7:	83 c4 10             	add    $0x10,%esp
    va_start(args, fmt);
   13cea:	8d 45 0c             	lea    0xc(%ebp),%eax
   13ced:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    kernel_vsprintf(str_buf, fmt, args);
   13cf3:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
   13cf9:	83 ec 04             	sub    $0x4,%esp
   13cfc:	50                   	push   %eax
   13cfd:	ff 75 08             	pushl  0x8(%ebp)
   13d00:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   13d06:	50                   	push   %eax
   13d07:	e8 1b fb ff ff       	call   13827 <kernel_vsprintf>
   13d0c:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    // 临界区进入
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   13d0f:	83 ec 0c             	sub    $0xc,%esp
   13d12:	68 24 ac 03 00       	push   $0x3ac24
   13d17:	e8 8d f2 ff ff       	call   12fa9 <mutex_lock>
   13d1c:	83 c4 10             	add    $0x10,%esp
    const char *p = str_buf;
   13d1f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   13d25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != '\0')
   13d28:	eb 3b                	jmp    13d65 <log_printf+0x9d>
    {
        // 检查串口是否忙
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0)
   13d2a:	90                   	nop
   13d2b:	83 ec 0c             	sub    $0xc,%esp
   13d2e:	68 fd 03 00 00       	push   $0x3fd
   13d33:	e8 db fe ff ff       	call   13c13 <inb>
   13d38:	83 c4 10             	add    $0x10,%esp
   13d3b:	0f b6 c0             	movzbl %al,%eax
   13d3e:	83 e0 40             	and    $0x40,%eax
   13d41:	85 c0                	test   %eax,%eax
   13d43:	74 e6                	je     13d2b <log_printf+0x63>
        {
        }
        outb(COM1_PORT, *p++);
   13d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d48:	8d 50 01             	lea    0x1(%eax),%edx
   13d4b:	89 55 f4             	mov    %edx,-0xc(%ebp)
   13d4e:	0f b6 00             	movzbl (%eax),%eax
   13d51:	0f b6 c0             	movzbl %al,%eax
   13d54:	83 ec 08             	sub    $0x8,%esp
   13d57:	50                   	push   %eax
   13d58:	68 f8 03 00 00       	push   $0x3f8
   13d5d:	e8 ce fe ff ff       	call   13c30 <outb>
   13d62:	83 c4 10             	add    $0x10,%esp
    while (*p != '\0')
   13d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d68:	0f b6 00             	movzbl (%eax),%eax
   13d6b:	84 c0                	test   %al,%al
   13d6d:	75 bb                	jne    13d2a <log_printf+0x62>
    }
    // 增加默认换行
    outb(COM1_PORT, '\r'); // 行号不变，列号归零
   13d6f:	83 ec 08             	sub    $0x8,%esp
   13d72:	6a 0d                	push   $0xd
   13d74:	68 f8 03 00 00       	push   $0x3f8
   13d79:	e8 b2 fe ff ff       	call   13c30 <outb>
   13d7e:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT, '\n'); // 列号不变，行号+1
   13d81:	83 ec 08             	sub    $0x8,%esp
   13d84:	6a 0a                	push   $0xa
   13d86:	68 f8 03 00 00       	push   $0x3f8
   13d8b:	e8 a0 fe ff ff       	call   13c30 <outb>
   13d90:	83 c4 10             	add    $0x10,%esp
    // irq_leave_protection(state); // 临界区退出
    mutex_unlock(&mutex);
   13d93:	83 ec 0c             	sub    $0xc,%esp
   13d96:	68 24 ac 03 00       	push   $0x3ac24
   13d9b:	e8 9d f2 ff ff       	call   1303d <mutex_unlock>
   13da0:	83 c4 10             	add    $0x10,%esp
   13da3:	90                   	nop
   13da4:	c9                   	leave  
   13da5:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
 	.text
 	.global first_task_entry
	.extern first_task_main
first_task_entry:
    // 需要重新加载各数据段
    mov %ss, %ax
80000000:	66 8c d0             	mov    %ss,%ax
    mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
    mov %ax, %es
80000005:	8e c0                	mov    %eax,%es
    mov %ax, %fs
80000007:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
80000009:	8e e8                	mov    %eax,%gs
8000000b:	e9 01 01 00 00       	jmp    80000111 <first_task_main>

80000010 <sys_call>:

/**
 * 执行系统调用
 */
static inline int sys_call(syscall_args_t *args)
{
80000010:	55                   	push   %ebp
80000011:	89 e5                	mov    %esp,%ebp
80000013:	57                   	push   %edi
80000014:	56                   	push   %esi
80000015:	53                   	push   %ebx
80000016:	83 ec 10             	sub    $0x10,%esp
    const unsigned long sys_gate_addr[] = {0, SELECTOR_SYSCALL | 0}; // 使用特权级0
80000019:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
80000020:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[gate])\n\n"
        : "=a"(ret)
        : [arg3] "r"(args->arg3), [arg2] "r"(args->arg2), [arg1] "r"(args->arg1),
80000027:	8b 45 08             	mov    0x8(%ebp),%eax
8000002a:	8b 40 10             	mov    0x10(%eax),%eax
8000002d:	8b 55 08             	mov    0x8(%ebp),%edx
80000030:	8b 52 0c             	mov    0xc(%edx),%edx
80000033:	8b 4d 08             	mov    0x8(%ebp),%ecx
80000036:	8b 49 08             	mov    0x8(%ecx),%ecx
          [arg0] "r"(args->arg0), [id] "r"(args->id),
80000039:	8b 5d 08             	mov    0x8(%ebp),%ebx
8000003c:	8b 5b 04             	mov    0x4(%ebx),%ebx
8000003f:	8b 75 08             	mov    0x8(%ebp),%esi
80000042:	8b 36                	mov    (%esi),%esi
    __asm__ __volatile__(
80000044:	8d 7d e8             	lea    -0x18(%ebp),%edi
80000047:	50                   	push   %eax
80000048:	52                   	push   %edx
80000049:	51                   	push   %ecx
8000004a:	53                   	push   %ebx
8000004b:	56                   	push   %esi
8000004c:	ff 1f                	lcall  *(%edi)
8000004e:	89 45 f0             	mov    %eax,-0x10(%ebp)
          [gate] "r"(sys_gate_addr));
    return ret;
80000051:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000054:	83 c4 10             	add    $0x10,%esp
80000057:	5b                   	pop    %ebx
80000058:	5e                   	pop    %esi
80000059:	5f                   	pop    %edi
8000005a:	5d                   	pop    %ebp
8000005b:	c3                   	ret    

8000005c <msleep>:

static inline void msleep(int ms)
{
8000005c:	55                   	push   %ebp
8000005d:	89 e5                	mov    %esp,%ebp
8000005f:	83 ec 20             	sub    $0x20,%esp
    if (ms <= 0)
80000062:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000066:	7e 1b                	jle    80000083 <msleep+0x27>
    {
        return;
    }

    syscall_args_t args;
    args.id = SYS_msleep;
80000068:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
8000006f:	8b 45 08             	mov    0x8(%ebp),%eax
80000072:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
80000075:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000078:	50                   	push   %eax
80000079:	e8 92 ff ff ff       	call   80000010 <sys_call>
8000007e:	83 c4 04             	add    $0x4,%esp
80000081:	eb 01                	jmp    80000084 <msleep+0x28>
        return;
80000083:	90                   	nop
}
80000084:	c9                   	leave  
80000085:	c3                   	ret    

80000086 <getpid>:

static inline int getpid(void)
{
80000086:	55                   	push   %ebp
80000087:	89 e5                	mov    %esp,%ebp
80000089:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_getpid;
8000008c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000093:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000096:	50                   	push   %eax
80000097:	e8 74 ff ff ff       	call   80000010 <sys_call>
8000009c:	83 c4 04             	add    $0x4,%esp
}
8000009f:	c9                   	leave  
800000a0:	c3                   	ret    

800000a1 <print_msg>:

static inline void print_msg(const char *fmt, int arg)
{
800000a1:	55                   	push   %ebp
800000a2:	89 e5                	mov    %esp,%ebp
800000a4:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_printmsg;
800000a7:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (int)fmt;
800000ae:	8b 45 08             	mov    0x8(%ebp),%eax
800000b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
800000b4:	8b 45 0c             	mov    0xc(%ebp),%eax
800000b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
800000ba:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000bd:	50                   	push   %eax
800000be:	e8 4d ff ff ff       	call   80000010 <sys_call>
800000c3:	83 c4 04             	add    $0x4,%esp
}
800000c6:	90                   	nop
800000c7:	c9                   	leave  
800000c8:	c3                   	ret    

800000c9 <fork>:

static inline int fork(void)
{
800000c9:	55                   	push   %ebp
800000ca:	89 e5                	mov    %esp,%ebp
800000cc:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_fork;
800000cf:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
800000d6:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000d9:	50                   	push   %eax
800000da:	e8 31 ff ff ff       	call   80000010 <sys_call>
800000df:	83 c4 04             	add    $0x4,%esp
}
800000e2:	c9                   	leave  
800000e3:	c3                   	ret    

800000e4 <execve>:

static inline int execve(const char *name, char *const *argv, char *const *env)
{
800000e4:	55                   	push   %ebp
800000e5:	89 e5                	mov    %esp,%ebp
800000e7:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_execve;
800000ea:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0 = (int)name;
800000f1:	8b 45 08             	mov    0x8(%ebp),%eax
800000f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
800000f7:	8b 45 0c             	mov    0xc(%ebp),%eax
800000fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
800000fd:	8b 45 10             	mov    0x10(%ebp),%eax
80000100:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
80000103:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000106:	50                   	push   %eax
80000107:	e8 04 ff ff ff       	call   80000010 <sys_call>
8000010c:	83 c4 04             	add    $0x4,%esp
}
8000010f:	c9                   	leave  
80000110:	c3                   	ret    

80000111 <first_task_main>:
#include "tools/log.h"
#include "core/task.h"
#include "applib/lib_syscall.h"

int first_task_main(void)
{
80000111:	55                   	push   %ebp
80000112:	89 e5                	mov    %esp,%ebp
80000114:	83 ec 20             	sub    $0x20,%esp
    int count = 3;
80000117:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)

    int pid = getpid();
8000011e:	e8 63 ff ff ff       	call   80000086 <getpid>
80000123:	89 45 f8             	mov    %eax,-0x8(%ebp)
    pid = fork();
80000126:	e8 9e ff ff ff       	call   800000c9 <fork>
8000012b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    print_msg("First task id=%d", pid);
8000012e:	ff 75 f8             	pushl  -0x8(%ebp)
80000131:	68 92 47 01 00       	push   $0x14792
80000136:	e8 66 ff ff ff       	call   800000a1 <print_msg>
8000013b:	83 c4 08             	add    $0x8,%esp
    if (pid < 0)
8000013e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
80000142:	79 11                	jns    80000155 <first_task_main+0x44>
    {
        print_msg("create task failed\n", 0);
80000144:	6a 00                	push   $0x0
80000146:	68 a3 47 01 00       	push   $0x147a3
8000014b:	e8 51 ff ff ff       	call   800000a1 <print_msg>
80000150:	83 c4 08             	add    $0x8,%esp
80000153:	eb 67                	jmp    800001bc <first_task_main+0xab>
    }
    else if (pid == 0)
80000155:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
80000159:	75 41                	jne    8000019c <first_task_main+0x8b>
    {
        print_msg("child: %d\n", count);
8000015b:	ff 75 fc             	pushl  -0x4(%ebp)
8000015e:	68 b7 47 01 00       	push   $0x147b7
80000163:	e8 39 ff ff ff       	call   800000a1 <print_msg>
80000168:	83 c4 08             	add    $0x8,%esp
        char *argv[] = {"arg0", "arg1", "arg2", "arg3"};
8000016b:	c7 45 e8 c2 47 01 00 	movl   $0x147c2,-0x18(%ebp)
80000172:	c7 45 ec c7 47 01 00 	movl   $0x147c7,-0x14(%ebp)
80000179:	c7 45 f0 cc 47 01 00 	movl   $0x147cc,-0x10(%ebp)
80000180:	c7 45 f4 d1 47 01 00 	movl   $0x147d1,-0xc(%ebp)
        execve("/shell.elf", argv, (char **)0);
80000187:	6a 00                	push   $0x0
80000189:	8d 45 e8             	lea    -0x18(%ebp),%eax
8000018c:	50                   	push   %eax
8000018d:	68 d6 47 01 00       	push   $0x147d6
80000192:	e8 4d ff ff ff       	call   800000e4 <execve>
80000197:	83 c4 0c             	add    $0xc,%esp
8000019a:	eb 20                	jmp    800001bc <first_task_main+0xab>
    }
    else
    {
        print_msg("child task id=%d\n", pid);
8000019c:	ff 75 f8             	pushl  -0x8(%ebp)
8000019f:	68 e1 47 01 00       	push   $0x147e1
800001a4:	e8 f8 fe ff ff       	call   800000a1 <print_msg>
800001a9:	83 c4 08             	add    $0x8,%esp
        print_msg("parent: %d\n", count);
800001ac:	ff 75 fc             	pushl  -0x4(%ebp)
800001af:	68 f3 47 01 00       	push   $0x147f3
800001b4:	e8 e8 fe ff ff       	call   800000a1 <print_msg>
800001b9:	83 c4 08             	add    $0x8,%esp
    }

    for (;;)
    {
        print_msg("task id=%d", pid);
800001bc:	ff 75 f8             	pushl  -0x8(%ebp)
800001bf:	68 ff 47 01 00       	push   $0x147ff
800001c4:	e8 d8 fe ff ff       	call   800000a1 <print_msg>
800001c9:	83 c4 08             	add    $0x8,%esp
        // log_printf("first task.");
        // sys_msleep(1000);
        msleep(1000);
800001cc:	68 e8 03 00 00       	push   $0x3e8
800001d1:	e8 86 fe ff ff       	call   8000005c <msleep>
800001d6:	83 c4 04             	add    $0x4,%esp
        print_msg("task id=%d", pid);
800001d9:	eb e1                	jmp    800001bc <first_task_main+0xab>
