
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00002d10 memsz 0x00002d10 flags r-x
    LOAD off    0x00004000 vaddr 0x00013000 paddr 0x00013000 align 2**12
         filesz 0x00000044 memsz 0x00007ed0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002897  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000478  00012898  00012898  00003898  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000044  00013000  00013000  00004000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00006ed0  00014000  00014000  00004044  2**12
                  ALLOC
  4 .debug_line   0000187c  00000000  00000000  00004044  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003f30  00000000  00000000  000058c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000114b  00000000  00000000  000097f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000001a0  00000000  00000000  0000a940  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000fe5  00000000  00000000  0000aae0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000011  00000000  00000000  0000bac5  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00001170  00000000  00000000  0000bad8  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00012898 l    d  .rodata	00000000 .rodata
00013000 l    d  .data	00000000 .data
00014000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102c7 l     F .text	00000017 up2
000102de l     F .text	0000000d down2
000102eb l     F .text	0000000c write_cr3
000102f7 l     F .text	00000014 pde_index
0001030b l     F .text	00000027 pde_paddr
00010332 l     F .text	00000010 pte_index
00010342 l     F .text	00000011 mmu_set_page_dir
00014000 l     O .bss	00000028 paddr_alloc
00015000 l     O .bss	00001000 kernel_page_dir
00010353 l     F .text	00000058 addr_alloc_init
000103ab l     F .text	00000067 addr_alloc_page
00010412 l     F .text	00000062 addr_free_page
00010474 l     F .text	00000066 show_mem_info
000104da l     F .text	0000003c total_mem_size
00012958 l     O .rodata	00000012 __func__.2212
00013000 l     O .data	00000040 kernel_map.2224
0001296c l     O .rodata	0000000c __func__.2253
00000000 l    df *ABS*	00000000 task.c
00010876 l     F .text	0000001b list_node_init
00010891 l     F .text	0000000b list_node_next
0001089c l     F .text	0000000b list_count
000108a7 l     F .text	0000000a list_first
000108b1 l     F .text	00000007 hlt
000108b8 l     F .text	0000000c write_tr
00016000 l     O .bss	00001000 idle_task_stack
00017000 l     O .bss	00000190 task_manager
000108c4 l     F .text	00000130 tss_init
000129f0 l     O .rodata	0000000a __func__.2117
00010b47 l     F .text	0000000a idle_task_entry
00010c81 l     F .text	00000043 task_next_run
00000000 l    df *ABS*	00000000 cpu.c
00010ec7 l     F .text	00000028 lgdt
00010eef l     F .text	0000001a far_jump
000171a0 l     O .bss	00000800 gdt_table
000179a0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
0001111b l     F .text	0000001d inb
00011138 l     F .text	0000001f outb
00011157 l     F .text	00000007 cli
0001115e l     F .text	00000007 sti
00011165 l     F .text	00000028 lidt
0001118d l     F .text	00000007 hlt
00011194 l     F .text	00000010 read_eflags
000111a4 l     F .text	0000000b write_eflags
000179c0 l     O .bss	00000400 idt_table
000111af l     F .text	000000d2 dump_core_regs
00011281 l     F .text	0000004e do_default_handler
000114ff l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 time.c
000118f6 l     F .text	0000001f outb
00017dc0 l     O .bss	00000004 sys_tick
00011915 l     F .text	00000060 init_pic
00000000 l    df *ABS*	00000000 init.c
00017de0 l     O .bss	000000b4 init_task
00017ea0 l     O .bss	00001000 init_task_stack
00018ea0 l     O .bss	00000010 sem
00000000 l    df *ABS*	00000000 mutex.c
00011ad4 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
00011c5e l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
00011fe7 l     F .text	00000007 hlt
00013040 l     O .data	00000004 num2ch.1920
00000000 l    df *ABS*	00000000 list.c
0001250c l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00012704 l     F .text	0000001d inb
00012721 l     F .text	0000001f outb
00018eb0 l     O .bss	00000014 mutex
00011edf g     F .text	0000003a bitmap_get_bit
0001215e g     F .text	0000004f kernel_memcpy
00010c16 g     F .text	0000000a task_current
00011897 g     F .text	0000000b irq_enable_global
000125a3 g     F .text	00000064 list_insert_last
00010e63 g     F .text	00000064 sys_msleep
00011403 g     F .text	0000001c do_handler_segment_not_present
00010bb7 g     F .text	00000034 task_set_ready
00011f19 g     F .text	0000001b bitmap_is_set
000121ad g     F .text	00000041 kernel_memset
00010274 g       .text	00000000 exception_handler_virtual_exception
000110ea g     F .text	0000001e cpu_init
00012740 g     F .text	00000079 log_init
00011a1e g     F .text	000000b6 init_main
00010219 g       .text	00000000 exception_handler_alignment_check
00010f88 g     F .text	00000039 gdt_free_sel
00011fee g     F .text	00000047 kernel_strcpy
00013000 g       .data	00000000 s_data
0001177a g     F .text	0000008b irq_enable
00010035 g       .text	00000000 exception_handler_unknown
000100b1 g       .text	00000000 exception_handler_breakpoint
0001135b g     F .text	0000001c do_handler_overflow
00011457 g     F .text	0000001c do_handler_alignment_check
000105c6 g     F .text	0000008c memory_create_map
000101c0 g       .text	00000000 exception_handler_general_protection
000114c7 g     F .text	0000001c do_handler_general_protection
00011d79 g     F .text	00000029 sem_count
000112eb g     F .text	0000001c do_handler_divider
00011e0b g     F .text	000000d4 bitmap_set_bit
000113cb g     F .text	0000001c do_handler_double_fault
000119e5 g     F .text	00000039 init_task_entry
000114e3 g     F .text	0000001c do_handler_page_fault
0001014c g       .text	00000000 exception_handler_double_fault
000118a2 g     F .text	0000002b pic_send_eoi
00010b3d g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
0001070d g     F .text	00000085 memory_create_uvm
00011c8c g     F .text	0000006b sem_wait
00011975 g     F .text	00000028 do_handler_timer
000101a3 g       .text	00000000 exception_handler_stack_segment_fault
000114ab g     F .text	0000001c do_handler_virtual_exception
000100d0 g       .text	00000000 exception_handler_overflow
00010fc1 g     F .text	00000075 get_alloc_desc
000102b2 g       .text	00000000 simple_switch
00018ed0 g     O .bss	00002000 stack
000100ef g       .text	00000000 exception_handler_bound_range
00011cf7 g     F .text	00000082 sem_notify
00011393 g     F .text	0000001c do_handler_invalid_opcode
00010169 g       .text	00000000 exception_handler_invalid_tss
0001143b g     F .text	0000001c do_handler_fpu_error
00010b03 g     F .text	0000003a task_first_init
00011473 g     F .text	0000001c do_handler_machine_check
00011307 g     F .text	0000001c do_handler_Debug
00012544 g     F .text	0000005f list_insert_first
00010e43 g     F .text	00000020 task_set_wakeup
00011323 g     F .text	0000001c do_handler_NMI
00010054 g       .text	00000000 exception_handler_divider
00012035 g     F .text	00000070 kernel_strncpy
0001188c g     F .text	0000000b irq_disable_global
00010c20 g     F .text	00000061 sys_sched_yield
0001aed0 g       .bss	00000000 mem_free_start
000119b5 g     F .text	00000030 kernel_init
00011c69 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
0001238b g     F .text	0000014b kernel_vsprintf
0001012d g       .text	00000000 exception_handler_device_unavailable
0001010e g       .text	00000000 exception_handler_invalid_opcode
00011b0d g     F .text	00000094 mutex_lock
00010236 g       .text	00000000 exception_handler_machine_check
000113e7 g     F .text	0000001c do_handler_invalid_tss
00000000 g       *ABS*	00000000 kernel_base
00010e09 g     F .text	0000003a task_set_sleep
000124d6 g     F .text	00000036 panic
00010293 g       .text	00000000 exception_handler_timer
00011740 g     F .text	0000003a irq_install
00011036 g     F .text	0000006d init_gdt
000118cd g     F .text	00000018 irq_enter_protection
00011adf g     F .text	0000002e mutex_init
00011805 g     F .text	00000087 irq_disable
00010255 g       .text	00000000 exception_handler_smd_exception
00011da2 g     F .text	00000016 bitmap_byte_count
000113af g     F .text	0000001c do_handler_device_unavailable
00010cc4 g     F .text	0000005b task_dispatch
00011108 g     F .text	00000013 switch_to_tss
000121ee g     F .text	0000005e kernel_memcmp
00010652 g     F .text	000000bb create_kernel_table
0001251f g     F .text	00000025 list_init
0001148f g     F .text	0000001c do_handler_smd_exception
000101dd g       .text	00000000 exception_handler_page_fault
00010beb g     F .text	0000002b task_set_block
000112cf g     F .text	0000001c do_handler_unknown
000101fa g       .text	00000000 exception_handler_fpu_error
00010ae5 g     F .text	0000001e task_switch_from_to
00011592 g     F .text	000001ae irq_init
00011ba1 g     F .text	000000bd mutex_unlock
000118e5 g     F .text	00000011 irq_leave_protection
00012123 g     F .text	0000003b kernel_strlen
00010f09 g     F .text	0000007f segment_desc_set
00011377 g     F .text	0000001c do_handler_bound_range
00012607 g     F .text	00000078 list_remove_first
00012d10 g       .rodata	00000000 e_text
000120a5 g     F .text	0000007e kernel_strncmp
00011db8 g     F .text	00000053 bitmap_init
00010186 g       .text	00000000 exception_handler_segment_not_present
00010092 g       .text	00000000 exception_handler_NMI
00011f34 g     F .text	000000b3 bitmap_alloc_nbits
00010b51 g     F .text	00000066 task_manager_init
00010073 g       .text	00000000 exception_handler_Debug
00010d1f g     F .text	000000ea task_time_tick
00010792 g     F .text	000000e4 memory_init
0001141f g     F .text	0000001c do_handler_stack_segment_fault
0001133f g     F .text	0000001c do_handler_breakpoint
000127b9 g     F .text	000000de log_printf
000109f4 g     F .text	000000f1 task_init
0001224c g     F .text	0000013f kernel_itoa
0001267f g     F .text	00000085 list_remove
000110a3 g     F .text	00000047 gate_desc_set
00010516 g     F .text	000000b0 find_pte
0001199d g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .extern kernel_init
    .extern init_main
    .global _start
    # void start (boot_info_t *boot_info)
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax
    # kernel_init(boot_info)
    push %eax
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 a9 19 00 00       	call   119b5 <kernel_init>
    jmp $KERNEL_SELECTOR_CS, $gdt_reload # 重新加载GDT
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs

    ; mov $stack, %eax
   10021:	b8 d0 8e 01 00       	mov    $0x18ed0,%eax
    ; mov $KERNEL_STACK_SIZE, %ebx
   10026:	bb 00 20 00 00       	mov    $0x2000,%ebx

    mov $(stack + KERNEL_STACK_SIZE), %esp
   1002b:	bc d0 ae 01 00       	mov    $0x1aed0,%esp
    jmp init_main
   10030:	e9 e9 19 00 00       	jmp    11a1e <init_main>

00010035 <exception_handler_unknown>:
    add $(2*4), %esp

    iret
.endm

exception_handler unknown, -1, 0
   10035:	6a 00                	push   $0x0
   10037:	6a ff                	push   $0xffffffff
   10039:	60                   	pusha  
   1003a:	1e                   	push   %ds
   1003b:	06                   	push   %es
   1003c:	0f a0                	push   %fs
   1003e:	0f a8                	push   %gs
   10040:	54                   	push   %esp
   10041:	e8 89 12 00 00       	call   112cf <do_handler_unknown>
   10046:	83 c4 04             	add    $0x4,%esp
   10049:	0f a9                	pop    %gs
   1004b:	0f a1                	pop    %fs
   1004d:	07                   	pop    %es
   1004e:	1f                   	pop    %ds
   1004f:	61                   	popa   
   10050:	83 c4 08             	add    $0x8,%esp
   10053:	cf                   	iret   

00010054 <exception_handler_divider>:
exception_handler divider, 0, 0
   10054:	6a 00                	push   $0x0
   10056:	6a 00                	push   $0x0
   10058:	60                   	pusha  
   10059:	1e                   	push   %ds
   1005a:	06                   	push   %es
   1005b:	0f a0                	push   %fs
   1005d:	0f a8                	push   %gs
   1005f:	54                   	push   %esp
   10060:	e8 86 12 00 00       	call   112eb <do_handler_divider>
   10065:	83 c4 04             	add    $0x4,%esp
   10068:	0f a9                	pop    %gs
   1006a:	0f a1                	pop    %fs
   1006c:	07                   	pop    %es
   1006d:	1f                   	pop    %ds
   1006e:	61                   	popa   
   1006f:	83 c4 08             	add    $0x8,%esp
   10072:	cf                   	iret   

00010073 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10073:	6a 00                	push   $0x0
   10075:	6a 01                	push   $0x1
   10077:	60                   	pusha  
   10078:	1e                   	push   %ds
   10079:	06                   	push   %es
   1007a:	0f a0                	push   %fs
   1007c:	0f a8                	push   %gs
   1007e:	54                   	push   %esp
   1007f:	e8 83 12 00 00       	call   11307 <do_handler_Debug>
   10084:	83 c4 04             	add    $0x4,%esp
   10087:	0f a9                	pop    %gs
   10089:	0f a1                	pop    %fs
   1008b:	07                   	pop    %es
   1008c:	1f                   	pop    %ds
   1008d:	61                   	popa   
   1008e:	83 c4 08             	add    $0x8,%esp
   10091:	cf                   	iret   

00010092 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10092:	6a 00                	push   $0x0
   10094:	6a 02                	push   $0x2
   10096:	60                   	pusha  
   10097:	1e                   	push   %ds
   10098:	06                   	push   %es
   10099:	0f a0                	push   %fs
   1009b:	0f a8                	push   %gs
   1009d:	54                   	push   %esp
   1009e:	e8 80 12 00 00       	call   11323 <do_handler_NMI>
   100a3:	83 c4 04             	add    $0x4,%esp
   100a6:	0f a9                	pop    %gs
   100a8:	0f a1                	pop    %fs
   100aa:	07                   	pop    %es
   100ab:	1f                   	pop    %ds
   100ac:	61                   	popa   
   100ad:	83 c4 08             	add    $0x8,%esp
   100b0:	cf                   	iret   

000100b1 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100b1:	6a 00                	push   $0x0
   100b3:	6a 03                	push   $0x3
   100b5:	60                   	pusha  
   100b6:	1e                   	push   %ds
   100b7:	06                   	push   %es
   100b8:	0f a0                	push   %fs
   100ba:	0f a8                	push   %gs
   100bc:	54                   	push   %esp
   100bd:	e8 7d 12 00 00       	call   1133f <do_handler_breakpoint>
   100c2:	83 c4 04             	add    $0x4,%esp
   100c5:	0f a9                	pop    %gs
   100c7:	0f a1                	pop    %fs
   100c9:	07                   	pop    %es
   100ca:	1f                   	pop    %ds
   100cb:	61                   	popa   
   100cc:	83 c4 08             	add    $0x8,%esp
   100cf:	cf                   	iret   

000100d0 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100d0:	6a 00                	push   $0x0
   100d2:	6a 04                	push   $0x4
   100d4:	60                   	pusha  
   100d5:	1e                   	push   %ds
   100d6:	06                   	push   %es
   100d7:	0f a0                	push   %fs
   100d9:	0f a8                	push   %gs
   100db:	54                   	push   %esp
   100dc:	e8 7a 12 00 00       	call   1135b <do_handler_overflow>
   100e1:	83 c4 04             	add    $0x4,%esp
   100e4:	0f a9                	pop    %gs
   100e6:	0f a1                	pop    %fs
   100e8:	07                   	pop    %es
   100e9:	1f                   	pop    %ds
   100ea:	61                   	popa   
   100eb:	83 c4 08             	add    $0x8,%esp
   100ee:	cf                   	iret   

000100ef <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100ef:	6a 00                	push   $0x0
   100f1:	6a 05                	push   $0x5
   100f3:	60                   	pusha  
   100f4:	1e                   	push   %ds
   100f5:	06                   	push   %es
   100f6:	0f a0                	push   %fs
   100f8:	0f a8                	push   %gs
   100fa:	54                   	push   %esp
   100fb:	e8 77 12 00 00       	call   11377 <do_handler_bound_range>
   10100:	83 c4 04             	add    $0x4,%esp
   10103:	0f a9                	pop    %gs
   10105:	0f a1                	pop    %fs
   10107:	07                   	pop    %es
   10108:	1f                   	pop    %ds
   10109:	61                   	popa   
   1010a:	83 c4 08             	add    $0x8,%esp
   1010d:	cf                   	iret   

0001010e <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   1010e:	6a 00                	push   $0x0
   10110:	6a 06                	push   $0x6
   10112:	60                   	pusha  
   10113:	1e                   	push   %ds
   10114:	06                   	push   %es
   10115:	0f a0                	push   %fs
   10117:	0f a8                	push   %gs
   10119:	54                   	push   %esp
   1011a:	e8 74 12 00 00       	call   11393 <do_handler_invalid_opcode>
   1011f:	83 c4 04             	add    $0x4,%esp
   10122:	0f a9                	pop    %gs
   10124:	0f a1                	pop    %fs
   10126:	07                   	pop    %es
   10127:	1f                   	pop    %ds
   10128:	61                   	popa   
   10129:	83 c4 08             	add    $0x8,%esp
   1012c:	cf                   	iret   

0001012d <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   1012d:	6a 00                	push   $0x0
   1012f:	6a 07                	push   $0x7
   10131:	60                   	pusha  
   10132:	1e                   	push   %ds
   10133:	06                   	push   %es
   10134:	0f a0                	push   %fs
   10136:	0f a8                	push   %gs
   10138:	54                   	push   %esp
   10139:	e8 71 12 00 00       	call   113af <do_handler_device_unavailable>
   1013e:	83 c4 04             	add    $0x4,%esp
   10141:	0f a9                	pop    %gs
   10143:	0f a1                	pop    %fs
   10145:	07                   	pop    %es
   10146:	1f                   	pop    %ds
   10147:	61                   	popa   
   10148:	83 c4 08             	add    $0x8,%esp
   1014b:	cf                   	iret   

0001014c <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   1014c:	6a 08                	push   $0x8
   1014e:	60                   	pusha  
   1014f:	1e                   	push   %ds
   10150:	06                   	push   %es
   10151:	0f a0                	push   %fs
   10153:	0f a8                	push   %gs
   10155:	54                   	push   %esp
   10156:	e8 70 12 00 00       	call   113cb <do_handler_double_fault>
   1015b:	83 c4 04             	add    $0x4,%esp
   1015e:	0f a9                	pop    %gs
   10160:	0f a1                	pop    %fs
   10162:	07                   	pop    %es
   10163:	1f                   	pop    %ds
   10164:	61                   	popa   
   10165:	83 c4 08             	add    $0x8,%esp
   10168:	cf                   	iret   

00010169 <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   10169:	6a 0a                	push   $0xa
   1016b:	60                   	pusha  
   1016c:	1e                   	push   %ds
   1016d:	06                   	push   %es
   1016e:	0f a0                	push   %fs
   10170:	0f a8                	push   %gs
   10172:	54                   	push   %esp
   10173:	e8 6f 12 00 00       	call   113e7 <do_handler_invalid_tss>
   10178:	83 c4 04             	add    $0x4,%esp
   1017b:	0f a9                	pop    %gs
   1017d:	0f a1                	pop    %fs
   1017f:	07                   	pop    %es
   10180:	1f                   	pop    %ds
   10181:	61                   	popa   
   10182:	83 c4 08             	add    $0x8,%esp
   10185:	cf                   	iret   

00010186 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10186:	6a 0b                	push   $0xb
   10188:	60                   	pusha  
   10189:	1e                   	push   %ds
   1018a:	06                   	push   %es
   1018b:	0f a0                	push   %fs
   1018d:	0f a8                	push   %gs
   1018f:	54                   	push   %esp
   10190:	e8 6e 12 00 00       	call   11403 <do_handler_segment_not_present>
   10195:	83 c4 04             	add    $0x4,%esp
   10198:	0f a9                	pop    %gs
   1019a:	0f a1                	pop    %fs
   1019c:	07                   	pop    %es
   1019d:	1f                   	pop    %ds
   1019e:	61                   	popa   
   1019f:	83 c4 08             	add    $0x8,%esp
   101a2:	cf                   	iret   

000101a3 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   101a3:	6a 0c                	push   $0xc
   101a5:	60                   	pusha  
   101a6:	1e                   	push   %ds
   101a7:	06                   	push   %es
   101a8:	0f a0                	push   %fs
   101aa:	0f a8                	push   %gs
   101ac:	54                   	push   %esp
   101ad:	e8 6d 12 00 00       	call   1141f <do_handler_stack_segment_fault>
   101b2:	83 c4 04             	add    $0x4,%esp
   101b5:	0f a9                	pop    %gs
   101b7:	0f a1                	pop    %fs
   101b9:	07                   	pop    %es
   101ba:	1f                   	pop    %ds
   101bb:	61                   	popa   
   101bc:	83 c4 08             	add    $0x8,%esp
   101bf:	cf                   	iret   

000101c0 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101c0:	6a 0d                	push   $0xd
   101c2:	60                   	pusha  
   101c3:	1e                   	push   %ds
   101c4:	06                   	push   %es
   101c5:	0f a0                	push   %fs
   101c7:	0f a8                	push   %gs
   101c9:	54                   	push   %esp
   101ca:	e8 f8 12 00 00       	call   114c7 <do_handler_general_protection>
   101cf:	83 c4 04             	add    $0x4,%esp
   101d2:	0f a9                	pop    %gs
   101d4:	0f a1                	pop    %fs
   101d6:	07                   	pop    %es
   101d7:	1f                   	pop    %ds
   101d8:	61                   	popa   
   101d9:	83 c4 08             	add    $0x8,%esp
   101dc:	cf                   	iret   

000101dd <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101dd:	6a 0e                	push   $0xe
   101df:	60                   	pusha  
   101e0:	1e                   	push   %ds
   101e1:	06                   	push   %es
   101e2:	0f a0                	push   %fs
   101e4:	0f a8                	push   %gs
   101e6:	54                   	push   %esp
   101e7:	e8 f7 12 00 00       	call   114e3 <do_handler_page_fault>
   101ec:	83 c4 04             	add    $0x4,%esp
   101ef:	0f a9                	pop    %gs
   101f1:	0f a1                	pop    %fs
   101f3:	07                   	pop    %es
   101f4:	1f                   	pop    %ds
   101f5:	61                   	popa   
   101f6:	83 c4 08             	add    $0x8,%esp
   101f9:	cf                   	iret   

000101fa <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101fa:	6a 00                	push   $0x0
   101fc:	6a 10                	push   $0x10
   101fe:	60                   	pusha  
   101ff:	1e                   	push   %ds
   10200:	06                   	push   %es
   10201:	0f a0                	push   %fs
   10203:	0f a8                	push   %gs
   10205:	54                   	push   %esp
   10206:	e8 30 12 00 00       	call   1143b <do_handler_fpu_error>
   1020b:	83 c4 04             	add    $0x4,%esp
   1020e:	0f a9                	pop    %gs
   10210:	0f a1                	pop    %fs
   10212:	07                   	pop    %es
   10213:	1f                   	pop    %ds
   10214:	61                   	popa   
   10215:	83 c4 08             	add    $0x8,%esp
   10218:	cf                   	iret   

00010219 <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   10219:	6a 11                	push   $0x11
   1021b:	60                   	pusha  
   1021c:	1e                   	push   %ds
   1021d:	06                   	push   %es
   1021e:	0f a0                	push   %fs
   10220:	0f a8                	push   %gs
   10222:	54                   	push   %esp
   10223:	e8 2f 12 00 00       	call   11457 <do_handler_alignment_check>
   10228:	83 c4 04             	add    $0x4,%esp
   1022b:	0f a9                	pop    %gs
   1022d:	0f a1                	pop    %fs
   1022f:	07                   	pop    %es
   10230:	1f                   	pop    %ds
   10231:	61                   	popa   
   10232:	83 c4 08             	add    $0x8,%esp
   10235:	cf                   	iret   

00010236 <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   10236:	6a 00                	push   $0x0
   10238:	6a 12                	push   $0x12
   1023a:	60                   	pusha  
   1023b:	1e                   	push   %ds
   1023c:	06                   	push   %es
   1023d:	0f a0                	push   %fs
   1023f:	0f a8                	push   %gs
   10241:	54                   	push   %esp
   10242:	e8 2c 12 00 00       	call   11473 <do_handler_machine_check>
   10247:	83 c4 04             	add    $0x4,%esp
   1024a:	0f a9                	pop    %gs
   1024c:	0f a1                	pop    %fs
   1024e:	07                   	pop    %es
   1024f:	1f                   	pop    %ds
   10250:	61                   	popa   
   10251:	83 c4 08             	add    $0x8,%esp
   10254:	cf                   	iret   

00010255 <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   10255:	6a 00                	push   $0x0
   10257:	6a 13                	push   $0x13
   10259:	60                   	pusha  
   1025a:	1e                   	push   %ds
   1025b:	06                   	push   %es
   1025c:	0f a0                	push   %fs
   1025e:	0f a8                	push   %gs
   10260:	54                   	push   %esp
   10261:	e8 29 12 00 00       	call   1148f <do_handler_smd_exception>
   10266:	83 c4 04             	add    $0x4,%esp
   10269:	0f a9                	pop    %gs
   1026b:	0f a1                	pop    %fs
   1026d:	07                   	pop    %es
   1026e:	1f                   	pop    %ds
   1026f:	61                   	popa   
   10270:	83 c4 08             	add    $0x8,%esp
   10273:	cf                   	iret   

00010274 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10274:	6a 00                	push   $0x0
   10276:	6a 14                	push   $0x14
   10278:	60                   	pusha  
   10279:	1e                   	push   %ds
   1027a:	06                   	push   %es
   1027b:	0f a0                	push   %fs
   1027d:	0f a8                	push   %gs
   1027f:	54                   	push   %esp
   10280:	e8 26 12 00 00       	call   114ab <do_handler_virtual_exception>
   10285:	83 c4 04             	add    $0x4,%esp
   10288:	0f a9                	pop    %gs
   1028a:	0f a1                	pop    %fs
   1028c:	07                   	pop    %es
   1028d:	1f                   	pop    %ds
   1028e:	61                   	popa   
   1028f:	83 c4 08             	add    $0x8,%esp
   10292:	cf                   	iret   

00010293 <exception_handler_timer>:

# 硬件中断
exception_handler timer, 0x20, 0
   10293:	6a 00                	push   $0x0
   10295:	6a 20                	push   $0x20
   10297:	60                   	pusha  
   10298:	1e                   	push   %ds
   10299:	06                   	push   %es
   1029a:	0f a0                	push   %fs
   1029c:	0f a8                	push   %gs
   1029e:	54                   	push   %esp
   1029f:	e8 d1 16 00 00       	call   11975 <do_handler_timer>
   102a4:	83 c4 04             	add    $0x4,%esp
   102a7:	0f a9                	pop    %gs
   102a9:	0f a1                	pop    %fs
   102ab:	07                   	pop    %es
   102ac:	1f                   	pop    %ds
   102ad:	61                   	popa   
   102ae:	83 c4 08             	add    $0x8,%esp
   102b1:	cf                   	iret   

000102b2 <simple_switch>:
// esp不用保存，只需要让esp保存在调用之前的状态
// eflags ?
    .text
    .global simple_switch
simple_switch:
    movl 4(%esp), %eax   // 取from->stack
   102b2:	8b 44 24 04          	mov    0x4(%esp),%eax
	movl 8(%esp), %edx   // 取to->stack
   102b6:	8b 54 24 08          	mov    0x8(%esp),%edx

	// 保存前一任务的状态
	push %ebp
   102ba:	55                   	push   %ebp
	push %ebx
   102bb:	53                   	push   %ebx
	push %esi
   102bc:	56                   	push   %esi
	push %edi
   102bd:	57                   	push   %edi

	// 切换栈
	mov %esp, (%eax)    // from->stack = esp
   102be:	89 20                	mov    %esp,(%eax)
  	mov %edx, %esp      // esp = to->stack
   102c0:	89 d4                	mov    %edx,%esp

	// 加载下一任务的栈
	pop %edi
   102c2:	5f                   	pop    %edi
	pop %esi
   102c3:	5e                   	pop    %esi
	pop %ebx
   102c4:	5b                   	pop    %ebx
	pop %ebp
   102c5:	5d                   	pop    %ebp
   102c6:	c3                   	ret    

000102c7 <up2>:
#include "comm/types.h"
#include <stdarg.h>

// 向上对齐到页边界
static inline uint32_t up2(uint32_t size, uint32_t bound)
{
   102c7:	55                   	push   %ebp
   102c8:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   102ca:	8b 55 08             	mov    0x8(%ebp),%edx
   102cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   102d0:	01 d0                	add    %edx,%eax
   102d2:	8d 50 ff             	lea    -0x1(%eax),%edx
   102d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   102d8:	f7 d8                	neg    %eax
   102da:	21 d0                	and    %edx,%eax
}
   102dc:	5d                   	pop    %ebp
   102dd:	c3                   	ret    

000102de <down2>:
// size = 0x1010 bound = 0x1000
// bound - 1 = 0x0FFF
// ~(bound-1) = 0xFFFF1000
// size & ~(bound-1) =  0x1010 & 0xFFFF1000 = 0x1000
static inline uint32_t down2(uint32_t size, uint32_t bound)
{
   102de:	55                   	push   %ebp
   102df:	89 e5                	mov    %esp,%ebp
    return size & ~(bound - 1);
   102e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   102e4:	f7 d8                	neg    %eax
   102e6:	23 45 08             	and    0x8(%ebp),%eax
}
   102e9:	5d                   	pop    %ebp
   102ea:	c3                   	ret    

000102eb <write_cr3>:
    __asm__ __volatile__("mov %%cr3, %[v]" : [v] "=r"(cr3));
    return cr3;
}

static inline void write_cr3(uint32_t v)
{
   102eb:	55                   	push   %ebp
   102ec:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3" ::[v] "r"(v));
   102ee:	8b 45 08             	mov    0x8(%ebp),%eax
   102f1:	0f 22 d8             	mov    %eax,%cr3
}
   102f4:	90                   	nop
   102f5:	5d                   	pop    %ebp
   102f6:	c3                   	ret    

000102f7 <pde_index>:

/**
 * @brief 返回vaddr在页目录中的索引
 */
static inline uint32_t pde_index(uint32_t vaddr)
{
   102f7:	55                   	push   %ebp
   102f8:	89 e5                	mov    %esp,%ebp
   102fa:	83 ec 10             	sub    $0x10,%esp
    int index = (vaddr >> 22); // 只取高10位
   102fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10300:	c1 e8 16             	shr    $0x16,%eax
   10303:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return index;
   10306:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10309:	c9                   	leave  
   1030a:	c3                   	ret    

0001030b <pde_paddr>:

/**
 * @brief 获取pde中地址
 */
static inline uint32_t pde_paddr(pde_t *pde)
{
   1030b:	55                   	push   %ebp
   1030c:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   1030e:	8b 45 08             	mov    0x8(%ebp),%eax
   10311:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10315:	c0 ea 04             	shr    $0x4,%dl
   10318:	0f b6 d2             	movzbl %dl,%edx
   1031b:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   1031f:	c1 e1 04             	shl    $0x4,%ecx
   10322:	09 ca                	or     %ecx,%edx
   10324:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   10328:	c1 e0 0c             	shl    $0xc,%eax
   1032b:	09 d0                	or     %edx,%eax
   1032d:	c1 e0 0c             	shl    $0xc,%eax
}
   10330:	5d                   	pop    %ebp
   10331:	c3                   	ret    

00010332 <pte_index>:

/**
 * @brief 返回vaddr在页表中的索引
 */
static inline int pte_index(uint32_t vaddr)
{
   10332:	55                   	push   %ebp
   10333:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12) & 0x3FF; // 取中间10位
   10335:	8b 45 08             	mov    0x8(%ebp),%eax
   10338:	c1 e8 0c             	shr    $0xc,%eax
   1033b:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   10340:	5d                   	pop    %ebp
   10341:	c3                   	ret    

00010342 <mmu_set_page_dir>:
/**
 * @brief 重新加载整个页表至cr3高20位寄存器
 * @param vaddr 页表的虚拟地址
 */
static inline void mmu_set_page_dir(uint32_t paddr)
{
   10342:	55                   	push   %ebp
   10343:	89 e5                	mov    %esp,%ebp
    // 将虚拟地址转换为物理地址
    write_cr3(paddr);
   10345:	ff 75 08             	pushl  0x8(%ebp)
   10348:	e8 9e ff ff ff       	call   102eb <write_cr3>
   1034d:	83 c4 04             	add    $0x4,%esp
}
   10350:	90                   	nop
   10351:	c9                   	leave  
   10352:	c3                   	ret    

00010353 <addr_alloc_init>:
 * @brief 初始化地址分配结构
 * 以下不检查start和size的页边界，由上层调用者检查
 */
static void addr_alloc_init(addr_alloc_t *alloc, uint8_t *bits,
                            uint32_t start, uint32_t size, uint32_t page_size)
{
   10353:	55                   	push   %ebp
   10354:	89 e5                	mov    %esp,%ebp
   10356:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&alloc->mutex);
   10359:	8b 45 08             	mov    0x8(%ebp),%eax
   1035c:	83 ec 0c             	sub    $0xc,%esp
   1035f:	50                   	push   %eax
   10360:	e8 7a 17 00 00       	call   11adf <mutex_init>
   10365:	83 c4 10             	add    $0x10,%esp
    alloc->start = start;
   10368:	8b 45 08             	mov    0x8(%ebp),%eax
   1036b:	8b 55 10             	mov    0x10(%ebp),%edx
   1036e:	89 50 20             	mov    %edx,0x20(%eax)
    alloc->size = size;
   10371:	8b 45 08             	mov    0x8(%ebp),%eax
   10374:	8b 55 14             	mov    0x14(%ebp),%edx
   10377:	89 50 24             	mov    %edx,0x24(%eax)
    alloc->page_size = page_size;
   1037a:	8b 45 08             	mov    0x8(%ebp),%eax
   1037d:	8b 55 18             	mov    0x18(%ebp),%edx
   10380:	89 50 1c             	mov    %edx,0x1c(%eax)
    bitmap_init(&alloc->bitmap, bits, alloc->size / page_size, 0);
   10383:	8b 45 08             	mov    0x8(%ebp),%eax
   10386:	8b 40 24             	mov    0x24(%eax),%eax
   10389:	ba 00 00 00 00       	mov    $0x0,%edx
   1038e:	f7 75 18             	divl   0x18(%ebp)
   10391:	89 c2                	mov    %eax,%edx
   10393:	8b 45 08             	mov    0x8(%ebp),%eax
   10396:	83 c0 14             	add    $0x14,%eax
   10399:	6a 00                	push   $0x0
   1039b:	52                   	push   %edx
   1039c:	ff 75 0c             	pushl  0xc(%ebp)
   1039f:	50                   	push   %eax
   103a0:	e8 13 1a 00 00       	call   11db8 <bitmap_init>
   103a5:	83 c4 10             	add    $0x10,%esp
}
   103a8:	90                   	nop
   103a9:	c9                   	leave  
   103aa:	c3                   	ret    

000103ab <addr_alloc_page>:

/**
 * @brief 分配多页内存
 */
static uint32_t addr_alloc_page(addr_alloc_t *alloc, int page_count)
{
   103ab:	55                   	push   %ebp
   103ac:	89 e5                	mov    %esp,%ebp
   103ae:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = 0;
   103b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&alloc->mutex);
   103b8:	8b 45 08             	mov    0x8(%ebp),%eax
   103bb:	83 ec 0c             	sub    $0xc,%esp
   103be:	50                   	push   %eax
   103bf:	e8 49 17 00 00       	call   11b0d <mutex_lock>
   103c4:	83 c4 10             	add    $0x10,%esp

    int page_index = bitmap_alloc_nbits(&alloc->bitmap, 0, page_count);
   103c7:	8b 45 08             	mov    0x8(%ebp),%eax
   103ca:	83 c0 14             	add    $0x14,%eax
   103cd:	83 ec 04             	sub    $0x4,%esp
   103d0:	ff 75 0c             	pushl  0xc(%ebp)
   103d3:	6a 00                	push   $0x0
   103d5:	50                   	push   %eax
   103d6:	e8 59 1b 00 00       	call   11f34 <bitmap_alloc_nbits>
   103db:	83 c4 10             	add    $0x10,%esp
   103de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_index >= 0)
   103e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   103e5:	78 17                	js     103fe <addr_alloc_page+0x53>
    {
        addr = alloc->start + page_index * alloc->page_size;
   103e7:	8b 45 08             	mov    0x8(%ebp),%eax
   103ea:	8b 50 20             	mov    0x20(%eax),%edx
   103ed:	8b 45 08             	mov    0x8(%ebp),%eax
   103f0:	8b 48 1c             	mov    0x1c(%eax),%ecx
   103f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   103f6:	0f af c1             	imul   %ecx,%eax
   103f9:	01 d0                	add    %edx,%eax
   103fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    mutex_unlock(&alloc->mutex);
   103fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10401:	83 ec 0c             	sub    $0xc,%esp
   10404:	50                   	push   %eax
   10405:	e8 97 17 00 00       	call   11ba1 <mutex_unlock>
   1040a:	83 c4 10             	add    $0x10,%esp
    return addr;
   1040d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10410:	c9                   	leave  
   10411:	c3                   	ret    

00010412 <addr_free_page>:

/**
 * @brief 释放多页内存
 */
static void addr_free_page(addr_alloc_t *alloc, uint32_t addr, int page_count)
{
   10412:	55                   	push   %ebp
   10413:	89 e5                	mov    %esp,%ebp
   10415:	53                   	push   %ebx
   10416:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   10419:	8b 45 08             	mov    0x8(%ebp),%eax
   1041c:	83 ec 0c             	sub    $0xc,%esp
   1041f:	50                   	push   %eax
   10420:	e8 e8 16 00 00       	call   11b0d <mutex_lock>
   10425:	83 c4 10             	add    $0x10,%esp

    uint32_t pg_idx = (addr - alloc->start) / alloc->page_size;
   10428:	8b 45 08             	mov    0x8(%ebp),%eax
   1042b:	8b 40 20             	mov    0x20(%eax),%eax
   1042e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10431:	89 d1                	mov    %edx,%ecx
   10433:	29 c1                	sub    %eax,%ecx
   10435:	8b 45 08             	mov    0x8(%ebp),%eax
   10438:	8b 58 1c             	mov    0x1c(%eax),%ebx
   1043b:	89 c8                	mov    %ecx,%eax
   1043d:	ba 00 00 00 00       	mov    $0x0,%edx
   10442:	f7 f3                	div    %ebx
   10444:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap, pg_idx, page_count, 0);
   10447:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1044a:	8b 55 08             	mov    0x8(%ebp),%edx
   1044d:	83 c2 14             	add    $0x14,%edx
   10450:	6a 00                	push   $0x0
   10452:	ff 75 10             	pushl  0x10(%ebp)
   10455:	50                   	push   %eax
   10456:	52                   	push   %edx
   10457:	e8 af 19 00 00       	call   11e0b <bitmap_set_bit>
   1045c:	83 c4 10             	add    $0x10,%esp

    mutex_unlock(&alloc->mutex);
   1045f:	8b 45 08             	mov    0x8(%ebp),%eax
   10462:	83 ec 0c             	sub    $0xc,%esp
   10465:	50                   	push   %eax
   10466:	e8 36 17 00 00       	call   11ba1 <mutex_unlock>
   1046b:	83 c4 10             	add    $0x10,%esp
}
   1046e:	90                   	nop
   1046f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10472:	c9                   	leave  
   10473:	c3                   	ret    

00010474 <show_mem_info>:

static void show_mem_info(boot_info_t *boot_info)
{
   10474:	55                   	push   %ebp
   10475:	89 e5                	mov    %esp,%ebp
   10477:	83 ec 18             	sub    $0x18,%esp
    log_printf("mem region:");
   1047a:	83 ec 0c             	sub    $0xc,%esp
   1047d:	68 98 28 01 00       	push   $0x12898
   10482:	e8 32 23 00 00       	call   127b9 <log_printf>
   10487:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++)
   1048a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10491:	eb 29                	jmp    104bc <show_mem_info+0x48>
    {
        log_printf("[%d]: 0x%x - 0x%x", i,
   10493:	8b 45 08             	mov    0x8(%ebp),%eax
   10496:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10499:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   1049d:	8b 45 08             	mov    0x8(%ebp),%eax
   104a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   104a3:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   104a6:	52                   	push   %edx
   104a7:	50                   	push   %eax
   104a8:	ff 75 f4             	pushl  -0xc(%ebp)
   104ab:	68 a4 28 01 00       	push   $0x128a4
   104b0:	e8 04 23 00 00       	call   127b9 <log_printf>
   104b5:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++)
   104b8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   104bc:	8b 45 08             	mov    0x8(%ebp),%eax
   104bf:	8b 40 50             	mov    0x50(%eax),%eax
   104c2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   104c5:	7c cc                	jl     10493 <show_mem_info+0x1f>
                   boot_info->ram_region_cfg[i].start,
                   boot_info->ram_region_cfg[i].size);
    }
    log_printf("\n");
   104c7:	83 ec 0c             	sub    $0xc,%esp
   104ca:	68 b6 28 01 00       	push   $0x128b6
   104cf:	e8 e5 22 00 00       	call   127b9 <log_printf>
   104d4:	83 c4 10             	add    $0x10,%esp
}
   104d7:	90                   	nop
   104d8:	c9                   	leave  
   104d9:	c3                   	ret    

000104da <total_mem_size>:

/**
 * @brief 获取可用的物理内存大小
 */
static uint32_t total_mem_size(boot_info_t *boot_info)
{
   104da:	55                   	push   %ebp
   104db:	89 e5                	mov    %esp,%ebp
   104dd:	83 ec 10             	sub    $0x10,%esp
    int mem_size = 0;
   104e0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    // 简单起见，暂不考虑中间有空洞的情况
    for (int i = 0; i < boot_info->ram_region_count; i++)
   104e7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   104ee:	eb 16                	jmp    10506 <total_mem_size+0x2c>
    {
        mem_size += boot_info->ram_region_cfg[i].size;
   104f0:	8b 45 08             	mov    0x8(%ebp),%eax
   104f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   104f6:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   104fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   104fd:	01 d0                	add    %edx,%eax
   104ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10502:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   10506:	8b 45 08             	mov    0x8(%ebp),%eax
   10509:	8b 40 50             	mov    0x50(%eax),%eax
   1050c:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   1050f:	7c df                	jl     104f0 <total_mem_size+0x16>
    }
    return mem_size;
   10511:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10514:	c9                   	leave  
   10515:	c3                   	ret    

00010516 <find_pte>:

pte_t *find_pte(pde_t *page_dir, uint32_t vaddr, int alloc)
{
   10516:	55                   	push   %ebp
   10517:	89 e5                	mov    %esp,%ebp
   10519:	83 ec 18             	sub    $0x18,%esp
    pte_t *page_table;

    pde_t *pde = page_dir + pde_index(vaddr);
   1051c:	ff 75 0c             	pushl  0xc(%ebp)
   1051f:	e8 d3 fd ff ff       	call   102f7 <pde_index>
   10524:	83 c4 04             	add    $0x4,%esp
   10527:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1052e:	8b 45 08             	mov    0x8(%ebp),%eax
   10531:	01 d0                	add    %edx,%eax
   10533:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pde->present)
   10536:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10539:	0f b6 00             	movzbl (%eax),%eax
   1053c:	83 e0 01             	and    $0x1,%eax
   1053f:	84 c0                	test   %al,%al
   10541:	74 10                	je     10553 <find_pte+0x3d>
    {
        page_table = (pte_t *)pde_paddr(pde);
   10543:	ff 75 f0             	pushl  -0x10(%ebp)
   10546:	e8 c0 fd ff ff       	call   1030b <pde_paddr>
   1054b:	83 c4 04             	add    $0x4,%esp
   1054e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10551:	eb 57                	jmp    105aa <find_pte+0x94>
    }
    else
    {
        // 如果不存在，则考虑分配一个
        if (alloc == 0)
   10553:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10557:	75 07                	jne    10560 <find_pte+0x4a>
        {
            return (pte_t *)0;
   10559:	b8 00 00 00 00       	mov    $0x0,%eax
   1055e:	eb 64                	jmp    105c4 <find_pte+0xae>
        }

        // 分配一个物理页表
        uint32_t pg_paddr = addr_alloc_page(&paddr_alloc, 1);
   10560:	83 ec 08             	sub    $0x8,%esp
   10563:	6a 01                	push   $0x1
   10565:	68 00 40 01 00       	push   $0x14000
   1056a:	e8 3c fe ff ff       	call   103ab <addr_alloc_page>
   1056f:	83 c4 10             	add    $0x10,%esp
   10572:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (pg_paddr == 0)
   10575:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10579:	75 07                	jne    10582 <find_pte+0x6c>
        {
            return (pte_t *)0;
   1057b:	b8 00 00 00 00       	mov    $0x0,%eax
   10580:	eb 42                	jmp    105c4 <find_pte+0xae>
        }

        // 设置为用户可读写，将被pte中设置所覆盖
        pde->v = pg_paddr | PTE_P | PTE_W | PDE_U;
   10582:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10585:	83 c8 07             	or     $0x7,%eax
   10588:	89 c2                	mov    %eax,%edx
   1058a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1058d:	89 10                	mov    %edx,(%eax)
        // 为物理页表绑定虚拟地址的映射，这样下面就可以计算出虚拟地址了
        // kernel_pg_last[pde_index(vaddr)].v = pg_paddr | PTE_P | PTE_W;

        // 清空页表，防止出现异常
        // 这里虚拟地址和物理地址一一映射，所以直接写入
        page_table = (pte_t *)(pg_paddr);
   1058f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10592:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table, 0, MEM_PAGE_SIZE);
   10595:	83 ec 04             	sub    $0x4,%esp
   10598:	68 00 10 00 00       	push   $0x1000
   1059d:	6a 00                	push   $0x0
   1059f:	ff 75 f4             	pushl  -0xc(%ebp)
   105a2:	e8 06 1c 00 00       	call   121ad <kernel_memset>
   105a7:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + pte_index(vaddr);
   105aa:	83 ec 0c             	sub    $0xc,%esp
   105ad:	ff 75 0c             	pushl  0xc(%ebp)
   105b0:	e8 7d fd ff ff       	call   10332 <pte_index>
   105b5:	83 c4 10             	add    $0x10,%esp
   105b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   105c2:	01 d0                	add    %edx,%eax
}
   105c4:	c9                   	leave  
   105c5:	c3                   	ret    

000105c6 <memory_create_map>:

/**
 * @brief 将指定的地址空间进行一页的映射
 */
int memory_create_map(pde_t *page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
   105c6:	55                   	push   %ebp
   105c7:	89 e5                	mov    %esp,%ebp
   105c9:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < count; i++)
   105cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   105d3:	eb 6e                	jmp    10643 <memory_create_map+0x7d>
    {
        // log_printf("create map: v-0x%x p-0x%x, perm: 0x%x", vaddr, paddr, perm);

        pte_t *pte = find_pte(page_dir, vaddr, 1);
   105d5:	83 ec 04             	sub    $0x4,%esp
   105d8:	6a 01                	push   $0x1
   105da:	ff 75 0c             	pushl  0xc(%ebp)
   105dd:	ff 75 08             	pushl  0x8(%ebp)
   105e0:	e8 31 ff ff ff       	call   10516 <find_pte>
   105e5:	83 c4 10             	add    $0x10,%esp
   105e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pte == (pte_t *)0)
   105eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   105ef:	75 07                	jne    105f8 <memory_create_map+0x32>
        {
            // log_printf("create pte failed. pte == 0");
            return -1;
   105f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   105f6:	eb 58                	jmp    10650 <memory_create_map+0x8a>
        }

        // 创建映射的时候，这条pte应当是不存在的。
        // 如果存在，说明可能有问题
        // log_printf("\tpte addr: 0x%x", (uint32_t)pte);
        ASSERT(pte->present == 0);
   105f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105fb:	0f b6 00             	movzbl (%eax),%eax
   105fe:	83 e0 01             	and    $0x1,%eax
   10601:	84 c0                	test   %al,%al
   10603:	74 1c                	je     10621 <memory_create_map+0x5b>
   10605:	68 b8 28 01 00       	push   $0x128b8
   1060a:	68 58 29 01 00       	push   $0x12958
   1060f:	68 8d 00 00 00       	push   $0x8d
   10614:	68 cc 28 01 00       	push   $0x128cc
   10619:	e8 b8 1e 00 00       	call   124d6 <panic>
   1061e:	83 c4 10             	add    $0x10,%esp

        pte->v = paddr | perm | PTE_P;
   10621:	8b 45 10             	mov    0x10(%ebp),%eax
   10624:	0b 45 18             	or     0x18(%ebp),%eax
   10627:	83 c8 01             	or     $0x1,%eax
   1062a:	89 c2                	mov    %eax,%edx
   1062c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1062f:	89 10                	mov    %edx,(%eax)

        vaddr += MEM_PAGE_SIZE;
   10631:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   10638:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++)
   1063f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10643:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10646:	3b 45 14             	cmp    0x14(%ebp),%eax
   10649:	7c 8a                	jl     105d5 <memory_create_map+0xf>
    }

    return 0;
   1064b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10650:	c9                   	leave  
   10651:	c3                   	ret    

00010652 <create_kernel_table>:

/**
 * @brief 根据内存映射表，构造内核页表
 */
void create_kernel_table(void)
{
   10652:	55                   	push   %ebp
   10653:	89 e5                	mov    %esp,%ebp
   10655:	83 ec 28             	sub    $0x28,%esp
        // 1M以上空间扩展V\P一一映射，方便直接操作
        {(void *)MEM_EXT_START, (void *)MEM_EXT_END, (void *)MEM_EXT_START, PTE_W},
    };

    // 清空页目录表
    kernel_memset(kernel_page_dir, 0, sizeof(kernel_page_dir));
   10658:	83 ec 04             	sub    $0x4,%esp
   1065b:	68 00 10 00 00       	push   $0x1000
   10660:	6a 00                	push   $0x0
   10662:	68 00 50 01 00       	push   $0x15000
   10667:	e8 41 1b 00 00       	call   121ad <kernel_memset>
   1066c:	83 c4 10             	add    $0x10,%esp

    // 清空后，然后依次根据映射关系创建映射表
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   1066f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10676:	e9 83 00 00 00       	jmp    106fe <create_kernel_table+0xac>
    {
        memory_map_t *map = kernel_map + i;
   1067b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1067e:	c1 e0 04             	shl    $0x4,%eax
   10681:	05 00 30 01 00       	add    $0x13000,%eax
   10686:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 可能有多个页，建立多个页的配置
        // 简化起见，不考虑4M的情况
        int vstart = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   10689:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1068c:	8b 00                	mov    (%eax),%eax
   1068e:	83 ec 08             	sub    $0x8,%esp
   10691:	68 00 10 00 00       	push   $0x1000
   10696:	50                   	push   %eax
   10697:	e8 42 fc ff ff       	call   102de <down2>
   1069c:	83 c4 10             	add    $0x10,%esp
   1069f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int vend = up2((uint32_t)map->vend, MEM_PAGE_SIZE);
   106a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106a5:	8b 40 04             	mov    0x4(%eax),%eax
   106a8:	83 ec 08             	sub    $0x8,%esp
   106ab:	68 00 10 00 00       	push   $0x1000
   106b0:	50                   	push   %eax
   106b1:	e8 11 fc ff ff       	call   102c7 <up2>
   106b6:	83 c4 10             	add    $0x10,%esp
   106b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int page_count = (vend - vstart) / MEM_PAGE_SIZE;
   106bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   106bf:	2b 45 ec             	sub    -0x14(%ebp),%eax
   106c2:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
   106c8:	85 c0                	test   %eax,%eax
   106ca:	0f 48 c2             	cmovs  %edx,%eax
   106cd:	c1 f8 0c             	sar    $0xc,%eax
   106d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        memory_create_map(kernel_page_dir, vstart, (uint32_t)map->pstart, page_count, map->perm);
   106d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106d6:	8b 50 0c             	mov    0xc(%eax),%edx
   106d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106dc:	8b 40 08             	mov    0x8(%eax),%eax
   106df:	89 c1                	mov    %eax,%ecx
   106e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   106e4:	83 ec 0c             	sub    $0xc,%esp
   106e7:	52                   	push   %edx
   106e8:	ff 75 e4             	pushl  -0x1c(%ebp)
   106eb:	51                   	push   %ecx
   106ec:	50                   	push   %eax
   106ed:	68 00 50 01 00       	push   $0x15000
   106f2:	e8 cf fe ff ff       	call   105c6 <memory_create_map>
   106f7:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   106fa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10701:	83 f8 03             	cmp    $0x3,%eax
   10704:	0f 86 71 ff ff ff    	jbe    1067b <create_kernel_table+0x29>
    }
}
   1070a:	90                   	nop
   1070b:	c9                   	leave  
   1070c:	c3                   	ret    

0001070d <memory_create_uvm>:
/**
 * @brief 创建进程的初始页表
 * 主要的工作创建页目录表，然后从内核页表中复制一部分
 */
uint32_t memory_create_uvm(void)
{
   1070d:	55                   	push   %ebp
   1070e:	89 e5                	mov    %esp,%ebp
   10710:	83 ec 18             	sub    $0x18,%esp
    pde_t *page_dir = (pde_t *)addr_alloc_page(&paddr_alloc, 1);
   10713:	83 ec 08             	sub    $0x8,%esp
   10716:	6a 01                	push   $0x1
   10718:	68 00 40 01 00       	push   $0x14000
   1071d:	e8 89 fc ff ff       	call   103ab <addr_alloc_page>
   10722:	83 c4 10             	add    $0x10,%esp
   10725:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_dir == 0)
   10728:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1072c:	75 07                	jne    10735 <memory_create_uvm+0x28>
    {
        return 0;
   1072e:	b8 00 00 00 00       	mov    $0x0,%eax
   10733:	eb 5b                	jmp    10790 <memory_create_uvm+0x83>
    }
    kernel_memset((void *)page_dir, 0, MEM_PAGE_SIZE);
   10735:	83 ec 04             	sub    $0x4,%esp
   10738:	68 00 10 00 00       	push   $0x1000
   1073d:	6a 00                	push   $0x0
   1073f:	ff 75 f0             	pushl  -0x10(%ebp)
   10742:	e8 66 1a 00 00       	call   121ad <kernel_memset>
   10747:	83 c4 10             	add    $0x10,%esp

    // 复制整个内核空间的页目录项，以便与其它进程共享内核空间
    // 用户空间的内存映射暂不处理，等加载程序时创建
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   1074a:	83 ec 0c             	sub    $0xc,%esp
   1074d:	68 00 00 00 80       	push   $0x80000000
   10752:	e8 a0 fb ff ff       	call   102f7 <pde_index>
   10757:	83 c4 10             	add    $0x10,%esp
   1075a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i = 0; i < user_pde_start; i++)
   1075d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10764:	eb 1f                	jmp    10785 <memory_create_uvm+0x78>
    {
        page_dir[i].v = kernel_page_dir[i].v;
   10766:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10769:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10770:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10773:	01 c2                	add    %eax,%edx
   10775:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10778:	8b 04 85 00 50 01 00 	mov    0x15000(,%eax,4),%eax
   1077f:	89 02                	mov    %eax,(%edx)
    for (int i = 0; i < user_pde_start; i++)
   10781:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10785:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10788:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   1078b:	77 d9                	ja     10766 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   1078d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   10790:	c9                   	leave  
   10791:	c3                   	ret    

00010792 <memory_init>:
 * 该函数的主要任务：
 * 1、初始化物理内存分配器：将所有物理内存管理起来. 在1MB内存中分配物理位图
 * 2、重新创建内核页表：原loader中创建的页表已经不再合适
 */
void memory_init(boot_info_t *boot_info)
{
   10792:	55                   	push   %ebp
   10793:	89 e5                	mov    %esp,%ebp
   10795:	83 ec 18             	sub    $0x18,%esp
    extern uint8_t *mem_free_start;
    log_printf("mem init");
   10798:	83 ec 0c             	sub    $0xc,%esp
   1079b:	68 08 29 01 00       	push   $0x12908
   107a0:	e8 14 20 00 00       	call   127b9 <log_printf>
   107a5:	83 c4 10             	add    $0x10,%esp
    show_mem_info(boot_info);
   107a8:	83 ec 0c             	sub    $0xc,%esp
   107ab:	ff 75 08             	pushl  0x8(%ebp)
   107ae:	e8 c1 fc ff ff       	call   10474 <show_mem_info>
   107b3:	83 c4 10             	add    $0x10,%esp

    // 在内核数据后面放物理页位图
    uint8_t *mem_free = (uint8_t *)&mem_free_start;
   107b6:	c7 45 f4 d0 ae 01 00 	movl   $0x1aed0,-0xc(%ebp)

    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;
   107bd:	83 ec 0c             	sub    $0xc,%esp
   107c0:	ff 75 08             	pushl  0x8(%ebp)
   107c3:	e8 12 fd ff ff       	call   104da <total_mem_size>
   107c8:	83 c4 10             	add    $0x10,%esp
   107cb:	2d 00 00 10 00       	sub    $0x100000,%eax
   107d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);
   107d3:	83 ec 08             	sub    $0x8,%esp
   107d6:	68 00 10 00 00       	push   $0x1000
   107db:	ff 75 f0             	pushl  -0x10(%ebp)
   107de:	e8 fb fa ff ff       	call   102de <down2>
   107e3:	83 c4 10             	add    $0x10,%esp
   107e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    log_printf("free memory: 0x%x, size:0x%x", MEM_EXT_START, mem_up1MB_free);
   107e9:	83 ec 04             	sub    $0x4,%esp
   107ec:	ff 75 f0             	pushl  -0x10(%ebp)
   107ef:	68 00 00 10 00       	push   $0x100000
   107f4:	68 11 29 01 00       	push   $0x12911
   107f9:	e8 bb 1f 00 00       	call   127b9 <log_printf>
   107fe:	83 c4 10             	add    $0x10,%esp

    // 4GB大小需要总共4*1024*1024*1024/4096/8=128KB的位图, 使用低1MB的RAM空间中足够
    // 该部分的内存仅跟在mem_free_start开始放置
    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);
   10801:	83 ec 0c             	sub    $0xc,%esp
   10804:	68 00 10 00 00       	push   $0x1000
   10809:	ff 75 f0             	pushl  -0x10(%ebp)
   1080c:	68 00 00 10 00       	push   $0x100000
   10811:	ff 75 f4             	pushl  -0xc(%ebp)
   10814:	68 00 40 01 00       	push   $0x14000
   10819:	e8 35 fb ff ff       	call   10353 <addr_alloc_init>
   1081e:	83 c4 20             	add    $0x20,%esp
    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE); // mem_free 跳过bit的地址
   10821:	a1 24 40 01 00       	mov    0x14024,%eax
   10826:	c1 e8 0c             	shr    $0xc,%eax
   10829:	83 ec 0c             	sub    $0xc,%esp
   1082c:	50                   	push   %eax
   1082d:	e8 70 15 00 00       	call   11da2 <bitmap_byte_count>
   10832:	83 c4 10             	add    $0x10,%esp
   10835:	01 45 f4             	add    %eax,-0xc(%ebp)
    // 到这里，mem_free应该比EBDA地址要小
    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   10838:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   1083f:	76 1c                	jbe    1085d <memory_init+0xcb>
   10841:	68 30 29 01 00       	push   $0x12930
   10846:	68 6c 29 01 00       	push   $0x1296c
   1084b:	68 ec 00 00 00       	push   $0xec
   10850:	68 cc 28 01 00       	push   $0x128cc
   10855:	e8 7c 1c 00 00       	call   124d6 <panic>
   1085a:	83 c4 10             	add    $0x10,%esp

    // 创建内核页表并切换过去
    create_kernel_table();
   1085d:	e8 f0 fd ff ff       	call   10652 <create_kernel_table>
    // 先切换到当前页表
    mmu_set_page_dir((uint32_t)kernel_page_dir);
   10862:	b8 00 50 01 00       	mov    $0x15000,%eax
   10867:	83 ec 0c             	sub    $0xc,%esp
   1086a:	50                   	push   %eax
   1086b:	e8 d2 fa ff ff       	call   10342 <mmu_set_page_dir>
   10870:	83 c4 10             	add    $0x10,%esp
    // {
    //     addr_free_page(&addr_alloc, addr, 2);
    //     addr += 4096 * 2;
    //     log_printf("alloc addr: 0x%x", addr);
    // }
   10873:	90                   	nop
   10874:	c9                   	leave  
   10875:	c3                   	ret    

00010876 <list_node_init>:
/**
 * 头结点的初始化
 * @param node 待初始化的结果
 */
static inline void list_node_init(list_node_t *node)
{
   10876:	55                   	push   %ebp
   10877:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   10879:	8b 45 08             	mov    0x8(%ebp),%eax
   1087c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10883:	8b 45 08             	mov    0x8(%ebp),%eax
   10886:	8b 50 04             	mov    0x4(%eax),%edx
   10889:	8b 45 08             	mov    0x8(%ebp),%eax
   1088c:	89 10                	mov    %edx,(%eax)
}
   1088e:	90                   	nop
   1088f:	5d                   	pop    %ebp
   10890:	c3                   	ret    

00010891 <list_node_next>:
 * 获取结点的后一结点
 * @param node 查询的结点
 * @return 后继结点
 */
static inline list_node_t *list_node_next(list_node_t *node)
{
   10891:	55                   	push   %ebp
   10892:	89 e5                	mov    %esp,%ebp
    return node->next;
   10894:	8b 45 08             	mov    0x8(%ebp),%eax
   10897:	8b 40 04             	mov    0x4(%eax),%eax
}
   1089a:	5d                   	pop    %ebp
   1089b:	c3                   	ret    

0001089c <list_count>:
 * 获取链表的结点数量
 * @param list 查询的链表
 * @return 结果的数据
 */
static inline int list_count(list_t *list)
{
   1089c:	55                   	push   %ebp
   1089d:	89 e5                	mov    %esp,%ebp
    return list->count;
   1089f:	8b 45 08             	mov    0x8(%ebp),%eax
   108a2:	8b 40 08             	mov    0x8(%eax),%eax
}
   108a5:	5d                   	pop    %ebp
   108a6:	c3                   	ret    

000108a7 <list_first>:
 * 获取指定链表的第一个表项
 * @param list 查询的链表
 * @return 第一个表项
 */
static inline list_node_t *list_first(list_t *list)
{
   108a7:	55                   	push   %ebp
   108a8:	89 e5                	mov    %esp,%ebp
    return list->first;
   108aa:	8b 45 08             	mov    0x8(%ebp),%eax
   108ad:	8b 00                	mov    (%eax),%eax
}
   108af:	5d                   	pop    %ebp
   108b0:	c3                   	ret    

000108b1 <hlt>:
    uint32_t addr[] = {offset, selector};
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
}

static inline void hlt(void)
{
   108b1:	55                   	push   %ebp
   108b2:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   108b4:	f4                   	hlt    
}
   108b5:	90                   	nop
   108b6:	5d                   	pop    %ebp
   108b7:	c3                   	ret    

000108b8 <write_tr>:

// 写tss register 当前运行那个进程
static inline void write_tr(uint32_t tss_selector)
{
   108b8:	55                   	push   %ebp
   108b9:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("ltr %%ax" ::"a"(tss_selector));
   108bb:	8b 45 08             	mov    0x8(%ebp),%eax
   108be:	0f 00 d8             	ltr    %ax
}
   108c1:	90                   	nop
   108c2:	5d                   	pop    %ebp
   108c3:	c3                   	ret    

000108c4 <tss_init>:

static uint32_t idle_task_stack[1024];
static task_manager_t task_manager; // 任务管理器

static int tss_init(task_t *task, uint32_t entry, uint32_t esp)
{
   108c4:	55                   	push   %ebp
   108c5:	89 e5                	mov    %esp,%ebp
   108c7:	83 ec 18             	sub    $0x18,%esp
    int tss_sel = get_alloc_desc();
   108ca:	e8 f2 06 00 00       	call   10fc1 <get_alloc_desc>
   108cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (tss_sel < 0)
   108d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   108d6:	79 1a                	jns    108f2 <tss_init+0x2e>
    {
        log_printf("alloc tss failed.\n");
   108d8:	83 ec 0c             	sub    $0xc,%esp
   108db:	68 78 29 01 00       	push   $0x12978
   108e0:	e8 d4 1e 00 00       	call   127b9 <log_printf>
   108e5:	83 c4 10             	add    $0x10,%esp
        return -1;
   108e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   108ed:	e9 00 01 00 00       	jmp    109f2 <tss_init+0x12e>
    }

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t), SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); // 设置GDT表项内容
   108f2:	8b 45 08             	mov    0x8(%ebp),%eax
   108f5:	83 c0 48             	add    $0x48,%eax
   108f8:	68 89 00 00 00       	push   $0x89
   108fd:	6a 68                	push   $0x68
   108ff:	50                   	push   %eax
   10900:	ff 75 f4             	pushl  -0xc(%ebp)
   10903:	e8 01 06 00 00       	call   10f09 <segment_desc_set>
   10908:	83 c4 10             	add    $0x10,%esp

    // tss段初始化
    kernel_memset(&task->tss, 0, sizeof(tss_t));
   1090b:	8b 45 08             	mov    0x8(%ebp),%eax
   1090e:	83 c0 48             	add    $0x48,%eax
   10911:	83 ec 04             	sub    $0x4,%esp
   10914:	6a 68                	push   $0x68
   10916:	6a 00                	push   $0x0
   10918:	50                   	push   %eax
   10919:	e8 8f 18 00 00       	call   121ad <kernel_memset>
   1091e:	83 c4 10             	add    $0x10,%esp
    task->tss.eip = entry;
   10921:	8b 45 08             	mov    0x8(%ebp),%eax
   10924:	8b 55 0c             	mov    0xc(%ebp),%edx
   10927:	89 50 68             	mov    %edx,0x68(%eax)
    task->tss.esp = task->tss.esp0 = esp;
   1092a:	8b 45 08             	mov    0x8(%ebp),%eax
   1092d:	8b 55 10             	mov    0x10(%ebp),%edx
   10930:	89 50 4c             	mov    %edx,0x4c(%eax)
   10933:	8b 45 08             	mov    0x8(%ebp),%eax
   10936:	8b 50 4c             	mov    0x4c(%eax),%edx
   10939:	8b 45 08             	mov    0x8(%ebp),%eax
   1093c:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
    task->tss.ss = task->tss.ss0 = KERNEL_SELECTOR_DS;
   10942:	8b 45 08             	mov    0x8(%ebp),%eax
   10945:	c7 40 50 10 00 00 00 	movl   $0x10,0x50(%eax)
   1094c:	8b 45 08             	mov    0x8(%ebp),%eax
   1094f:	8b 50 50             	mov    0x50(%eax),%edx
   10952:	8b 45 08             	mov    0x8(%ebp),%eax
   10955:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = KERNEL_SELECTOR_DS;
   1095b:	8b 45 08             	mov    0x8(%ebp),%eax
   1095e:	c7 80 a4 00 00 00 10 	movl   $0x10,0xa4(%eax)
   10965:	00 00 00 
   10968:	8b 45 08             	mov    0x8(%ebp),%eax
   1096b:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   10971:	8b 45 08             	mov    0x8(%ebp),%eax
   10974:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
   1097a:	8b 45 08             	mov    0x8(%ebp),%eax
   1097d:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
   10983:	8b 45 08             	mov    0x8(%ebp),%eax
   10986:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
   1098c:	8b 45 08             	mov    0x8(%ebp),%eax
   1098f:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
   10995:	8b 45 08             	mov    0x8(%ebp),%eax
   10998:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
    task->tss.cs = KERNEL_SELECTOR_CS;
   1099e:	8b 45 08             	mov    0x8(%ebp),%eax
   109a1:	c7 80 94 00 00 00 08 	movl   $0x8,0x94(%eax)
   109a8:	00 00 00 
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
   109ab:	8b 45 08             	mov    0x8(%ebp),%eax
   109ae:	c7 40 6c 02 02 00 00 	movl   $0x202,0x6c(%eax)

    // 页表初始化
    uint32_t page_dir = memory_create_uvm();
   109b5:	e8 53 fd ff ff       	call   1070d <memory_create_uvm>
   109ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_dir == 0)
   109bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   109c1:	75 15                	jne    109d8 <tss_init+0x114>
    {
        gdt_free_sel(tss_sel);
   109c3:	83 ec 0c             	sub    $0xc,%esp
   109c6:	ff 75 f4             	pushl  -0xc(%ebp)
   109c9:	e8 ba 05 00 00       	call   10f88 <gdt_free_sel>
   109ce:	83 c4 10             	add    $0x10,%esp
        return -1;
   109d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   109d6:	eb 1a                	jmp    109f2 <tss_init+0x12e>
    }
    task->tss.cr3 = page_dir;
   109d8:	8b 45 08             	mov    0x8(%ebp),%eax
   109db:	8b 55 f0             	mov    -0x10(%ebp),%edx
   109de:	89 50 64             	mov    %edx,0x64(%eax)
    task->tss_sel = tss_sel;
   109e1:	8b 45 08             	mov    0x8(%ebp),%eax
   109e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   109e7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
    return 0;
   109ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
   109f2:	c9                   	leave  
   109f3:	c3                   	ret    

000109f4 <task_init>:

int task_init(task_t *task, const char *name, uint32_t entry, uint32_t esp)
{
   109f4:	55                   	push   %ebp
   109f5:	89 e5                	mov    %esp,%ebp
   109f7:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task_t *)0);
   109fa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   109fe:	75 19                	jne    10a19 <task_init+0x25>
   10a00:	68 8b 29 01 00       	push   $0x1298b
   10a05:	68 f0 29 01 00       	push   $0x129f0
   10a0a:	6a 2e                	push   $0x2e
   10a0c:	68 a0 29 01 00       	push   $0x129a0
   10a11:	e8 c0 1a 00 00       	call   124d6 <panic>
   10a16:	83 c4 10             	add    $0x10,%esp
    tss_init(task, entry, esp);
   10a19:	83 ec 04             	sub    $0x4,%esp
   10a1c:	ff 75 14             	pushl  0x14(%ebp)
   10a1f:	ff 75 10             	pushl  0x10(%ebp)
   10a22:	ff 75 08             	pushl  0x8(%ebp)
   10a25:	e8 9a fe ff ff       	call   108c4 <tss_init>
   10a2a:	83 c4 10             	add    $0x10,%esp

    // 任务字段初始化
    kernel_strncpy(task->name, name, TASK_NAME_SIZE);
   10a2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10a30:	83 c0 04             	add    $0x4,%eax
   10a33:	83 ec 04             	sub    $0x4,%esp
   10a36:	6a 20                	push   $0x20
   10a38:	ff 75 0c             	pushl  0xc(%ebp)
   10a3b:	50                   	push   %eax
   10a3c:	e8 f4 15 00 00       	call   12035 <kernel_strncpy>
   10a41:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_CREATED;
   10a44:	8b 45 08             	mov    0x8(%ebp),%eax
   10a47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->sleep_ticks = 0;
   10a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   10a50:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   10a57:	8b 45 08             	mov    0x8(%ebp),%eax
   10a5a:	c7 40 28 0a 00 00 00 	movl   $0xa,0x28(%eax)
    task->slice_ticks = task->time_ticks;
   10a61:	8b 45 08             	mov    0x8(%ebp),%eax
   10a64:	8b 50 28             	mov    0x28(%eax),%edx
   10a67:	8b 45 08             	mov    0x8(%ebp),%eax
   10a6a:	89 50 2c             	mov    %edx,0x2c(%eax)
    list_node_init(&task->all_node);
   10a6d:	8b 45 08             	mov    0x8(%ebp),%eax
   10a70:	83 c0 40             	add    $0x40,%eax
   10a73:	83 ec 0c             	sub    $0xc,%esp
   10a76:	50                   	push   %eax
   10a77:	e8 fa fd ff ff       	call   10876 <list_node_init>
   10a7c:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   10a7f:	8b 45 08             	mov    0x8(%ebp),%eax
   10a82:	83 c0 30             	add    $0x30,%eax
   10a85:	83 ec 0c             	sub    $0xc,%esp
   10a88:	50                   	push   %eax
   10a89:	e8 e8 fd ff ff       	call   10876 <list_node_init>
   10a8e:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   10a91:	8b 45 08             	mov    0x8(%ebp),%eax
   10a94:	83 c0 38             	add    $0x38,%eax
   10a97:	83 ec 0c             	sub    $0xc,%esp
   10a9a:	50                   	push   %eax
   10a9b:	e8 d6 fd ff ff       	call   10876 <list_node_init>
   10aa0:	83 c4 10             	add    $0x10,%esp

    irq_state_t state = irq_enter_protection();
   10aa3:	e8 25 0e 00 00       	call   118cd <irq_enter_protection>
   10aa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   10aab:	83 ec 0c             	sub    $0xc,%esp
   10aae:	ff 75 08             	pushl  0x8(%ebp)
   10ab1:	e8 01 01 00 00       	call   10bb7 <task_set_ready>
   10ab6:	83 c4 10             	add    $0x10,%esp
    list_insert_last(&task_manager.task_list, &task->all_node); // 插入所有task进队尾
   10ab9:	8b 45 08             	mov    0x8(%ebp),%eax
   10abc:	83 c0 40             	add    $0x40,%eax
   10abf:	83 ec 08             	sub    $0x8,%esp
   10ac2:	50                   	push   %eax
   10ac3:	68 10 70 01 00       	push   $0x17010
   10ac8:	e8 d6 1a 00 00       	call   125a3 <list_insert_last>
   10acd:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   10ad0:	83 ec 0c             	sub    $0xc,%esp
   10ad3:	ff 75 f4             	pushl  -0xc(%ebp)
   10ad6:	e8 0a 0e 00 00       	call   118e5 <irq_leave_protection>
   10adb:	83 c4 10             	add    $0x10,%esp
    return 0;
   10ade:	b8 00 00 00 00       	mov    $0x0,%eax
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    // }
}
   10ae3:	c9                   	leave  
   10ae4:	c3                   	ret    

00010ae5 <task_switch_from_to>:

void task_switch_from_to(task_t *from, task_t *to)
{
   10ae5:	55                   	push   %ebp
   10ae6:	89 e5                	mov    %esp,%ebp
   10ae8:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   10aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aee:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   10af4:	83 ec 0c             	sub    $0xc,%esp
   10af7:	50                   	push   %eax
   10af8:	e8 0b 06 00 00       	call   11108 <switch_to_tss>
   10afd:	83 c4 10             	add    $0x10,%esp
    // simple_switch(&from->stack, to->stack);
}
   10b00:	90                   	nop
   10b01:	c9                   	leave  
   10b02:	c3                   	ret    

00010b03 <task_first_init>:

void task_first_init(void)
{
   10b03:	55                   	push   %ebp
   10b04:	89 e5                	mov    %esp,%ebp
   10b06:	83 ec 08             	sub    $0x8,%esp
    task_init(&task_manager.first_task, "first task", 0, 0);
   10b09:	6a 00                	push   $0x0
   10b0b:	6a 00                	push   $0x0
   10b0d:	68 da 29 01 00       	push   $0x129da
   10b12:	68 28 70 01 00       	push   $0x17028
   10b17:	e8 d8 fe ff ff       	call   109f4 <task_init>
   10b1c:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = &task_manager.first_task;
   10b1f:	c7 05 00 70 01 00 28 	movl   $0x17028,0x17000
   10b26:	70 01 00 

    // 写TR寄存器，指示当前运行的第一个任务
    write_tr(task_manager.first_task.tss_sel);
   10b29:	a1 d8 70 01 00       	mov    0x170d8,%eax
   10b2e:	83 ec 0c             	sub    $0xc,%esp
   10b31:	50                   	push   %eax
   10b32:	e8 81 fd ff ff       	call   108b8 <write_tr>
   10b37:	83 c4 10             	add    $0x10,%esp
}
   10b3a:	90                   	nop
   10b3b:	c9                   	leave  
   10b3c:	c3                   	ret    

00010b3d <task_first_task>:

/**
 * @brief 返回初始任务
 */
task_t *task_first_task(void)
{
   10b3d:	55                   	push   %ebp
   10b3e:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   10b40:	b8 28 70 01 00       	mov    $0x17028,%eax
}
   10b45:	5d                   	pop    %ebp
   10b46:	c3                   	ret    

00010b47 <idle_task_entry>:

static void idle_task_entry(void)
{
   10b47:	55                   	push   %ebp
   10b48:	89 e5                	mov    %esp,%ebp
    for (;;)
    {
        hlt();
   10b4a:	e8 62 fd ff ff       	call   108b1 <hlt>
   10b4f:	eb f9                	jmp    10b4a <idle_task_entry+0x3>

00010b51 <task_manager_init>:
    }
}

void task_manager_init(void)
{
   10b51:	55                   	push   %ebp
   10b52:	89 e5                	mov    %esp,%ebp
   10b54:	83 ec 08             	sub    $0x8,%esp
    // 各队列初始化
    list_init(&task_manager.ready_list);
   10b57:	83 ec 0c             	sub    $0xc,%esp
   10b5a:	68 04 70 01 00       	push   $0x17004
   10b5f:	e8 bb 19 00 00       	call   1251f <list_init>
   10b64:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   10b67:	83 ec 0c             	sub    $0xc,%esp
   10b6a:	68 10 70 01 00       	push   $0x17010
   10b6f:	e8 ab 19 00 00       	call   1251f <list_init>
   10b74:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   10b77:	83 ec 0c             	sub    $0xc,%esp
   10b7a:	68 1c 70 01 00       	push   $0x1701c
   10b7f:	e8 9b 19 00 00       	call   1251f <list_init>
   10b84:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = (task_t *)0;
   10b87:	c7 05 00 70 01 00 00 	movl   $0x0,0x17000
   10b8e:	00 00 00 

    task_init(&task_manager.idle_task, "idle_task", (uint32_t)idle_task_entry, (uint32_t)idle_task_stack + 1024);
   10b91:	b8 00 60 01 00       	mov    $0x16000,%eax
   10b96:	05 00 04 00 00       	add    $0x400,%eax
   10b9b:	ba 47 0b 01 00       	mov    $0x10b47,%edx
   10ba0:	50                   	push   %eax
   10ba1:	52                   	push   %edx
   10ba2:	68 e5 29 01 00       	push   $0x129e5
   10ba7:	68 dc 70 01 00       	push   $0x170dc
   10bac:	e8 43 fe ff ff       	call   109f4 <task_init>
   10bb1:	83 c4 10             	add    $0x10,%esp
}
   10bb4:	90                   	nop
   10bb5:	c9                   	leave  
   10bb6:	c3                   	ret    

00010bb7 <task_set_ready>:

/**
 * @brief 将任务插入就绪队列
 */
void task_set_ready(task_t *task)
{
   10bb7:	55                   	push   %ebp
   10bb8:	89 e5                	mov    %esp,%ebp
   10bba:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   10bbd:	81 7d 08 dc 70 01 00 	cmpl   $0x170dc,0x8(%ebp)
   10bc4:	74 22                	je     10be8 <task_set_ready+0x31>
    {
        return;
    }
    list_insert_last(&task_manager.ready_list, &task->run_node);
   10bc6:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc9:	83 c0 30             	add    $0x30,%eax
   10bcc:	83 ec 08             	sub    $0x8,%esp
   10bcf:	50                   	push   %eax
   10bd0:	68 04 70 01 00       	push   $0x17004
   10bd5:	e8 c9 19 00 00       	call   125a3 <list_insert_last>
   10bda:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;
   10bdd:	8b 45 08             	mov    0x8(%ebp),%eax
   10be0:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   10be6:	eb 01                	jmp    10be9 <task_set_ready+0x32>
        return;
   10be8:	90                   	nop
}
   10be9:	c9                   	leave  
   10bea:	c3                   	ret    

00010beb <task_set_block>:

/**
 * @brief 将任务从就绪队列移除
 */
void task_set_block(task_t *task)
{
   10beb:	55                   	push   %ebp
   10bec:	89 e5                	mov    %esp,%ebp
   10bee:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   10bf1:	81 7d 08 dc 70 01 00 	cmpl   $0x170dc,0x8(%ebp)
   10bf8:	74 19                	je     10c13 <task_set_block+0x28>
    {
        return;
    }
    list_remove(&task_manager.ready_list, &task->run_node);
   10bfa:	8b 45 08             	mov    0x8(%ebp),%eax
   10bfd:	83 c0 30             	add    $0x30,%eax
   10c00:	83 ec 08             	sub    $0x8,%esp
   10c03:	50                   	push   %eax
   10c04:	68 04 70 01 00       	push   $0x17004
   10c09:	e8 71 1a 00 00       	call   1267f <list_remove>
   10c0e:	83 c4 10             	add    $0x10,%esp
   10c11:	eb 01                	jmp    10c14 <task_set_block+0x29>
        return;
   10c13:	90                   	nop
}
   10c14:	c9                   	leave  
   10c15:	c3                   	ret    

00010c16 <task_current>:

/**
 * @brief 获取当前正在运行的任务
 */
task_t *task_current(void)
{
   10c16:	55                   	push   %ebp
   10c17:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   10c19:	a1 00 70 01 00       	mov    0x17000,%eax
}
   10c1e:	5d                   	pop    %ebp
   10c1f:	c3                   	ret    

00010c20 <sys_sched_yield>:

int sys_sched_yield(void)
{
   10c20:	55                   	push   %ebp
   10c21:	89 e5                	mov    %esp,%ebp
   10c23:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   10c26:	e8 a2 0c 00 00       	call   118cd <irq_enter_protection>
   10c2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (list_count(&task_manager.ready_list) > 1)
   10c2e:	83 ec 0c             	sub    $0xc,%esp
   10c31:	68 04 70 01 00       	push   $0x17004
   10c36:	e8 61 fc ff ff       	call   1089c <list_count>
   10c3b:	83 c4 10             	add    $0x10,%esp
   10c3e:	83 f8 01             	cmp    $0x1,%eax
   10c41:	7e 29                	jle    10c6c <sys_sched_yield+0x4c>
    {
        task_t *curr_task = task_current();
   10c43:	e8 ce ff ff ff       	call   10c16 <task_current>
   10c48:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        task_set_block(curr_task);
   10c4b:	83 ec 0c             	sub    $0xc,%esp
   10c4e:	ff 75 f0             	pushl  -0x10(%ebp)
   10c51:	e8 95 ff ff ff       	call   10beb <task_set_block>
   10c56:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   10c59:	83 ec 0c             	sub    $0xc,%esp
   10c5c:	ff 75 f0             	pushl  -0x10(%ebp)
   10c5f:	e8 53 ff ff ff       	call   10bb7 <task_set_ready>
   10c64:	83 c4 10             	add    $0x10,%esp

        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
   10c67:	e8 58 00 00 00       	call   10cc4 <task_dispatch>
    }
    irq_leave_protection(state);
   10c6c:	83 ec 0c             	sub    $0xc,%esp
   10c6f:	ff 75 f4             	pushl  -0xc(%ebp)
   10c72:	e8 6e 0c 00 00       	call   118e5 <irq_leave_protection>
   10c77:	83 c4 10             	add    $0x10,%esp
    return 0;
   10c7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c7f:	c9                   	leave  
   10c80:	c3                   	ret    

00010c81 <task_next_run>:

/**
 * @brief 获取下一将要运行的任务
 */
static task_t *task_next_run(void)
{
   10c81:	55                   	push   %ebp
   10c82:	89 e5                	mov    %esp,%ebp
   10c84:	83 ec 10             	sub    $0x10,%esp
    if (list_count(&task_manager.ready_list) == 0)
   10c87:	68 04 70 01 00       	push   $0x17004
   10c8c:	e8 0b fc ff ff       	call   1089c <list_count>
   10c91:	83 c4 04             	add    $0x4,%esp
   10c94:	85 c0                	test   %eax,%eax
   10c96:	75 07                	jne    10c9f <task_next_run+0x1e>
    {
        return &task_manager.idle_task;
   10c98:	b8 dc 70 01 00       	mov    $0x170dc,%eax
   10c9d:	eb 23                	jmp    10cc2 <task_next_run+0x41>
    }

    // 普通任务
    list_node_t *task_node = list_first(&task_manager.ready_list);
   10c9f:	68 04 70 01 00       	push   $0x17004
   10ca4:	e8 fe fb ff ff       	call   108a7 <list_first>
   10ca9:	83 c4 04             	add    $0x4,%esp
   10cac:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node, task_t, run_node);
   10caf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10cb3:	74 08                	je     10cbd <task_next_run+0x3c>
   10cb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10cb8:	83 e8 30             	sub    $0x30,%eax
   10cbb:	eb 05                	jmp    10cc2 <task_next_run+0x41>
   10cbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cc2:	c9                   	leave  
   10cc3:	c3                   	ret    

00010cc4 <task_dispatch>:

/**
 * @brief 进行一次任务调度
 */
void task_dispatch(void)
{
   10cc4:	55                   	push   %ebp
   10cc5:	89 e5                	mov    %esp,%ebp
   10cc7:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   10cca:	e8 fe 0b 00 00       	call   118cd <irq_enter_protection>
   10ccf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *to = task_next_run();
   10cd2:	e8 aa ff ff ff       	call   10c81 <task_next_run>
   10cd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (to != task_manager.curr_task)
   10cda:	a1 00 70 01 00       	mov    0x17000,%eax
   10cdf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   10ce2:	74 2a                	je     10d0e <task_dispatch+0x4a>
    {
        task_t *from = task_manager.curr_task;
   10ce4:	a1 00 70 01 00       	mov    0x17000,%eax
   10ce9:	89 45 ec             	mov    %eax,-0x14(%ebp)

        task_manager.curr_task = to;
   10cec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cef:	a3 00 70 01 00       	mov    %eax,0x17000
        to->state = TASK_RUNNING;
   10cf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cf7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from, to);
   10cfd:	83 ec 08             	sub    $0x8,%esp
   10d00:	ff 75 f0             	pushl  -0x10(%ebp)
   10d03:	ff 75 ec             	pushl  -0x14(%ebp)
   10d06:	e8 da fd ff ff       	call   10ae5 <task_switch_from_to>
   10d0b:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   10d0e:	83 ec 0c             	sub    $0xc,%esp
   10d11:	ff 75 f4             	pushl  -0xc(%ebp)
   10d14:	e8 cc 0b 00 00       	call   118e5 <irq_leave_protection>
   10d19:	83 c4 10             	add    $0x10,%esp
}
   10d1c:	90                   	nop
   10d1d:	c9                   	leave  
   10d1e:	c3                   	ret    

00010d1f <task_time_tick>:
/**
 * @brief 时间处理
 * 该函数在中断处理函数中调用
 */
void task_time_tick(void)
{
   10d1f:	55                   	push   %ebp
   10d20:	89 e5                	mov    %esp,%ebp
   10d22:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   10d25:	e8 ec fe ff ff       	call   10c16 <task_current>
   10d2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_state_t state = irq_enter_protection();
   10d2d:	e8 9b 0b 00 00       	call   118cd <irq_enter_protection>
   10d32:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (--curr_task->slice_ticks == 0)
   10d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d38:	8b 40 2c             	mov    0x2c(%eax),%eax
   10d3b:	8d 50 ff             	lea    -0x1(%eax),%edx
   10d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d41:	89 50 2c             	mov    %edx,0x2c(%eax)
   10d44:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d47:	8b 40 2c             	mov    0x2c(%eax),%eax
   10d4a:	85 c0                	test   %eax,%eax
   10d4c:	75 28                	jne    10d76 <task_time_tick+0x57>
    {
        // 时间片用完，重新加载时间片
        // 对于空闲任务，此处减未用
        curr_task->slice_ticks = curr_task->time_ticks;
   10d4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d51:	8b 50 28             	mov    0x28(%eax),%edx
   10d54:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d57:	89 50 2c             	mov    %edx,0x2c(%eax)

        // 调整队列的位置到尾部，不用直接操作队列
        task_set_block(curr_task);
   10d5a:	83 ec 0c             	sub    $0xc,%esp
   10d5d:	ff 75 f0             	pushl  -0x10(%ebp)
   10d60:	e8 86 fe ff ff       	call   10beb <task_set_block>
   10d65:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   10d68:	83 ec 0c             	sub    $0xc,%esp
   10d6b:	ff 75 f0             	pushl  -0x10(%ebp)
   10d6e:	e8 44 fe ff ff       	call   10bb7 <task_set_ready>
   10d73:	83 c4 10             	add    $0x10,%esp
    }

    // 睡眠处理
    list_node_t *curr = list_first(&task_manager.sleep_list);
   10d76:	83 ec 0c             	sub    $0xc,%esp
   10d79:	68 1c 70 01 00       	push   $0x1701c
   10d7e:	e8 24 fb ff ff       	call   108a7 <list_first>
   10d83:	83 c4 10             	add    $0x10,%esp
   10d86:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   10d89:	eb 62                	jmp    10ded <task_time_tick+0xce>
    {
        list_node_t *next = list_node_next(curr);
   10d8b:	83 ec 0c             	sub    $0xc,%esp
   10d8e:	ff 75 f4             	pushl  -0xc(%ebp)
   10d91:	e8 fb fa ff ff       	call   10891 <list_node_next>
   10d96:	83 c4 10             	add    $0x10,%esp
   10d99:	89 45 e8             	mov    %eax,-0x18(%ebp)

        task_t *task = list_node_parent(curr, task_t, run_node);
   10d9c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10da0:	74 08                	je     10daa <task_time_tick+0x8b>
   10da2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10da5:	83 e8 30             	sub    $0x30,%eax
   10da8:	eb 05                	jmp    10daf <task_time_tick+0x90>
   10daa:	b8 00 00 00 00       	mov    $0x0,%eax
   10daf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (--task->sleep_ticks == 0)
   10db2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10db5:	8b 40 24             	mov    0x24(%eax),%eax
   10db8:	8d 50 ff             	lea    -0x1(%eax),%edx
   10dbb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dbe:	89 50 24             	mov    %edx,0x24(%eax)
   10dc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dc4:	8b 40 24             	mov    0x24(%eax),%eax
   10dc7:	85 c0                	test   %eax,%eax
   10dc9:	75 1c                	jne    10de7 <task_time_tick+0xc8>
        {
            // 延时时间到达，从睡眠队列中移除，送至就绪队列
            task_set_wakeup(task);
   10dcb:	83 ec 0c             	sub    $0xc,%esp
   10dce:	ff 75 e4             	pushl  -0x1c(%ebp)
   10dd1:	e8 6d 00 00 00       	call   10e43 <task_set_wakeup>
   10dd6:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   10dd9:	83 ec 0c             	sub    $0xc,%esp
   10ddc:	ff 75 e4             	pushl  -0x1c(%ebp)
   10ddf:	e8 d3 fd ff ff       	call   10bb7 <task_set_ready>
   10de4:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   10de7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10dea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   10ded:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10df1:	75 98                	jne    10d8b <task_time_tick+0x6c>
    }
    task_dispatch();
   10df3:	e8 cc fe ff ff       	call   10cc4 <task_dispatch>
    irq_leave_protection(state);
   10df8:	83 ec 0c             	sub    $0xc,%esp
   10dfb:	ff 75 ec             	pushl  -0x14(%ebp)
   10dfe:	e8 e2 0a 00 00       	call   118e5 <irq_leave_protection>
   10e03:	83 c4 10             	add    $0x10,%esp
}
   10e06:	90                   	nop
   10e07:	c9                   	leave  
   10e08:	c3                   	ret    

00010e09 <task_set_sleep>:

/**
 * @brief 将任务加入睡眠状态
 */
void task_set_sleep(task_t *task, uint32_t ticks)
{
   10e09:	55                   	push   %ebp
   10e0a:	89 e5                	mov    %esp,%ebp
   10e0c:	83 ec 08             	sub    $0x8,%esp
    if (ticks <= 0)
   10e0f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e13:	74 2b                	je     10e40 <task_set_sleep+0x37>
    {
        return;
    }

    task->sleep_ticks = ticks;
   10e15:	8b 55 0c             	mov    0xc(%ebp),%edx
   10e18:	8b 45 08             	mov    0x8(%ebp),%eax
   10e1b:	89 50 24             	mov    %edx,0x24(%eax)
    task->state = TASK_SLEEP;
   10e1e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e21:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list, &task->run_node);
   10e27:	8b 45 08             	mov    0x8(%ebp),%eax
   10e2a:	83 c0 30             	add    $0x30,%eax
   10e2d:	83 ec 08             	sub    $0x8,%esp
   10e30:	50                   	push   %eax
   10e31:	68 1c 70 01 00       	push   $0x1701c
   10e36:	e8 68 17 00 00       	call   125a3 <list_insert_last>
   10e3b:	83 c4 10             	add    $0x10,%esp
   10e3e:	eb 01                	jmp    10e41 <task_set_sleep+0x38>
        return;
   10e40:	90                   	nop
}
   10e41:	c9                   	leave  
   10e42:	c3                   	ret    

00010e43 <task_set_wakeup>:
 * @brief 将任务从延时队列移除
 *
 * @param task
 */
void task_set_wakeup(task_t *task)
{
   10e43:	55                   	push   %ebp
   10e44:	89 e5                	mov    %esp,%ebp
   10e46:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list, &task->run_node);
   10e49:	8b 45 08             	mov    0x8(%ebp),%eax
   10e4c:	83 c0 30             	add    $0x30,%eax
   10e4f:	83 ec 08             	sub    $0x8,%esp
   10e52:	50                   	push   %eax
   10e53:	68 1c 70 01 00       	push   $0x1701c
   10e58:	e8 22 18 00 00       	call   1267f <list_remove>
   10e5d:	83 c4 10             	add    $0x10,%esp
}
   10e60:	90                   	nop
   10e61:	c9                   	leave  
   10e62:	c3                   	ret    

00010e63 <sys_msleep>:
 * @brief 任务进入睡眠状态
 *
 * @param ms
 */
void sys_msleep(uint32_t ms)
{
   10e63:	55                   	push   %ebp
   10e64:	89 e5                	mov    %esp,%ebp
   10e66:	83 ec 18             	sub    $0x18,%esp
    // 至少延时1个tick
    if (ms < OS_TICK_MS)
   10e69:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   10e6d:	77 07                	ja     10e76 <sys_msleep+0x13>
    {
        ms = OS_TICK_MS;
   10e6f:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   10e76:	e8 52 0a 00 00       	call   118cd <irq_enter_protection>
   10e7b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 从就绪队列移除，加入睡眠队列
    task_set_block(task_manager.curr_task);
   10e7e:	a1 00 70 01 00       	mov    0x17000,%eax
   10e83:	83 ec 0c             	sub    $0xc,%esp
   10e86:	50                   	push   %eax
   10e87:	e8 5f fd ff ff       	call   10beb <task_set_block>
   10e8c:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   10e8f:	8b 45 08             	mov    0x8(%ebp),%eax
   10e92:	83 c0 09             	add    $0x9,%eax
   10e95:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   10e9a:	f7 e2                	mul    %edx
   10e9c:	c1 ea 03             	shr    $0x3,%edx
   10e9f:	a1 00 70 01 00       	mov    0x17000,%eax
   10ea4:	83 ec 08             	sub    $0x8,%esp
   10ea7:	52                   	push   %edx
   10ea8:	50                   	push   %eax
   10ea9:	e8 5b ff ff ff       	call   10e09 <task_set_sleep>
   10eae:	83 c4 10             	add    $0x10,%esp

    // 进行一次调度
    task_dispatch();
   10eb1:	e8 0e fe ff ff       	call   10cc4 <task_dispatch>

    irq_leave_protection(state);
   10eb6:	83 ec 0c             	sub    $0xc,%esp
   10eb9:	ff 75 f4             	pushl  -0xc(%ebp)
   10ebc:	e8 24 0a 00 00       	call   118e5 <irq_leave_protection>
   10ec1:	83 c4 10             	add    $0x10,%esp
   10ec4:	90                   	nop
   10ec5:	c9                   	leave  
   10ec6:	c3                   	ret    

00010ec7 <lgdt>:
{
   10ec7:	55                   	push   %ebp
   10ec8:	89 e5                	mov    %esp,%ebp
   10eca:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   10ecd:	8b 45 08             	mov    0x8(%ebp),%eax
   10ed0:	c1 e8 10             	shr    $0x10,%eax
   10ed3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   10ed7:	8b 45 08             	mov    0x8(%ebp),%eax
   10eda:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   10ede:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ee1:	83 e8 01             	sub    $0x1,%eax
   10ee4:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]" ::[g] "m"(gdt));
   10ee8:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   10eec:	90                   	nop
   10eed:	c9                   	leave  
   10eee:	c3                   	ret    

00010eef <far_jump>:
{
   10eef:	55                   	push   %ebp
   10ef0:	89 e5                	mov    %esp,%ebp
   10ef2:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset, selector};
   10ef5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ef8:	89 45 f8             	mov    %eax,-0x8(%ebp)
   10efb:	8b 45 08             	mov    0x8(%ebp),%eax
   10efe:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
   10f01:	8d 45 f8             	lea    -0x8(%ebp),%eax
   10f04:	ff 28                	ljmp   *(%eax)
}
   10f06:	90                   	nop
   10f07:	c9                   	leave  
   10f08:	c3                   	ret    

00010f09 <segment_desc_set>:

static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;

void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   10f09:	55                   	push   %ebp
   10f0a:	89 e5                	mov    %esp,%ebp
   10f0c:	83 ec 14             	sub    $0x14,%esp
   10f0f:	8b 45 14             	mov    0x14(%ebp),%eax
   10f12:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + (selector / sizeof(segment_desc_t)); //
   10f16:	8b 45 08             	mov    0x8(%ebp),%eax
   10f19:	83 e0 f8             	and    $0xfffffff8,%eax
   10f1c:	05 a0 71 01 00       	add    $0x171a0,%eax
   10f21:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置limit单位为4kB
    if (limit > 0xFFFF)
   10f24:	81 7d 10 ff ff 00 00 	cmpl   $0xffff,0x10(%ebp)
   10f2b:	76 0f                	jbe    10f3c <segment_desc_set+0x33>
    {
        attr |= SEG_G; // G 标志位
   10f2d:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit /= 0x1000;
   10f33:	8b 45 10             	mov    0x10(%ebp),%eax
   10f36:	c1 e8 0c             	shr    $0xc,%eax
   10f39:	89 45 10             	mov    %eax,0x10(%ebp)
    }

    desc->limit15_0 = limit & 0xFFFF;
   10f3c:	8b 45 10             	mov    0x10(%ebp),%eax
   10f3f:	89 c2                	mov    %eax,%edx
   10f41:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f44:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xFFFF;
   10f47:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f4a:	89 c2                	mov    %eax,%edx
   10f4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f4f:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xFF;
   10f53:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f56:	c1 e8 10             	shr    $0x10,%eax
   10f59:	89 c2                	mov    %eax,%edx
   10f5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f5e:	88 50 04             	mov    %dl,0x4(%eax)
    desc->base31_24 = (base >> 24) & 0xFF;
   10f61:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f64:	c1 e8 18             	shr    $0x18,%eax
   10f67:	89 c2                	mov    %eax,%edx
   10f69:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f6c:	88 50 07             	mov    %dl,0x7(%eax)
    desc->attr = attr | (((limit >> 16) & 0xFF) << 8);
   10f6f:	8b 45 10             	mov    0x10(%ebp),%eax
   10f72:	c1 e8 10             	shr    $0x10,%eax
   10f75:	c1 e0 08             	shl    $0x8,%eax
   10f78:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   10f7c:	89 c2                	mov    %eax,%edx
   10f7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f81:	66 89 50 05          	mov    %dx,0x5(%eax)
}
   10f85:	90                   	nop
   10f86:	c9                   	leave  
   10f87:	c3                   	ret    

00010f88 <gdt_free_sel>:

void gdt_free_sel(int sel)
{
   10f88:	55                   	push   %ebp
   10f89:	89 e5                	mov    %esp,%ebp
   10f8b:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   10f8e:	83 ec 0c             	sub    $0xc,%esp
   10f91:	68 a0 79 01 00       	push   $0x179a0
   10f96:	e8 72 0b 00 00       	call   11b0d <mutex_lock>
   10f9b:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel / sizeof(segment_desc_t)].attr = 0;
   10f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   10fa1:	c1 e8 03             	shr    $0x3,%eax
   10fa4:	66 c7 04 c5 a5 71 01 	movw   $0x0,0x171a5(,%eax,8)
   10fab:	00 00 00 
    mutex_unlock(&mutex);
   10fae:	83 ec 0c             	sub    $0xc,%esp
   10fb1:	68 a0 79 01 00       	push   $0x179a0
   10fb6:	e8 e6 0b 00 00       	call   11ba1 <mutex_unlock>
   10fbb:	83 c4 10             	add    $0x10,%esp
}
   10fbe:	90                   	nop
   10fbf:	c9                   	leave  
   10fc0:	c3                   	ret    

00010fc1 <get_alloc_desc>:

int get_alloc_desc()
{
   10fc1:	55                   	push   %ebp
   10fc2:	89 e5                	mov    %esp,%ebp
   10fc4:	83 ec 18             	sub    $0x18,%esp
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   10fc7:	83 ec 0c             	sub    $0xc,%esp
   10fca:	68 a0 79 01 00       	push   $0x179a0
   10fcf:	e8 39 0b 00 00       	call   11b0d <mutex_lock>
   10fd4:	83 c4 10             	add    $0x10,%esp

    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   10fd7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   10fde:	eb 36                	jmp    11016 <get_alloc_desc+0x55>
    {
        segment_desc_t *desc = gdt_table + i;
   10fe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fe3:	c1 e0 03             	shl    $0x3,%eax
   10fe6:	05 a0 71 01 00       	add    $0x171a0,%eax
   10feb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (desc->attr == 0) // 根据属性是否为0判断
   10fee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ff1:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   10ff5:	66 85 c0             	test   %ax,%ax
   10ff8:	75 18                	jne    11012 <get_alloc_desc+0x51>
        {
            // irq_leave_protection(state);
            mutex_unlock(&mutex);
   10ffa:	83 ec 0c             	sub    $0xc,%esp
   10ffd:	68 a0 79 01 00       	push   $0x179a0
   11002:	e8 9a 0b 00 00       	call   11ba1 <mutex_unlock>
   11007:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   1100a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1100d:	c1 e0 03             	shl    $0x3,%eax
   11010:	eb 22                	jmp    11034 <get_alloc_desc+0x73>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   11012:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11016:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1101d:	7e c1                	jle    10fe0 <get_alloc_desc+0x1f>
        }
    }
    // irq_leave_protection(state);
    mutex_unlock(&mutex);
   1101f:	83 ec 0c             	sub    $0xc,%esp
   11022:	68 a0 79 01 00       	push   $0x179a0
   11027:	e8 75 0b 00 00       	call   11ba1 <mutex_unlock>
   1102c:	83 c4 10             	add    $0x10,%esp
    return -1;
   1102f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11034:	c9                   	leave  
   11035:	c3                   	ret    

00011036 <init_gdt>:

void init_gdt(void)
{
   11036:	55                   	push   %ebp
   11037:	89 e5                	mov    %esp,%ebp
   11039:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   1103c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11043:	eb 19                	jmp    1105e <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0); // 找到第几个GDT表项
   11045:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11048:	c1 e0 03             	shl    $0x3,%eax
   1104b:	6a 00                	push   $0x0
   1104d:	6a 00                	push   $0x0
   1104f:	6a 00                	push   $0x0
   11051:	50                   	push   %eax
   11052:	e8 b2 fe ff ff       	call   10f09 <segment_desc_set>
   11057:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   1105a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1105e:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   11065:	7e de                	jle    11045 <init_gdt+0xf>
    }
    // 数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xFFFFFFFF,
   11067:	68 92 40 00 00       	push   $0x4092
   1106c:	6a ff                	push   $0xffffffff
   1106e:	6a 00                	push   $0x0
   11070:	6a 10                	push   $0x10
   11072:	e8 92 fe ff ff       	call   10f09 <segment_desc_set>
   11077:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    // 代码段
    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xFFFFFFFF,
   1107a:	68 9a 40 00 00       	push   $0x409a
   1107f:	6a ff                	push   $0xffffffff
   11081:	6a 00                	push   $0x0
   11083:	6a 08                	push   $0x8
   11085:	e8 7f fe ff ff       	call   10f09 <segment_desc_set>
   1108a:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);

    // 重新加载GDT
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   1108d:	b8 a0 71 01 00       	mov    $0x171a0,%eax
   11092:	68 00 08 00 00       	push   $0x800
   11097:	50                   	push   %eax
   11098:	e8 2a fe ff ff       	call   10ec7 <lgdt>
   1109d:	83 c4 08             	add    $0x8,%esp
}
   110a0:	90                   	nop
   110a1:	c9                   	leave  
   110a2:	c3                   	ret    

000110a3 <gate_desc_set>:

void gate_desc_set(gate_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   110a3:	55                   	push   %ebp
   110a4:	89 e5                	mov    %esp,%ebp
   110a6:	83 ec 08             	sub    $0x8,%esp
   110a9:	8b 55 0c             	mov    0xc(%ebp),%edx
   110ac:	8b 45 14             	mov    0x14(%ebp),%eax
   110af:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   110b3:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0 = offset & 0xFFFF;
   110b7:	8b 45 10             	mov    0x10(%ebp),%eax
   110ba:	89 c2                	mov    %eax,%edx
   110bc:	8b 45 08             	mov    0x8(%ebp),%eax
   110bf:	66 89 10             	mov    %dx,(%eax)
    desc->selector = selector;
   110c2:	8b 45 08             	mov    0x8(%ebp),%eax
   110c5:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   110c9:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr = attr;
   110cd:	8b 45 08             	mov    0x8(%ebp),%eax
   110d0:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   110d4:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16 = (offset >> 16) & 0xFFFFF;
   110d8:	8b 45 10             	mov    0x10(%ebp),%eax
   110db:	c1 e8 10             	shr    $0x10,%eax
   110de:	89 c2                	mov    %eax,%edx
   110e0:	8b 45 08             	mov    0x8(%ebp),%eax
   110e3:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   110e7:	90                   	nop
   110e8:	c9                   	leave  
   110e9:	c3                   	ret    

000110ea <cpu_init>:

void cpu_init(void)
{
   110ea:	55                   	push   %ebp
   110eb:	89 e5                	mov    %esp,%ebp
   110ed:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   110f0:	83 ec 0c             	sub    $0xc,%esp
   110f3:	68 a0 79 01 00       	push   $0x179a0
   110f8:	e8 e2 09 00 00       	call   11adf <mutex_init>
   110fd:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   11100:	e8 31 ff ff ff       	call   11036 <init_gdt>
}
   11105:	90                   	nop
   11106:	c9                   	leave  
   11107:	c3                   	ret    

00011108 <switch_to_tss>:

void switch_to_tss(uint32_t tss_selector)
{
   11108:	55                   	push   %ebp
   11109:	89 e5                	mov    %esp,%ebp
    far_jump(tss_selector, 0);
   1110b:	6a 00                	push   $0x0
   1110d:	ff 75 08             	pushl  0x8(%ebp)
   11110:	e8 da fd ff ff       	call   10eef <far_jump>
   11115:	83 c4 08             	add    $0x8,%esp
   11118:	90                   	nop
   11119:	c9                   	leave  
   1111a:	c3                   	ret    

0001111b <inb>:
{
   1111b:	55                   	push   %ebp
   1111c:	89 e5                	mov    %esp,%ebp
   1111e:	83 ec 14             	sub    $0x14,%esp
   11121:	8b 45 08             	mov    0x8(%ebp),%eax
   11124:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   11128:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1112c:	89 c2                	mov    %eax,%edx
   1112e:	ec                   	in     (%dx),%al
   1112f:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   11132:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   11136:	c9                   	leave  
   11137:	c3                   	ret    

00011138 <outb>:
{
   11138:	55                   	push   %ebp
   11139:	89 e5                	mov    %esp,%ebp
   1113b:	83 ec 08             	sub    $0x8,%esp
   1113e:	8b 55 08             	mov    0x8(%ebp),%edx
   11141:	8b 45 0c             	mov    0xc(%ebp),%eax
   11144:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   11148:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   1114b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1114f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   11153:	ee                   	out    %al,(%dx)
}
   11154:	90                   	nop
   11155:	c9                   	leave  
   11156:	c3                   	ret    

00011157 <cli>:
{
   11157:	55                   	push   %ebp
   11158:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   1115a:	fa                   	cli    
}
   1115b:	90                   	nop
   1115c:	5d                   	pop    %ebp
   1115d:	c3                   	ret    

0001115e <sti>:
{
   1115e:	55                   	push   %ebp
   1115f:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   11161:	fb                   	sti    
}
   11162:	90                   	nop
   11163:	5d                   	pop    %ebp
   11164:	c3                   	ret    

00011165 <lidt>:
{
   11165:	55                   	push   %ebp
   11166:	89 e5                	mov    %esp,%ebp
   11168:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   1116b:	8b 45 08             	mov    0x8(%ebp),%eax
   1116e:	c1 e8 10             	shr    $0x10,%eax
   11171:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xFFFF;
   11175:	8b 45 08             	mov    0x8(%ebp),%eax
   11178:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   1117c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1117f:	83 e8 01             	sub    $0x1,%eax
   11182:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[g]" ::[g] "m"(idt));
   11186:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   1118a:	90                   	nop
   1118b:	c9                   	leave  
   1118c:	c3                   	ret    

0001118d <hlt>:
{
   1118d:	55                   	push   %ebp
   1118e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   11190:	f4                   	hlt    
}
   11191:	90                   	nop
   11192:	5d                   	pop    %ebp
   11193:	c3                   	ret    

00011194 <read_eflags>:

static inline uint32_t read_eflags(void)
{
   11194:	55                   	push   %ebp
   11195:	89 e5                	mov    %esp,%ebp
   11197:	83 ec 10             	sub    $0x10,%esp
    uint32_t eflags;

    __asm__ __volatile__("pushfl\n\tpopl %%eax" : "=a"(eflags));
   1119a:	9c                   	pushf  
   1119b:	58                   	pop    %eax
   1119c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   1119f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   111a2:	c9                   	leave  
   111a3:	c3                   	ret    

000111a4 <write_eflags>:

static inline void write_eflags(uint32_t eflags)
{
   111a4:	55                   	push   %ebp
   111a5:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("pushl %%eax\n\tpopfl" ::"a"(eflags));
   111a7:	8b 45 08             	mov    0x8(%ebp),%eax
   111aa:	50                   	push   %eax
   111ab:	9d                   	popf   
}
   111ac:	90                   	nop
   111ad:	5d                   	pop    %ebp
   111ae:	c3                   	ret    

000111af <dump_core_regs>:
#define IDT_TABLE_NR 128

static gate_desc_t idt_table[IDT_TABLE_NR];

static void dump_core_regs(exception_frame_t *frame)
{
   111af:	55                   	push   %ebp
   111b0:	89 e5                	mov    %esp,%ebp
   111b2:	57                   	push   %edi
   111b3:	56                   	push   %esi
   111b4:	53                   	push   %ebx
   111b5:	83 ec 1c             	sub    $0x1c,%esp
    // 打印CPU寄存器相关内容
    log_printf("IRQ: %d, error code: %d.", frame->num, frame->err_code);
   111b8:	8b 45 08             	mov    0x8(%ebp),%eax
   111bb:	8b 50 34             	mov    0x34(%eax),%edx
   111be:	8b 45 08             	mov    0x8(%ebp),%eax
   111c1:	8b 40 30             	mov    0x30(%eax),%eax
   111c4:	83 ec 04             	sub    $0x4,%esp
   111c7:	52                   	push   %edx
   111c8:	50                   	push   %eax
   111c9:	68 fc 29 01 00       	push   $0x129fc
   111ce:	e8 e6 15 00 00       	call   127b9 <log_printf>
   111d3:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS:%d\nGS:%d",
   111d6:	8b 45 08             	mov    0x8(%ebp),%eax
   111d9:	8b 30                	mov    (%eax),%esi
   111db:	8b 45 08             	mov    0x8(%ebp),%eax
   111de:	8b 58 04             	mov    0x4(%eax),%ebx
   111e1:	8b 45 08             	mov    0x8(%ebp),%eax
   111e4:	8b 48 08             	mov    0x8(%eax),%ecx
   111e7:	8b 45 08             	mov    0x8(%ebp),%eax
   111ea:	8b 50 0c             	mov    0xc(%eax),%edx
   111ed:	8b 45 08             	mov    0x8(%ebp),%eax
   111f0:	8b 40 3c             	mov    0x3c(%eax),%eax
   111f3:	83 ec 08             	sub    $0x8,%esp
   111f6:	56                   	push   %esi
   111f7:	53                   	push   %ebx
   111f8:	51                   	push   %ecx
   111f9:	52                   	push   %edx
   111fa:	50                   	push   %eax
   111fb:	68 18 2a 01 00       	push   $0x12a18
   11200:	e8 b4 15 00 00       	call   127b9 <log_printf>
   11205:	83 c4 20             	add    $0x20,%esp
               frame->cs, frame->ds, frame->es, frame->fs, frame->gs);
    log_printf("EAX:0x%x\n"
   11208:	8b 45 08             	mov    0x8(%ebp),%eax
   1120b:	8b 48 1c             	mov    0x1c(%eax),%ecx
   1120e:	8b 45 08             	mov    0x8(%ebp),%eax
   11211:	8b 40 18             	mov    0x18(%eax),%eax
   11214:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   11217:	8b 45 08             	mov    0x8(%ebp),%eax
   1121a:	8b 78 14             	mov    0x14(%eax),%edi
   1121d:	89 7d e0             	mov    %edi,-0x20(%ebp)
   11220:	8b 45 08             	mov    0x8(%ebp),%eax
   11223:	8b 78 10             	mov    0x10(%eax),%edi
   11226:	8b 45 08             	mov    0x8(%ebp),%eax
   11229:	8b 70 24             	mov    0x24(%eax),%esi
   1122c:	8b 45 08             	mov    0x8(%ebp),%eax
   1122f:	8b 58 28             	mov    0x28(%eax),%ebx
   11232:	8b 45 08             	mov    0x8(%ebp),%eax
   11235:	8b 50 20             	mov    0x20(%eax),%edx
   11238:	8b 45 08             	mov    0x8(%ebp),%eax
   1123b:	8b 40 2c             	mov    0x2c(%eax),%eax
   1123e:	83 ec 0c             	sub    $0xc,%esp
   11241:	51                   	push   %ecx
   11242:	ff 75 e4             	pushl  -0x1c(%ebp)
   11245:	ff 75 e0             	pushl  -0x20(%ebp)
   11248:	57                   	push   %edi
   11249:	56                   	push   %esi
   1124a:	53                   	push   %ebx
   1124b:	52                   	push   %edx
   1124c:	50                   	push   %eax
   1124d:	68 40 2a 01 00       	push   $0x12a40
   11252:	e8 62 15 00 00       	call   127b9 <log_printf>
   11257:	83 c4 30             	add    $0x30,%esp
               "ESI:0x%x\n"
               "EBP:0x%x\n"
               "ESP:0x%x\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, frame->esp);
    log_printf("EIP:0x%x\nEFLAGS:0x%x\n", frame->eip, frame->eflags);
   1125a:	8b 45 08             	mov    0x8(%ebp),%eax
   1125d:	8b 50 40             	mov    0x40(%eax),%edx
   11260:	8b 45 08             	mov    0x8(%ebp),%eax
   11263:	8b 40 38             	mov    0x38(%eax),%eax
   11266:	83 ec 04             	sub    $0x4,%esp
   11269:	52                   	push   %edx
   1126a:	50                   	push   %eax
   1126b:	68 89 2a 01 00       	push   $0x12a89
   11270:	e8 44 15 00 00       	call   127b9 <log_printf>
   11275:	83 c4 10             	add    $0x10,%esp
}
   11278:	90                   	nop
   11279:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1127c:	5b                   	pop    %ebx
   1127d:	5e                   	pop    %esi
   1127e:	5f                   	pop    %edi
   1127f:	5d                   	pop    %ebp
   11280:	c3                   	ret    

00011281 <do_default_handler>:

static void do_default_handler(exception_frame_t *frame, const char *msg)
{
   11281:	55                   	push   %ebp
   11282:	89 e5                	mov    %esp,%ebp
   11284:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   11287:	83 ec 0c             	sub    $0xc,%esp
   1128a:	68 a0 2a 01 00       	push   $0x12aa0
   1128f:	e8 25 15 00 00       	call   127b9 <log_printf>
   11294:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s.", msg);
   11297:	83 ec 08             	sub    $0x8,%esp
   1129a:	ff 75 0c             	pushl  0xc(%ebp)
   1129d:	68 c1 2a 01 00       	push   $0x12ac1
   112a2:	e8 12 15 00 00       	call   127b9 <log_printf>
   112a7:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame); // 打印寄存器
   112aa:	83 ec 0c             	sub    $0xc,%esp
   112ad:	ff 75 08             	pushl  0x8(%ebp)
   112b0:	e8 fa fe ff ff       	call   111af <dump_core_regs>
   112b5:	83 c4 10             	add    $0x10,%esp
    log_printf("--------------------------------");
   112b8:	83 ec 0c             	sub    $0xc,%esp
   112bb:	68 a0 2a 01 00       	push   $0x12aa0
   112c0:	e8 f4 14 00 00       	call   127b9 <log_printf>
   112c5:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   112c8:	e8 c0 fe ff ff       	call   1118d <hlt>
   112cd:	eb f9                	jmp    112c8 <do_default_handler+0x47>

000112cf <do_handler_unknown>:
    }
}

void do_handler_unknown(exception_frame_t *frame)
{
   112cf:	55                   	push   %ebp
   112d0:	89 e5                	mov    %esp,%ebp
   112d2:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "unknown exception");
   112d5:	83 ec 08             	sub    $0x8,%esp
   112d8:	68 dc 2a 01 00       	push   $0x12adc
   112dd:	ff 75 08             	pushl  0x8(%ebp)
   112e0:	e8 9c ff ff ff       	call   11281 <do_default_handler>
   112e5:	83 c4 10             	add    $0x10,%esp
}
   112e8:	90                   	nop
   112e9:	c9                   	leave  
   112ea:	c3                   	ret    

000112eb <do_handler_divider>:

void do_handler_divider(exception_frame_t *frame)
{
   112eb:	55                   	push   %ebp
   112ec:	89 e5                	mov    %esp,%ebp
   112ee:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "divider exception");
   112f1:	83 ec 08             	sub    $0x8,%esp
   112f4:	68 ee 2a 01 00       	push   $0x12aee
   112f9:	ff 75 08             	pushl  0x8(%ebp)
   112fc:	e8 80 ff ff ff       	call   11281 <do_default_handler>
   11301:	83 c4 10             	add    $0x10,%esp
}
   11304:	90                   	nop
   11305:	c9                   	leave  
   11306:	c3                   	ret    

00011307 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t *frame)
{
   11307:	55                   	push   %ebp
   11308:	89 e5                	mov    %esp,%ebp
   1130a:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Debug Exception");
   1130d:	83 ec 08             	sub    $0x8,%esp
   11310:	68 00 2b 01 00       	push   $0x12b00
   11315:	ff 75 08             	pushl  0x8(%ebp)
   11318:	e8 64 ff ff ff       	call   11281 <do_default_handler>
   1131d:	83 c4 10             	add    $0x10,%esp
}
   11320:	90                   	nop
   11321:	c9                   	leave  
   11322:	c3                   	ret    

00011323 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t *frame)
{
   11323:	55                   	push   %ebp
   11324:	89 e5                	mov    %esp,%ebp
   11326:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "NMI Interrupt.");
   11329:	83 ec 08             	sub    $0x8,%esp
   1132c:	68 10 2b 01 00       	push   $0x12b10
   11331:	ff 75 08             	pushl  0x8(%ebp)
   11334:	e8 48 ff ff ff       	call   11281 <do_default_handler>
   11339:	83 c4 10             	add    $0x10,%esp
}
   1133c:	90                   	nop
   1133d:	c9                   	leave  
   1133e:	c3                   	ret    

0001133f <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t *frame)
{
   1133f:	55                   	push   %ebp
   11340:	89 e5                	mov    %esp,%ebp
   11342:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Breakpoint.");
   11345:	83 ec 08             	sub    $0x8,%esp
   11348:	68 1f 2b 01 00       	push   $0x12b1f
   1134d:	ff 75 08             	pushl  0x8(%ebp)
   11350:	e8 2c ff ff ff       	call   11281 <do_default_handler>
   11355:	83 c4 10             	add    $0x10,%esp
}
   11358:	90                   	nop
   11359:	c9                   	leave  
   1135a:	c3                   	ret    

0001135b <do_handler_overflow>:

void do_handler_overflow(exception_frame_t *frame)
{
   1135b:	55                   	push   %ebp
   1135c:	89 e5                	mov    %esp,%ebp
   1135e:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Overflow.");
   11361:	83 ec 08             	sub    $0x8,%esp
   11364:	68 2b 2b 01 00       	push   $0x12b2b
   11369:	ff 75 08             	pushl  0x8(%ebp)
   1136c:	e8 10 ff ff ff       	call   11281 <do_default_handler>
   11371:	83 c4 10             	add    $0x10,%esp
}
   11374:	90                   	nop
   11375:	c9                   	leave  
   11376:	c3                   	ret    

00011377 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t *frame)
{
   11377:	55                   	push   %ebp
   11378:	89 e5                	mov    %esp,%ebp
   1137a:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "BOUND Range Exceeded.");
   1137d:	83 ec 08             	sub    $0x8,%esp
   11380:	68 35 2b 01 00       	push   $0x12b35
   11385:	ff 75 08             	pushl  0x8(%ebp)
   11388:	e8 f4 fe ff ff       	call   11281 <do_default_handler>
   1138d:	83 c4 10             	add    $0x10,%esp
}
   11390:	90                   	nop
   11391:	c9                   	leave  
   11392:	c3                   	ret    

00011393 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t *frame)
{
   11393:	55                   	push   %ebp
   11394:	89 e5                	mov    %esp,%ebp
   11396:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid Opcode.");
   11399:	83 ec 08             	sub    $0x8,%esp
   1139c:	68 4b 2b 01 00       	push   $0x12b4b
   113a1:	ff 75 08             	pushl  0x8(%ebp)
   113a4:	e8 d8 fe ff ff       	call   11281 <do_default_handler>
   113a9:	83 c4 10             	add    $0x10,%esp
}
   113ac:	90                   	nop
   113ad:	c9                   	leave  
   113ae:	c3                   	ret    

000113af <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t *frame)
{
   113af:	55                   	push   %ebp
   113b0:	89 e5                	mov    %esp,%ebp
   113b2:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Device Not Available.");
   113b5:	83 ec 08             	sub    $0x8,%esp
   113b8:	68 5b 2b 01 00       	push   $0x12b5b
   113bd:	ff 75 08             	pushl  0x8(%ebp)
   113c0:	e8 bc fe ff ff       	call   11281 <do_default_handler>
   113c5:	83 c4 10             	add    $0x10,%esp
}
   113c8:	90                   	nop
   113c9:	c9                   	leave  
   113ca:	c3                   	ret    

000113cb <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t *frame)
{
   113cb:	55                   	push   %ebp
   113cc:	89 e5                	mov    %esp,%ebp
   113ce:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Double Fault.");
   113d1:	83 ec 08             	sub    $0x8,%esp
   113d4:	68 71 2b 01 00       	push   $0x12b71
   113d9:	ff 75 08             	pushl  0x8(%ebp)
   113dc:	e8 a0 fe ff ff       	call   11281 <do_default_handler>
   113e1:	83 c4 10             	add    $0x10,%esp
}
   113e4:	90                   	nop
   113e5:	c9                   	leave  
   113e6:	c3                   	ret    

000113e7 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t *frame)
{
   113e7:	55                   	push   %ebp
   113e8:	89 e5                	mov    %esp,%ebp
   113ea:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid TSS");
   113ed:	83 ec 08             	sub    $0x8,%esp
   113f0:	68 7f 2b 01 00       	push   $0x12b7f
   113f5:	ff 75 08             	pushl  0x8(%ebp)
   113f8:	e8 84 fe ff ff       	call   11281 <do_default_handler>
   113fd:	83 c4 10             	add    $0x10,%esp
}
   11400:	90                   	nop
   11401:	c9                   	leave  
   11402:	c3                   	ret    

00011403 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t *frame)
{
   11403:	55                   	push   %ebp
   11404:	89 e5                	mov    %esp,%ebp
   11406:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Segment Not Present.");
   11409:	83 ec 08             	sub    $0x8,%esp
   1140c:	68 8b 2b 01 00       	push   $0x12b8b
   11411:	ff 75 08             	pushl  0x8(%ebp)
   11414:	e8 68 fe ff ff       	call   11281 <do_default_handler>
   11419:	83 c4 10             	add    $0x10,%esp
}
   1141c:	90                   	nop
   1141d:	c9                   	leave  
   1141e:	c3                   	ret    

0001141f <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   1141f:	55                   	push   %ebp
   11420:	89 e5                	mov    %esp,%ebp
   11422:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Stack-Segment Fault.");
   11425:	83 ec 08             	sub    $0x8,%esp
   11428:	68 a0 2b 01 00       	push   $0x12ba0
   1142d:	ff 75 08             	pushl  0x8(%ebp)
   11430:	e8 4c fe ff ff       	call   11281 <do_default_handler>
   11435:	83 c4 10             	add    $0x10,%esp
}
   11438:	90                   	nop
   11439:	c9                   	leave  
   1143a:	c3                   	ret    

0001143b <do_handler_fpu_error>:

void do_handler_fpu_error(exception_frame_t *frame)
{
   1143b:	55                   	push   %ebp
   1143c:	89 e5                	mov    %esp,%ebp
   1143e:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "X87 FPU Floating Point Error.");
   11441:	83 ec 08             	sub    $0x8,%esp
   11444:	68 b5 2b 01 00       	push   $0x12bb5
   11449:	ff 75 08             	pushl  0x8(%ebp)
   1144c:	e8 30 fe ff ff       	call   11281 <do_default_handler>
   11451:	83 c4 10             	add    $0x10,%esp
}
   11454:	90                   	nop
   11455:	c9                   	leave  
   11456:	c3                   	ret    

00011457 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t *frame)
{
   11457:	55                   	push   %ebp
   11458:	89 e5                	mov    %esp,%ebp
   1145a:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Alignment Check.");
   1145d:	83 ec 08             	sub    $0x8,%esp
   11460:	68 d3 2b 01 00       	push   $0x12bd3
   11465:	ff 75 08             	pushl  0x8(%ebp)
   11468:	e8 14 fe ff ff       	call   11281 <do_default_handler>
   1146d:	83 c4 10             	add    $0x10,%esp
}
   11470:	90                   	nop
   11471:	c9                   	leave  
   11472:	c3                   	ret    

00011473 <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t *frame)
{
   11473:	55                   	push   %ebp
   11474:	89 e5                	mov    %esp,%ebp
   11476:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Machine Check.");
   11479:	83 ec 08             	sub    $0x8,%esp
   1147c:	68 e4 2b 01 00       	push   $0x12be4
   11481:	ff 75 08             	pushl  0x8(%ebp)
   11484:	e8 f8 fd ff ff       	call   11281 <do_default_handler>
   11489:	83 c4 10             	add    $0x10,%esp
}
   1148c:	90                   	nop
   1148d:	c9                   	leave  
   1148e:	c3                   	ret    

0001148f <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t *frame)
{
   1148f:	55                   	push   %ebp
   11490:	89 e5                	mov    %esp,%ebp
   11492:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "SIMD Floating Point Exception.");
   11495:	83 ec 08             	sub    $0x8,%esp
   11498:	68 f4 2b 01 00       	push   $0x12bf4
   1149d:	ff 75 08             	pushl  0x8(%ebp)
   114a0:	e8 dc fd ff ff       	call   11281 <do_default_handler>
   114a5:	83 c4 10             	add    $0x10,%esp
}
   114a8:	90                   	nop
   114a9:	c9                   	leave  
   114aa:	c3                   	ret    

000114ab <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t *frame)
{
   114ab:	55                   	push   %ebp
   114ac:	89 e5                	mov    %esp,%ebp
   114ae:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Virtualization Exception.");
   114b1:	83 ec 08             	sub    $0x8,%esp
   114b4:	68 13 2c 01 00       	push   $0x12c13
   114b9:	ff 75 08             	pushl  0x8(%ebp)
   114bc:	e8 c0 fd ff ff       	call   11281 <do_default_handler>
   114c1:	83 c4 10             	add    $0x10,%esp
}
   114c4:	90                   	nop
   114c5:	c9                   	leave  
   114c6:	c3                   	ret    

000114c7 <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t *frame)
{
   114c7:	55                   	push   %ebp
   114c8:	89 e5                	mov    %esp,%ebp
   114ca:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "General_protection Exception.");
   114cd:	83 ec 08             	sub    $0x8,%esp
   114d0:	68 2d 2c 01 00       	push   $0x12c2d
   114d5:	ff 75 08             	pushl  0x8(%ebp)
   114d8:	e8 a4 fd ff ff       	call   11281 <do_default_handler>
   114dd:	83 c4 10             	add    $0x10,%esp
}
   114e0:	90                   	nop
   114e1:	c9                   	leave  
   114e2:	c3                   	ret    

000114e3 <do_handler_page_fault>:

void do_handler_page_fault(exception_frame_t *frame)
{
   114e3:	55                   	push   %ebp
   114e4:	89 e5                	mov    %esp,%ebp
   114e6:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Page_fault Exception.");
   114e9:	83 ec 08             	sub    $0x8,%esp
   114ec:	68 4b 2c 01 00       	push   $0x12c4b
   114f1:	ff 75 08             	pushl  0x8(%ebp)
   114f4:	e8 88 fd ff ff       	call   11281 <do_default_handler>
   114f9:	83 c4 10             	add    $0x10,%esp
}
   114fc:	90                   	nop
   114fd:	c9                   	leave  
   114fe:	c3                   	ret    

000114ff <init_pic>:

static void init_pic(void)
{
   114ff:	55                   	push   %ebp
   11500:	89 e5                	mov    %esp,%ebp
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   11502:	6a 11                	push   $0x11
   11504:	6a 20                	push   $0x20
   11506:	e8 2d fc ff ff       	call   11138 <outb>
   1150b:	83 c4 08             	add    $0x8,%esp
    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
   1150e:	6a 20                	push   $0x20
   11510:	6a 21                	push   $0x21
   11512:	e8 21 fc ff ff       	call   11138 <outb>
   11517:	83 c4 08             	add    $0x8,%esp
    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
   1151a:	6a 04                	push   $0x4
   1151c:	6a 21                	push   $0x21
   1151e:	e8 15 fc ff ff       	call   11138 <outb>
   11523:	83 c4 08             	add    $0x8,%esp
    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086);
   11526:	6a 01                	push   $0x1
   11528:	6a 21                	push   $0x21
   1152a:	e8 09 fc ff ff       	call   11138 <outb>
   1152f:	83 c4 08             	add    $0x8,%esp

    // 第二块芯片
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   11532:	6a 11                	push   $0x11
   11534:	68 a0 00 00 00       	push   $0xa0
   11539:	e8 fa fb ff ff       	call   11138 <outb>
   1153e:	83 c4 08             	add    $0x8,%esp

    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   11541:	6a 28                	push   $0x28
   11543:	68 a1 00 00 00       	push   $0xa1
   11548:	e8 eb fb ff ff       	call   11138 <outb>
   1154d:	83 c4 08             	add    $0x8,%esp

    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
   11550:	6a 02                	push   $0x2
   11552:	68 a1 00 00 00       	push   $0xa1
   11557:	e8 dc fb ff ff       	call   11138 <outb>
   1155c:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
   1155f:	6a 01                	push   $0x1
   11561:	68 a1 00 00 00       	push   $0xa1
   11566:	e8 cd fb ff ff       	call   11138 <outb>
   1156b:	83 c4 08             	add    $0x8,%esp

    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   1156e:	68 fb 00 00 00       	push   $0xfb
   11573:	6a 21                	push   $0x21
   11575:	e8 be fb ff ff       	call   11138 <outb>
   1157a:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   1157d:	68 ff 00 00 00       	push   $0xff
   11582:	68 a1 00 00 00       	push   $0xa1
   11587:	e8 ac fb ff ff       	call   11138 <outb>
   1158c:	83 c4 08             	add    $0x8,%esp
}
   1158f:	90                   	nop
   11590:	c9                   	leave  
   11591:	c3                   	ret    

00011592 <irq_init>:

void irq_init(void)
{
   11592:	55                   	push   %ebp
   11593:	89 e5                	mov    %esp,%ebp
   11595:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   11598:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1159f:	eb 25                	jmp    115c6 <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   115a1:	ba 35 00 01 00       	mov    $0x10035,%edx
   115a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115a9:	c1 e0 03             	shl    $0x3,%eax
   115ac:	05 c0 79 01 00       	add    $0x179c0,%eax
   115b1:	68 00 8e 00 00       	push   $0x8e00
   115b6:	52                   	push   %edx
   115b7:	6a 08                	push   $0x8
   115b9:	50                   	push   %eax
   115ba:	e8 e4 fa ff ff       	call   110a3 <gate_desc_set>
   115bf:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   115c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115c6:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   115ca:	7e d5                	jle    115a1 <irq_init+0xf>
    }
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   115cc:	83 ec 08             	sub    $0x8,%esp
   115cf:	68 54 00 01 00       	push   $0x10054
   115d4:	6a 00                	push   $0x0
   115d6:	e8 65 01 00 00       	call   11740 <irq_install>
   115db:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   115de:	83 ec 08             	sub    $0x8,%esp
   115e1:	68 73 00 01 00       	push   $0x10073
   115e6:	6a 01                	push   $0x1
   115e8:	e8 53 01 00 00       	call   11740 <irq_install>
   115ed:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   115f0:	83 ec 08             	sub    $0x8,%esp
   115f3:	68 92 00 01 00       	push   $0x10092
   115f8:	6a 02                	push   $0x2
   115fa:	e8 41 01 00 00       	call   11740 <irq_install>
   115ff:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   11602:	83 ec 08             	sub    $0x8,%esp
   11605:	68 b1 00 01 00       	push   $0x100b1
   1160a:	6a 03                	push   $0x3
   1160c:	e8 2f 01 00 00       	call   11740 <irq_install>
   11611:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   11614:	83 ec 08             	sub    $0x8,%esp
   11617:	68 d0 00 01 00       	push   $0x100d0
   1161c:	6a 04                	push   $0x4
   1161e:	e8 1d 01 00 00       	call   11740 <irq_install>
   11623:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   11626:	83 ec 08             	sub    $0x8,%esp
   11629:	68 ef 00 01 00       	push   $0x100ef
   1162e:	6a 05                	push   $0x5
   11630:	e8 0b 01 00 00       	call   11740 <irq_install>
   11635:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   11638:	83 ec 08             	sub    $0x8,%esp
   1163b:	68 0e 01 01 00       	push   $0x1010e
   11640:	6a 06                	push   $0x6
   11642:	e8 f9 00 00 00       	call   11740 <irq_install>
   11647:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   1164a:	83 ec 08             	sub    $0x8,%esp
   1164d:	68 2d 01 01 00       	push   $0x1012d
   11652:	6a 07                	push   $0x7
   11654:	e8 e7 00 00 00       	call   11740 <irq_install>
   11659:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   1165c:	83 ec 08             	sub    $0x8,%esp
   1165f:	68 4c 01 01 00       	push   $0x1014c
   11664:	6a 08                	push   $0x8
   11666:	e8 d5 00 00 00       	call   11740 <irq_install>
   1166b:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   1166e:	83 ec 08             	sub    $0x8,%esp
   11671:	68 69 01 01 00       	push   $0x10169
   11676:	6a 0a                	push   $0xa
   11678:	e8 c3 00 00 00       	call   11740 <irq_install>
   1167d:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   11680:	83 ec 08             	sub    $0x8,%esp
   11683:	68 86 01 01 00       	push   $0x10186
   11688:	6a 0b                	push   $0xb
   1168a:	e8 b1 00 00 00       	call   11740 <irq_install>
   1168f:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   11692:	83 ec 08             	sub    $0x8,%esp
   11695:	68 a3 01 01 00       	push   $0x101a3
   1169a:	6a 0c                	push   $0xc
   1169c:	e8 9f 00 00 00       	call   11740 <irq_install>
   116a1:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   116a4:	83 ec 08             	sub    $0x8,%esp
   116a7:	68 c0 01 01 00       	push   $0x101c0
   116ac:	6a 0d                	push   $0xd
   116ae:	e8 8d 00 00 00       	call   11740 <irq_install>
   116b3:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   116b6:	83 ec 08             	sub    $0x8,%esp
   116b9:	68 dd 01 01 00       	push   $0x101dd
   116be:	6a 0e                	push   $0xe
   116c0:	e8 7b 00 00 00       	call   11740 <irq_install>
   116c5:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   116c8:	83 ec 08             	sub    $0x8,%esp
   116cb:	68 fa 01 01 00       	push   $0x101fa
   116d0:	6a 10                	push   $0x10
   116d2:	e8 69 00 00 00       	call   11740 <irq_install>
   116d7:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   116da:	83 ec 08             	sub    $0x8,%esp
   116dd:	68 19 02 01 00       	push   $0x10219
   116e2:	6a 11                	push   $0x11
   116e4:	e8 57 00 00 00       	call   11740 <irq_install>
   116e9:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   116ec:	83 ec 08             	sub    $0x8,%esp
   116ef:	68 36 02 01 00       	push   $0x10236
   116f4:	6a 12                	push   $0x12
   116f6:	e8 45 00 00 00       	call   11740 <irq_install>
   116fb:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   116fe:	83 ec 08             	sub    $0x8,%esp
   11701:	68 55 02 01 00       	push   $0x10255
   11706:	6a 13                	push   $0x13
   11708:	e8 33 00 00 00       	call   11740 <irq_install>
   1170d:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   11710:	83 ec 08             	sub    $0x8,%esp
   11713:	68 74 02 01 00       	push   $0x10274
   11718:	6a 14                	push   $0x14
   1171a:	e8 21 00 00 00       	call   11740 <irq_install>
   1171f:	83 c4 10             	add    $0x10,%esp
    lidt((uint32_t)idt_table, sizeof(idt_table));
   11722:	b8 c0 79 01 00       	mov    $0x179c0,%eax
   11727:	83 ec 08             	sub    $0x8,%esp
   1172a:	68 00 04 00 00       	push   $0x400
   1172f:	50                   	push   %eax
   11730:	e8 30 fa ff ff       	call   11165 <lidt>
   11735:	83 c4 10             	add    $0x10,%esp

    init_pic();
   11738:	e8 c2 fd ff ff       	call   114ff <init_pic>
}
   1173d:	90                   	nop
   1173e:	c9                   	leave  
   1173f:	c3                   	ret    

00011740 <irq_install>:

int irq_install(int irq_num, irq_handler_t handler)
{
   11740:	55                   	push   %ebp
   11741:	89 e5                	mov    %esp,%ebp
   11743:	83 ec 08             	sub    $0x8,%esp
    if (irq_num >= IDT_TABLE_NR)
   11746:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1174a:	7e 07                	jle    11753 <irq_install+0x13>
    {
        return -1;
   1174c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11751:	eb 25                	jmp    11778 <irq_install+0x38>
    }

    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   11753:	8b 45 0c             	mov    0xc(%ebp),%eax
   11756:	8b 55 08             	mov    0x8(%ebp),%edx
   11759:	c1 e2 03             	shl    $0x3,%edx
   1175c:	81 c2 c0 79 01 00    	add    $0x179c0,%edx
   11762:	68 00 8e 00 00       	push   $0x8e00
   11767:	50                   	push   %eax
   11768:	6a 08                	push   $0x8
   1176a:	52                   	push   %edx
   1176b:	e8 33 f9 ff ff       	call   110a3 <gate_desc_set>
   11770:	83 c4 10             	add    $0x10,%esp
    return 0;
   11773:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11778:	c9                   	leave  
   11779:	c3                   	ret    

0001177a <irq_enable>:

void irq_enable(int irq_num)
{
   1177a:	55                   	push   %ebp
   1177b:	89 e5                	mov    %esp,%ebp
   1177d:	53                   	push   %ebx
   1177e:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   11781:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   11785:	7e 78                	jle    117ff <irq_enable+0x85>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   11787:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   1178b:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   1178f:	7f 32                	jg     117c3 <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   11791:	6a 21                	push   $0x21
   11793:	e8 83 f9 ff ff       	call   1111b <inb>
   11798:	83 c4 04             	add    $0x4,%esp
   1179b:	89 c2                	mov    %eax,%edx
   1179d:	8b 45 08             	mov    0x8(%ebp),%eax
   117a0:	bb 01 00 00 00       	mov    $0x1,%ebx
   117a5:	89 c1                	mov    %eax,%ecx
   117a7:	d3 e3                	shl    %cl,%ebx
   117a9:	89 d8                	mov    %ebx,%eax
   117ab:	f7 d0                	not    %eax
   117ad:	21 d0                	and    %edx,%eax
   117af:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   117b2:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   117b6:	50                   	push   %eax
   117b7:	6a 21                	push   $0x21
   117b9:	e8 7a f9 ff ff       	call   11138 <outb>
   117be:	83 c4 08             	add    $0x8,%esp
   117c1:	eb 3d                	jmp    11800 <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   117c3:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   117c7:	68 a1 00 00 00       	push   $0xa1
   117cc:	e8 4a f9 ff ff       	call   1111b <inb>
   117d1:	83 c4 04             	add    $0x4,%esp
   117d4:	89 c2                	mov    %eax,%edx
   117d6:	8b 45 08             	mov    0x8(%ebp),%eax
   117d9:	bb 01 00 00 00       	mov    $0x1,%ebx
   117de:	89 c1                	mov    %eax,%ecx
   117e0:	d3 e3                	shl    %cl,%ebx
   117e2:	89 d8                	mov    %ebx,%eax
   117e4:	f7 d0                	not    %eax
   117e6:	21 d0                	and    %edx,%eax
   117e8:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   117eb:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   117ef:	50                   	push   %eax
   117f0:	68 a1 00 00 00       	push   $0xa1
   117f5:	e8 3e f9 ff ff       	call   11138 <outb>
   117fa:	83 c4 08             	add    $0x8,%esp
   117fd:	eb 01                	jmp    11800 <irq_enable+0x86>
        return;
   117ff:	90                   	nop
    }
}
   11800:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11803:	c9                   	leave  
   11804:	c3                   	ret    

00011805 <irq_disable>:

void irq_disable(int irq_num)
{
   11805:	55                   	push   %ebp
   11806:	89 e5                	mov    %esp,%ebp
   11808:	53                   	push   %ebx
   11809:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   1180c:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   11810:	7e 74                	jle    11886 <irq_disable+0x81>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   11812:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   11816:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   1181a:	7f 30                	jg     1184c <irq_disable+0x47>
    {
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   1181c:	6a 21                	push   $0x21
   1181e:	e8 f8 f8 ff ff       	call   1111b <inb>
   11823:	83 c4 04             	add    $0x4,%esp
   11826:	89 c3                	mov    %eax,%ebx
   11828:	8b 45 08             	mov    0x8(%ebp),%eax
   1182b:	ba 01 00 00 00       	mov    $0x1,%edx
   11830:	89 c1                	mov    %eax,%ecx
   11832:	d3 e2                	shl    %cl,%edx
   11834:	89 d0                	mov    %edx,%eax
   11836:	09 d8                	or     %ebx,%eax
   11838:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   1183b:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1183f:	50                   	push   %eax
   11840:	6a 21                	push   $0x21
   11842:	e8 f1 f8 ff ff       	call   11138 <outb>
   11847:	83 c4 08             	add    $0x8,%esp
   1184a:	eb 3b                	jmp    11887 <irq_disable+0x82>
    }
    else
    {
        irq_num -= 8;
   1184c:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   11850:	68 a1 00 00 00       	push   $0xa1
   11855:	e8 c1 f8 ff ff       	call   1111b <inb>
   1185a:	83 c4 04             	add    $0x4,%esp
   1185d:	89 c3                	mov    %eax,%ebx
   1185f:	8b 45 08             	mov    0x8(%ebp),%eax
   11862:	ba 01 00 00 00       	mov    $0x1,%edx
   11867:	89 c1                	mov    %eax,%ecx
   11869:	d3 e2                	shl    %cl,%edx
   1186b:	89 d0                	mov    %edx,%eax
   1186d:	09 d8                	or     %ebx,%eax
   1186f:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   11872:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   11876:	50                   	push   %eax
   11877:	68 a1 00 00 00       	push   $0xa1
   1187c:	e8 b7 f8 ff ff       	call   11138 <outb>
   11881:	83 c4 08             	add    $0x8,%esp
   11884:	eb 01                	jmp    11887 <irq_disable+0x82>
        return;
   11886:	90                   	nop
    }
}
   11887:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1188a:	c9                   	leave  
   1188b:	c3                   	ret    

0001188c <irq_disable_global>:

void irq_disable_global(void)
{
   1188c:	55                   	push   %ebp
   1188d:	89 e5                	mov    %esp,%ebp
    cli();
   1188f:	e8 c3 f8 ff ff       	call   11157 <cli>
}
   11894:	90                   	nop
   11895:	5d                   	pop    %ebp
   11896:	c3                   	ret    

00011897 <irq_enable_global>:

void irq_enable_global(void)
{
   11897:	55                   	push   %ebp
   11898:	89 e5                	mov    %esp,%ebp
    sti();
   1189a:	e8 bf f8 ff ff       	call   1115e <sti>
}
   1189f:	90                   	nop
   118a0:	5d                   	pop    %ebp
   118a1:	c3                   	ret    

000118a2 <pic_send_eoi>:

void pic_send_eoi(int irq_num)
{
   118a2:	55                   	push   %ebp
   118a3:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   118a5:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    // 从片也可能需要发送EOI
    if (irq_num >= 8)
   118a9:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   118ad:	7e 0f                	jle    118be <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   118af:	6a 20                	push   $0x20
   118b1:	68 a0 00 00 00       	push   $0xa0
   118b6:	e8 7d f8 ff ff       	call   11138 <outb>
   118bb:	83 c4 08             	add    $0x8,%esp
    }

    outb(PIC0_OCW2, PIC_OCW2_EOI);
   118be:	6a 20                	push   $0x20
   118c0:	6a 20                	push   $0x20
   118c2:	e8 71 f8 ff ff       	call   11138 <outb>
   118c7:	83 c4 08             	add    $0x8,%esp
}
   118ca:	90                   	nop
   118cb:	c9                   	leave  
   118cc:	c3                   	ret    

000118cd <irq_enter_protection>:

/**
 * @brief 进入中断保护
 */
irq_state_t irq_enter_protection(void)
{
   118cd:	55                   	push   %ebp
   118ce:	89 e5                	mov    %esp,%ebp
   118d0:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags(); // 保存之前的中断状态
   118d3:	e8 bc f8 ff ff       	call   11194 <read_eflags>
   118d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   118db:	e8 ac ff ff ff       	call   1188c <irq_disable_global>
    return state;
   118e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   118e3:	c9                   	leave  
   118e4:	c3                   	ret    

000118e5 <irq_leave_protection>:

/**
 * @brief 退出中断保护
 */
void irq_leave_protection(irq_state_t state)
{
   118e5:	55                   	push   %ebp
   118e6:	89 e5                	mov    %esp,%ebp
    write_eflags(state); // 恢复之前的中断状态
   118e8:	ff 75 08             	pushl  0x8(%ebp)
   118eb:	e8 b4 f8 ff ff       	call   111a4 <write_eflags>
   118f0:	83 c4 04             	add    $0x4,%esp
   118f3:	90                   	nop
   118f4:	c9                   	leave  
   118f5:	c3                   	ret    

000118f6 <outb>:
{
   118f6:	55                   	push   %ebp
   118f7:	89 e5                	mov    %esp,%ebp
   118f9:	83 ec 08             	sub    $0x8,%esp
   118fc:	8b 55 08             	mov    0x8(%ebp),%edx
   118ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11902:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   11906:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   11909:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1190d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   11911:	ee                   	out    %al,(%dx)
}
   11912:	90                   	nop
   11913:	c9                   	leave  
   11914:	c3                   	ret    

00011915 <init_pic>:
#include "cpu/irq.h"
#include "os_cfg.h"
#include "comm/cpu_instr.h"
static uint32_t sys_tick;
static void init_pic(void)
{
   11915:	55                   	push   %ebp
   11916:	89 e5                	mov    %esp,%ebp
   11918:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS); // 每隔10ms+1
   1191b:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
   11922:	6a 36                	push   $0x36
   11924:	6a 43                	push   $0x43
   11926:	e8 cb ff ff ff       	call   118f6 <outb>
   1192b:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);        // 加载低8位
   1192e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11931:	0f b6 c0             	movzbl %al,%eax
   11934:	50                   	push   %eax
   11935:	6a 40                	push   $0x40
   11937:	e8 ba ff ff ff       	call   118f6 <outb>
   1193c:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   1193f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11942:	c1 e8 08             	shr    $0x8,%eax
   11945:	0f b6 c0             	movzbl %al,%eax
   11948:	50                   	push   %eax
   11949:	6a 40                	push   $0x40
   1194b:	e8 a6 ff ff ff       	call   118f6 <outb>
   11950:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_timer);
   11953:	83 ec 08             	sub    $0x8,%esp
   11956:	68 93 02 01 00       	push   $0x10293
   1195b:	6a 20                	push   $0x20
   1195d:	e8 de fd ff ff       	call   11740 <irq_install>
   11962:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   11965:	83 ec 0c             	sub    $0xc,%esp
   11968:	6a 20                	push   $0x20
   1196a:	e8 0b fe ff ff       	call   1177a <irq_enable>
   1196f:	83 c4 10             	add    $0x10,%esp
}
   11972:	90                   	nop
   11973:	c9                   	leave  
   11974:	c3                   	ret    

00011975 <do_handler_timer>:
void do_handler_timer(exception_frame_t *frame)
{
   11975:	55                   	push   %ebp
   11976:	89 e5                	mov    %esp,%ebp
   11978:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   1197b:	a1 c0 7d 01 00       	mov    0x17dc0,%eax
   11980:	83 c0 01             	add    $0x1,%eax
   11983:	a3 c0 7d 01 00       	mov    %eax,0x17dc0
    // 先发EOI，而不是放在最后
    // 放最后将从任务中切换出去之后，除非任务再切换回来才能继续响应
    pic_send_eoi(IRQ0_TIMER);
   11988:	83 ec 0c             	sub    $0xc,%esp
   1198b:	6a 20                	push   $0x20
   1198d:	e8 10 ff ff ff       	call   118a2 <pic_send_eoi>
   11992:	83 c4 10             	add    $0x10,%esp

    task_time_tick();
   11995:	e8 85 f3 ff ff       	call   10d1f <task_time_tick>
}
   1199a:	90                   	nop
   1199b:	c9                   	leave  
   1199c:	c3                   	ret    

0001199d <time_init>:
void time_init(void)
{
   1199d:	55                   	push   %ebp
   1199e:	89 e5                	mov    %esp,%ebp
   119a0:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   119a3:	c7 05 c0 7d 01 00 00 	movl   $0x0,0x17dc0
   119aa:	00 00 00 
    init_pic();
   119ad:	e8 63 ff ff ff       	call   11915 <init_pic>
   119b2:	90                   	nop
   119b3:	c9                   	leave  
   119b4:	c3                   	ret    

000119b5 <kernel_init>:
#include "comm/cpu_instr.h"
#include "ipc/sem.h"
#include "core/memory.h"

void kernel_init(boot_info_t *boot_info)
{
   119b5:	55                   	push   %ebp
   119b6:	89 e5                	mov    %esp,%ebp
   119b8:	83 ec 08             	sub    $0x8,%esp
    cpu_init();
   119bb:	e8 2a f7 ff ff       	call   110ea <cpu_init>
    log_init();
   119c0:	e8 7b 0d 00 00       	call   12740 <log_init>
    irq_init();
   119c5:	e8 c8 fb ff ff       	call   11592 <irq_init>

    // 内存初始化要放前面一点，因为后面的代码可能需要内存分配
    memory_init(boot_info);
   119ca:	83 ec 0c             	sub    $0xc,%esp
   119cd:	ff 75 08             	pushl  0x8(%ebp)
   119d0:	e8 bd ed ff ff       	call   10792 <memory_init>
   119d5:	83 c4 10             	add    $0x10,%esp
    time_init();
   119d8:	e8 c0 ff ff ff       	call   1199d <time_init>

    task_manager_init();
   119dd:	e8 6f f1 ff ff       	call   10b51 <task_manager_init>
}
   119e2:	90                   	nop
   119e3:	c9                   	leave  
   119e4:	c3                   	ret    

000119e5 <init_task_entry>:
static uint32_t init_task_stack[1024];
static sem_t sem;
// static task_t first_task;

void init_task_entry(void)
{
   119e5:	55                   	push   %ebp
   119e6:	89 e5                	mov    %esp,%ebp
   119e8:	83 ec 18             	sub    $0x18,%esp
    int count = 0;
   119eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;;)
    {
        sem_wait(&sem);
   119f2:	83 ec 0c             	sub    $0xc,%esp
   119f5:	68 a0 8e 01 00       	push   $0x18ea0
   119fa:	e8 8d 02 00 00       	call   11c8c <sem_wait>
   119ff:	83 c4 10             	add    $0x10,%esp
        log_printf("init_task_entry: %d", count++);
   11a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a05:	8d 50 01             	lea    0x1(%eax),%edx
   11a08:	89 55 f4             	mov    %edx,-0xc(%ebp)
   11a0b:	83 ec 08             	sub    $0x8,%esp
   11a0e:	50                   	push   %eax
   11a0f:	68 61 2c 01 00       	push   $0x12c61
   11a14:	e8 a0 0d 00 00       	call   127b9 <log_printf>
   11a19:	83 c4 10             	add    $0x10,%esp
        sem_wait(&sem);
   11a1c:	eb d4                	jmp    119f2 <init_task_entry+0xd>

00011a1e <init_main>:
//     }
//     log_printf("list: first=0x%x, last=0x%x, count=%d", list_first(&list), list_last(&list), list_count(&list));
// }

void init_main(void)
{
   11a1e:	55                   	push   %ebp
   11a1f:	89 e5                	mov    %esp,%ebp
   11a21:	83 ec 18             	sub    $0x18,%esp
    // list_test();

    log_printf("Kernel is running...");
   11a24:	83 ec 0c             	sub    $0xc,%esp
   11a27:	68 75 2c 01 00       	push   $0x12c75
   11a2c:	e8 88 0d 00 00       	call   127b9 <log_printf>
   11a31:	83 c4 10             	add    $0x10,%esp
    log_printf("Version: %s", OS_VERSION);
   11a34:	83 ec 08             	sub    $0x8,%esp
   11a37:	68 8a 2c 01 00       	push   $0x12c8a
   11a3c:	68 90 2c 01 00       	push   $0x12c90
   11a41:	e8 73 0d 00 00       	call   127b9 <log_printf>
   11a46:	83 c4 10             	add    $0x10,%esp
    log_printf("%d %d %x %c", 123456, -123, 0x123456, 'a');
   11a49:	83 ec 0c             	sub    $0xc,%esp
   11a4c:	6a 61                	push   $0x61
   11a4e:	68 56 34 12 00       	push   $0x123456
   11a53:	6a 85                	push   $0xffffff85
   11a55:	68 40 e2 01 00       	push   $0x1e240
   11a5a:	68 9c 2c 01 00       	push   $0x12c9c
   11a5f:	e8 55 0d 00 00       	call   127b9 <log_printf>
   11a64:	83 c4 20             	add    $0x20,%esp

    task_init(&init_task, "init task", (uint32_t)init_task_entry, (uint32_t)&init_task_stack[1024]); // 压栈先-4再入栈
   11a67:	ba a0 8e 01 00       	mov    $0x18ea0,%edx
   11a6c:	b8 e5 19 01 00       	mov    $0x119e5,%eax
   11a71:	52                   	push   %edx
   11a72:	50                   	push   %eax
   11a73:	68 a8 2c 01 00       	push   $0x12ca8
   11a78:	68 e0 7d 01 00       	push   $0x17de0
   11a7d:	e8 72 ef ff ff       	call   109f4 <task_init>
   11a82:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   11a85:	e8 79 f0 ff ff       	call   10b03 <task_first_init>

    sem_init(&sem, 0);
   11a8a:	83 ec 08             	sub    $0x8,%esp
   11a8d:	6a 00                	push   $0x0
   11a8f:	68 a0 8e 01 00       	push   $0x18ea0
   11a94:	e8 d0 01 00 00       	call   11c69 <sem_init>
   11a99:	83 c4 10             	add    $0x10,%esp
    irq_enable_global(); // 用时间片中断来调度
   11a9c:	e8 f6 fd ff ff       	call   11897 <irq_enable_global>

    int count = 0;
   11aa1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;;)
    {
        log_printf("init_main: %d", count++);
   11aa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11aab:	8d 50 01             	lea    0x1(%eax),%edx
   11aae:	89 55 f4             	mov    %edx,-0xc(%ebp)
   11ab1:	83 ec 08             	sub    $0x8,%esp
   11ab4:	50                   	push   %eax
   11ab5:	68 b2 2c 01 00       	push   $0x12cb2
   11aba:	e8 fa 0c 00 00       	call   127b9 <log_printf>
   11abf:	83 c4 10             	add    $0x10,%esp
        sem_notify(&sem);
   11ac2:	83 ec 0c             	sub    $0xc,%esp
   11ac5:	68 a0 8e 01 00       	push   $0x18ea0
   11aca:	e8 28 02 00 00       	call   11cf7 <sem_notify>
   11acf:	83 c4 10             	add    $0x10,%esp
        log_printf("init_main: %d", count++);
   11ad2:	eb d4                	jmp    11aa8 <init_main+0x8a>

00011ad4 <list_count>:
{
   11ad4:	55                   	push   %ebp
   11ad5:	89 e5                	mov    %esp,%ebp
    return list->count;
   11ad7:	8b 45 08             	mov    0x8(%ebp),%eax
   11ada:	8b 40 08             	mov    0x8(%eax),%eax
}
   11add:	5d                   	pop    %ebp
   11ade:	c3                   	ret    

00011adf <mutex_init>:

/**
 * 锁初始化
 */
void mutex_init(mutex_t *mutex)
{
   11adf:	55                   	push   %ebp
   11ae0:	89 e5                	mov    %esp,%ebp
   11ae2:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count = 0;
   11ae5:	8b 45 08             	mov    0x8(%ebp),%eax
   11ae8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner = (task_t *)0;
   11aef:	8b 45 08             	mov    0x8(%ebp),%eax
   11af2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   11af8:	8b 45 08             	mov    0x8(%ebp),%eax
   11afb:	83 c0 08             	add    $0x8,%eax
   11afe:	83 ec 0c             	sub    $0xc,%esp
   11b01:	50                   	push   %eax
   11b02:	e8 18 0a 00 00       	call   1251f <list_init>
   11b07:	83 c4 10             	add    $0x10,%esp
}
   11b0a:	90                   	nop
   11b0b:	c9                   	leave  
   11b0c:	c3                   	ret    

00011b0d <mutex_lock>:

/**
 * 申请锁
 */
void mutex_lock(mutex_t *mutex)
{
   11b0d:	55                   	push   %ebp
   11b0e:	89 e5                	mov    %esp,%ebp
   11b10:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11b13:	e8 b5 fd ff ff       	call   118cd <irq_enter_protection>
   11b18:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *curr = task_current();
   11b1b:	e8 f6 f0 ff ff       	call   10c16 <task_current>
   11b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->locked_count == 0)
   11b23:	8b 45 08             	mov    0x8(%ebp),%eax
   11b26:	8b 40 04             	mov    0x4(%eax),%eax
   11b29:	85 c0                	test   %eax,%eax
   11b2b:	75 14                	jne    11b41 <mutex_lock+0x34>
    {
        // 没有任务占用，占用之
        mutex->locked_count = 1;
   11b2d:	8b 45 08             	mov    0x8(%ebp),%eax
   11b30:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner = curr;
   11b37:	8b 45 08             	mov    0x8(%ebp),%eax
   11b3a:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11b3d:	89 10                	mov    %edx,(%eax)
   11b3f:	eb 4f                	jmp    11b90 <mutex_lock+0x83>
    }
    else if (mutex->owner == curr)
   11b41:	8b 45 08             	mov    0x8(%ebp),%eax
   11b44:	8b 00                	mov    (%eax),%eax
   11b46:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b49:	75 11                	jne    11b5c <mutex_lock+0x4f>
    {
        // 已经为当前任务所有，只增加计数
        mutex->locked_count++;
   11b4b:	8b 45 08             	mov    0x8(%ebp),%eax
   11b4e:	8b 40 04             	mov    0x4(%eax),%eax
   11b51:	8d 50 01             	lea    0x1(%eax),%edx
   11b54:	8b 45 08             	mov    0x8(%ebp),%eax
   11b57:	89 50 04             	mov    %edx,0x4(%eax)
   11b5a:	eb 34                	jmp    11b90 <mutex_lock+0x83>
    }
    else
    {
        // 有其它任务占用，则进入队列等待
        task_t *curr = task_current();
   11b5c:	e8 b5 f0 ff ff       	call   10c16 <task_current>
   11b61:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr);
   11b64:	83 ec 0c             	sub    $0xc,%esp
   11b67:	ff 75 ec             	pushl  -0x14(%ebp)
   11b6a:	e8 7c f0 ff ff       	call   10beb <task_set_block>
   11b6f:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   11b72:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b75:	8d 50 38             	lea    0x38(%eax),%edx
   11b78:	8b 45 08             	mov    0x8(%ebp),%eax
   11b7b:	83 c0 08             	add    $0x8,%eax
   11b7e:	83 ec 08             	sub    $0x8,%esp
   11b81:	52                   	push   %edx
   11b82:	50                   	push   %eax
   11b83:	e8 1b 0a 00 00       	call   125a3 <list_insert_last>
   11b88:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   11b8b:	e8 34 f1 ff ff       	call   10cc4 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   11b90:	83 ec 0c             	sub    $0xc,%esp
   11b93:	ff 75 f4             	pushl  -0xc(%ebp)
   11b96:	e8 4a fd ff ff       	call   118e5 <irq_leave_protection>
   11b9b:	83 c4 10             	add    $0x10,%esp
}
   11b9e:	90                   	nop
   11b9f:	c9                   	leave  
   11ba0:	c3                   	ret    

00011ba1 <mutex_unlock>:

/**
 * 释放锁
 */
void mutex_unlock(mutex_t *mutex)
{
   11ba1:	55                   	push   %ebp
   11ba2:	89 e5                	mov    %esp,%ebp
   11ba4:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11ba7:	e8 21 fd ff ff       	call   118cd <irq_enter_protection>
   11bac:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 只有锁的拥有者才能释放锁
    task_t *curr = task_current();
   11baf:	e8 62 f0 ff ff       	call   10c16 <task_current>
   11bb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->owner == curr)
   11bb7:	8b 45 08             	mov    0x8(%ebp),%eax
   11bba:	8b 00                	mov    (%eax),%eax
   11bbc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11bbf:	0f 85 88 00 00 00    	jne    11c4d <mutex_unlock+0xac>
    {
        if (--mutex->locked_count == 0)
   11bc5:	8b 45 08             	mov    0x8(%ebp),%eax
   11bc8:	8b 40 04             	mov    0x4(%eax),%eax
   11bcb:	8d 50 ff             	lea    -0x1(%eax),%edx
   11bce:	8b 45 08             	mov    0x8(%ebp),%eax
   11bd1:	89 50 04             	mov    %edx,0x4(%eax)
   11bd4:	8b 45 08             	mov    0x8(%ebp),%eax
   11bd7:	8b 40 04             	mov    0x4(%eax),%eax
   11bda:	85 c0                	test   %eax,%eax
   11bdc:	75 6f                	jne    11c4d <mutex_unlock+0xac>
        {
            // 减到0，释放锁
            mutex->owner = (task_t *)0;
   11bde:	8b 45 08             	mov    0x8(%ebp),%eax
   11be1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            // 如果队列中有任务等待，则立即唤醒并占用锁
            if (list_count(&mutex->wait_list))
   11be7:	8b 45 08             	mov    0x8(%ebp),%eax
   11bea:	83 c0 08             	add    $0x8,%eax
   11bed:	83 ec 0c             	sub    $0xc,%esp
   11bf0:	50                   	push   %eax
   11bf1:	e8 de fe ff ff       	call   11ad4 <list_count>
   11bf6:	83 c4 10             	add    $0x10,%esp
   11bf9:	85 c0                	test   %eax,%eax
   11bfb:	74 50                	je     11c4d <mutex_unlock+0xac>
            {
                list_node_t *task_node = list_remove_first(&mutex->wait_list);
   11bfd:	8b 45 08             	mov    0x8(%ebp),%eax
   11c00:	83 c0 08             	add    $0x8,%eax
   11c03:	83 ec 0c             	sub    $0xc,%esp
   11c06:	50                   	push   %eax
   11c07:	e8 fb 09 00 00       	call   12607 <list_remove_first>
   11c0c:	83 c4 10             	add    $0x10,%esp
   11c0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t *task = list_node_parent(task_node, task_t, wait_node);
   11c12:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11c16:	74 08                	je     11c20 <mutex_unlock+0x7f>
   11c18:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c1b:	83 e8 38             	sub    $0x38,%eax
   11c1e:	eb 05                	jmp    11c25 <mutex_unlock+0x84>
   11c20:	b8 00 00 00 00       	mov    $0x0,%eax
   11c25:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   11c28:	83 ec 0c             	sub    $0xc,%esp
   11c2b:	ff 75 e8             	pushl  -0x18(%ebp)
   11c2e:	e8 84 ef ff ff       	call   10bb7 <task_set_ready>
   11c33:	83 c4 10             	add    $0x10,%esp

                // 在这里占用，而不是在任务醒后占用，因为可能抢不到
                mutex->locked_count = 1;
   11c36:	8b 45 08             	mov    0x8(%ebp),%eax
   11c39:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner = task;
   11c40:	8b 45 08             	mov    0x8(%ebp),%eax
   11c43:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11c46:	89 10                	mov    %edx,(%eax)

                task_dispatch();
   11c48:	e8 77 f0 ff ff       	call   10cc4 <task_dispatch>
            }
        }
    }

    irq_leave_protection(irq_state);
   11c4d:	83 ec 0c             	sub    $0xc,%esp
   11c50:	ff 75 f4             	pushl  -0xc(%ebp)
   11c53:	e8 8d fc ff ff       	call   118e5 <irq_leave_protection>
   11c58:	83 c4 10             	add    $0x10,%esp
   11c5b:	90                   	nop
   11c5c:	c9                   	leave  
   11c5d:	c3                   	ret    

00011c5e <list_count>:
{
   11c5e:	55                   	push   %ebp
   11c5f:	89 e5                	mov    %esp,%ebp
    return list->count;
   11c61:	8b 45 08             	mov    0x8(%ebp),%eax
   11c64:	8b 40 08             	mov    0x8(%eax),%eax
}
   11c67:	5d                   	pop    %ebp
   11c68:	c3                   	ret    

00011c69 <sem_init>:

/**
 * 信号量初始化
 */
void sem_init(sem_t *sem, int init_count)
{
   11c69:	55                   	push   %ebp
   11c6a:	89 e5                	mov    %esp,%ebp
   11c6c:	83 ec 08             	sub    $0x8,%esp
    sem->count = init_count;
   11c6f:	8b 45 08             	mov    0x8(%ebp),%eax
   11c72:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c75:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   11c77:	8b 45 08             	mov    0x8(%ebp),%eax
   11c7a:	83 c0 04             	add    $0x4,%eax
   11c7d:	83 ec 0c             	sub    $0xc,%esp
   11c80:	50                   	push   %eax
   11c81:	e8 99 08 00 00       	call   1251f <list_init>
   11c86:	83 c4 10             	add    $0x10,%esp
}
   11c89:	90                   	nop
   11c8a:	c9                   	leave  
   11c8b:	c3                   	ret    

00011c8c <sem_wait>:

/**
 * 申请信号量
 */
void sem_wait(sem_t *sem)
{
   11c8c:	55                   	push   %ebp
   11c8d:	89 e5                	mov    %esp,%ebp
   11c8f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11c92:	e8 36 fc ff ff       	call   118cd <irq_enter_protection>
   11c97:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (sem->count > 0)
   11c9a:	8b 45 08             	mov    0x8(%ebp),%eax
   11c9d:	8b 00                	mov    (%eax),%eax
   11c9f:	85 c0                	test   %eax,%eax
   11ca1:	7e 0f                	jle    11cb2 <sem_wait+0x26>
    {
        sem->count--;
   11ca3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ca6:	8b 00                	mov    (%eax),%eax
   11ca8:	8d 50 ff             	lea    -0x1(%eax),%edx
   11cab:	8b 45 08             	mov    0x8(%ebp),%eax
   11cae:	89 10                	mov    %edx,(%eax)
   11cb0:	eb 34                	jmp    11ce6 <sem_wait+0x5a>
    }
    else
    {
        // 从就绪队列中移除，然后加入信号量的等待队列
        task_t *curr = task_current();
   11cb2:	e8 5f ef ff ff       	call   10c16 <task_current>
   11cb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   11cba:	83 ec 0c             	sub    $0xc,%esp
   11cbd:	ff 75 f0             	pushl  -0x10(%ebp)
   11cc0:	e8 26 ef ff ff       	call   10beb <task_set_block>
   11cc5:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &curr->wait_node);
   11cc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ccb:	8d 50 38             	lea    0x38(%eax),%edx
   11cce:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd1:	83 c0 04             	add    $0x4,%eax
   11cd4:	83 ec 08             	sub    $0x8,%esp
   11cd7:	52                   	push   %edx
   11cd8:	50                   	push   %eax
   11cd9:	e8 c5 08 00 00       	call   125a3 <list_insert_last>
   11cde:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   11ce1:	e8 de ef ff ff       	call   10cc4 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   11ce6:	83 ec 0c             	sub    $0xc,%esp
   11ce9:	ff 75 f4             	pushl  -0xc(%ebp)
   11cec:	e8 f4 fb ff ff       	call   118e5 <irq_leave_protection>
   11cf1:	83 c4 10             	add    $0x10,%esp
}
   11cf4:	90                   	nop
   11cf5:	c9                   	leave  
   11cf6:	c3                   	ret    

00011cf7 <sem_notify>:

/**
 * 释放信号量
 */
void sem_notify(sem_t *sem)
{
   11cf7:	55                   	push   %ebp
   11cf8:	89 e5                	mov    %esp,%ebp
   11cfa:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11cfd:	e8 cb fb ff ff       	call   118cd <irq_enter_protection>
   11d02:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&sem->wait_list))
   11d05:	8b 45 08             	mov    0x8(%ebp),%eax
   11d08:	83 c0 04             	add    $0x4,%eax
   11d0b:	83 ec 0c             	sub    $0xc,%esp
   11d0e:	50                   	push   %eax
   11d0f:	e8 4a ff ff ff       	call   11c5e <list_count>
   11d14:	83 c4 10             	add    $0x10,%esp
   11d17:	85 c0                	test   %eax,%eax
   11d19:	74 40                	je     11d5b <sem_notify+0x64>
    {
        // 有进程等待，则唤醒加入就绪队列
        list_node_t *node = list_remove_first(&sem->wait_list);
   11d1b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d1e:	83 c0 04             	add    $0x4,%eax
   11d21:	83 ec 0c             	sub    $0xc,%esp
   11d24:	50                   	push   %eax
   11d25:	e8 dd 08 00 00       	call   12607 <list_remove_first>
   11d2a:	83 c4 10             	add    $0x10,%esp
   11d2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node, task_t, wait_node);
   11d30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11d34:	74 08                	je     11d3e <sem_notify+0x47>
   11d36:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d39:	83 e8 38             	sub    $0x38,%eax
   11d3c:	eb 05                	jmp    11d43 <sem_notify+0x4c>
   11d3e:	b8 00 00 00 00       	mov    $0x0,%eax
   11d43:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   11d46:	83 ec 0c             	sub    $0xc,%esp
   11d49:	ff 75 ec             	pushl  -0x14(%ebp)
   11d4c:	e8 66 ee ff ff       	call   10bb7 <task_set_ready>
   11d51:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   11d54:	e8 6b ef ff ff       	call   10cc4 <task_dispatch>
   11d59:	eb 0d                	jmp    11d68 <sem_notify+0x71>
    }
    else
    {
        sem->count++;
   11d5b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5e:	8b 00                	mov    (%eax),%eax
   11d60:	8d 50 01             	lea    0x1(%eax),%edx
   11d63:	8b 45 08             	mov    0x8(%ebp),%eax
   11d66:	89 10                	mov    %edx,(%eax)
    }

    irq_leave_protection(irq_state);
   11d68:	83 ec 0c             	sub    $0xc,%esp
   11d6b:	ff 75 f4             	pushl  -0xc(%ebp)
   11d6e:	e8 72 fb ff ff       	call   118e5 <irq_leave_protection>
   11d73:	83 c4 10             	add    $0x10,%esp
}
   11d76:	90                   	nop
   11d77:	c9                   	leave  
   11d78:	c3                   	ret    

00011d79 <sem_count>:

/**
 * 获取信号量的当前值
 */
int sem_count(sem_t *sem)
{
   11d79:	55                   	push   %ebp
   11d7a:	89 e5                	mov    %esp,%ebp
   11d7c:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11d7f:	e8 49 fb ff ff       	call   118cd <irq_enter_protection>
   11d84:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   11d87:	8b 45 08             	mov    0x8(%ebp),%eax
   11d8a:	8b 00                	mov    (%eax),%eax
   11d8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(irq_state);
   11d8f:	83 ec 0c             	sub    $0xc,%esp
   11d92:	ff 75 f4             	pushl  -0xc(%ebp)
   11d95:	e8 4b fb ff ff       	call   118e5 <irq_leave_protection>
   11d9a:	83 c4 10             	add    $0x10,%esp
    return count;
   11d9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11da0:	c9                   	leave  
   11da1:	c3                   	ret    

00011da2 <bitmap_byte_count>:

/**
 * @brief 获取所需要的字节数量
 */
int bitmap_byte_count(int bit_count)
{
   11da2:	55                   	push   %ebp
   11da3:	89 e5                	mov    %esp,%ebp
    return (bit_count + 8 - 1) / 8; // 向上取整
   11da5:	8b 45 08             	mov    0x8(%ebp),%eax
   11da8:	83 c0 07             	add    $0x7,%eax
   11dab:	8d 50 07             	lea    0x7(%eax),%edx
   11dae:	85 c0                	test   %eax,%eax
   11db0:	0f 48 c2             	cmovs  %edx,%eax
   11db3:	c1 f8 03             	sar    $0x3,%eax
}
   11db6:	5d                   	pop    %ebp
   11db7:	c3                   	ret    

00011db8 <bitmap_init>:

/**
 * @brief 位图初始化
 */
void bitmap_init(bitmap_t *bitmap, uint8_t *bits, int count, int init_bit)
{
   11db8:	55                   	push   %ebp
   11db9:	89 e5                	mov    %esp,%ebp
   11dbb:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count = count;
   11dbe:	8b 45 08             	mov    0x8(%ebp),%eax
   11dc1:	8b 55 10             	mov    0x10(%ebp),%edx
   11dc4:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   11dc6:	8b 45 08             	mov    0x8(%ebp),%eax
   11dc9:	8b 55 0c             	mov    0xc(%ebp),%edx
   11dcc:	89 50 04             	mov    %edx,0x4(%eax)

    int bytes = bitmap_byte_count(bitmap->bit_count);
   11dcf:	8b 45 08             	mov    0x8(%ebp),%eax
   11dd2:	8b 00                	mov    (%eax),%eax
   11dd4:	50                   	push   %eax
   11dd5:	e8 c8 ff ff ff       	call   11da2 <bitmap_byte_count>
   11dda:	83 c4 04             	add    $0x4,%esp
   11ddd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits, init_bit ? 0xFF : 0, bytes); // 将bitmap置位
   11de0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   11de4:	74 07                	je     11ded <bitmap_init+0x35>
   11de6:	ba ff 00 00 00       	mov    $0xff,%edx
   11deb:	eb 05                	jmp    11df2 <bitmap_init+0x3a>
   11ded:	ba 00 00 00 00       	mov    $0x0,%edx
   11df2:	8b 45 08             	mov    0x8(%ebp),%eax
   11df5:	8b 40 04             	mov    0x4(%eax),%eax
   11df8:	83 ec 04             	sub    $0x4,%esp
   11dfb:	ff 75 f4             	pushl  -0xc(%ebp)
   11dfe:	52                   	push   %edx
   11dff:	50                   	push   %eax
   11e00:	e8 a8 03 00 00       	call   121ad <kernel_memset>
   11e05:	83 c4 10             	add    $0x10,%esp
}
   11e08:	90                   	nop
   11e09:	c9                   	leave  
   11e0a:	c3                   	ret    

00011e0b <bitmap_set_bit>:

/**
 * @brief 连续设置N个位
 */
void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit)
{
   11e0b:	55                   	push   %ebp
   11e0c:	89 e5                	mov    %esp,%ebp
   11e0e:	56                   	push   %esi
   11e0f:	53                   	push   %ebx
   11e10:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   11e13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11e1a:	e9 a2 00 00 00       	jmp    11ec1 <bitmap_set_bit+0xb6>
    {
        // 可以考虑进行一定程序的优化!!
        if (bit)
   11e1f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   11e23:	74 4a                	je     11e6f <bitmap_set_bit+0x64>
        {
            bitmap->bits[index / 8] |= 1 << (index % 8);
   11e25:	8b 45 08             	mov    0x8(%ebp),%eax
   11e28:	8b 50 04             	mov    0x4(%eax),%edx
   11e2b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e2e:	8d 48 07             	lea    0x7(%eax),%ecx
   11e31:	85 c0                	test   %eax,%eax
   11e33:	0f 48 c1             	cmovs  %ecx,%eax
   11e36:	c1 f8 03             	sar    $0x3,%eax
   11e39:	89 c3                	mov    %eax,%ebx
   11e3b:	89 d8                	mov    %ebx,%eax
   11e3d:	01 d0                	add    %edx,%eax
   11e3f:	0f b6 00             	movzbl (%eax),%eax
   11e42:	89 c6                	mov    %eax,%esi
   11e44:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e47:	99                   	cltd   
   11e48:	c1 ea 1d             	shr    $0x1d,%edx
   11e4b:	01 d0                	add    %edx,%eax
   11e4d:	83 e0 07             	and    $0x7,%eax
   11e50:	29 d0                	sub    %edx,%eax
   11e52:	ba 01 00 00 00       	mov    $0x1,%edx
   11e57:	89 c1                	mov    %eax,%ecx
   11e59:	d3 e2                	shl    %cl,%edx
   11e5b:	89 d0                	mov    %edx,%eax
   11e5d:	89 f2                	mov    %esi,%edx
   11e5f:	09 c2                	or     %eax,%edx
   11e61:	8b 45 08             	mov    0x8(%ebp),%eax
   11e64:	8b 40 04             	mov    0x4(%eax),%eax
   11e67:	89 d9                	mov    %ebx,%ecx
   11e69:	01 c8                	add    %ecx,%eax
   11e6b:	88 10                	mov    %dl,(%eax)
   11e6d:	eb 4a                	jmp    11eb9 <bitmap_set_bit+0xae>
        }
        else
        {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
   11e6f:	8b 45 08             	mov    0x8(%ebp),%eax
   11e72:	8b 50 04             	mov    0x4(%eax),%edx
   11e75:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e78:	8d 48 07             	lea    0x7(%eax),%ecx
   11e7b:	85 c0                	test   %eax,%eax
   11e7d:	0f 48 c1             	cmovs  %ecx,%eax
   11e80:	c1 f8 03             	sar    $0x3,%eax
   11e83:	89 c3                	mov    %eax,%ebx
   11e85:	89 d8                	mov    %ebx,%eax
   11e87:	01 d0                	add    %edx,%eax
   11e89:	0f b6 00             	movzbl (%eax),%eax
   11e8c:	89 c6                	mov    %eax,%esi
   11e8e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e91:	99                   	cltd   
   11e92:	c1 ea 1d             	shr    $0x1d,%edx
   11e95:	01 d0                	add    %edx,%eax
   11e97:	83 e0 07             	and    $0x7,%eax
   11e9a:	29 d0                	sub    %edx,%eax
   11e9c:	ba 01 00 00 00       	mov    $0x1,%edx
   11ea1:	89 c1                	mov    %eax,%ecx
   11ea3:	d3 e2                	shl    %cl,%edx
   11ea5:	89 d0                	mov    %edx,%eax
   11ea7:	f7 d0                	not    %eax
   11ea9:	89 f2                	mov    %esi,%edx
   11eab:	21 c2                	and    %eax,%edx
   11ead:	8b 45 08             	mov    0x8(%ebp),%eax
   11eb0:	8b 40 04             	mov    0x4(%eax),%eax
   11eb3:	89 d9                	mov    %ebx,%ecx
   11eb5:	01 c8                	add    %ecx,%eax
   11eb7:	88 10                	mov    %dl,(%eax)
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   11eb9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11ebd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   11ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ec4:	3b 45 10             	cmp    0x10(%ebp),%eax
   11ec7:	7d 0e                	jge    11ed7 <bitmap_set_bit+0xcc>
   11ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   11ecc:	8b 00                	mov    (%eax),%eax
   11ece:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11ed1:	0f 8c 48 ff ff ff    	jl     11e1f <bitmap_set_bit+0x14>
        }
    }
}
   11ed7:	90                   	nop
   11ed8:	83 c4 10             	add    $0x10,%esp
   11edb:	5b                   	pop    %ebx
   11edc:	5e                   	pop    %esi
   11edd:	5d                   	pop    %ebp
   11ede:	c3                   	ret    

00011edf <bitmap_get_bit>:

/**
 * @brief 获取指定位的状态
 */
int bitmap_get_bit(bitmap_t *bitmap, int index)
{
   11edf:	55                   	push   %ebp
   11ee0:	89 e5                	mov    %esp,%ebp
   11ee2:	53                   	push   %ebx
    // return bitmap->bits[index / 8] & (1 << (index % 8));
    //  2023-3-9 这里应该返回0或者1
    return (bitmap->bits[index / 8] & (1 << (index % 8))) ? 1 : 0;
   11ee3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ee6:	8b 50 04             	mov    0x4(%eax),%edx
   11ee9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11eec:	8d 48 07             	lea    0x7(%eax),%ecx
   11eef:	85 c0                	test   %eax,%eax
   11ef1:	0f 48 c1             	cmovs  %ecx,%eax
   11ef4:	c1 f8 03             	sar    $0x3,%eax
   11ef7:	01 d0                	add    %edx,%eax
   11ef9:	0f b6 00             	movzbl (%eax),%eax
   11efc:	0f b6 d8             	movzbl %al,%ebx
   11eff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f02:	99                   	cltd   
   11f03:	c1 ea 1d             	shr    $0x1d,%edx
   11f06:	01 d0                	add    %edx,%eax
   11f08:	83 e0 07             	and    $0x7,%eax
   11f0b:	29 d0                	sub    %edx,%eax
   11f0d:	89 c1                	mov    %eax,%ecx
   11f0f:	d3 fb                	sar    %cl,%ebx
   11f11:	89 d8                	mov    %ebx,%eax
   11f13:	83 e0 01             	and    $0x1,%eax
}
   11f16:	5b                   	pop    %ebx
   11f17:	5d                   	pop    %ebp
   11f18:	c3                   	ret    

00011f19 <bitmap_is_set>:

/**
 * @brief 检查指定位是否置1
 */
int bitmap_is_set(bitmap_t *bitmap, int index)
{
   11f19:	55                   	push   %ebp
   11f1a:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
   11f1c:	ff 75 0c             	pushl  0xc(%ebp)
   11f1f:	ff 75 08             	pushl  0x8(%ebp)
   11f22:	e8 b8 ff ff ff       	call   11edf <bitmap_get_bit>
   11f27:	83 c4 08             	add    $0x8,%esp
   11f2a:	85 c0                	test   %eax,%eax
   11f2c:	0f 95 c0             	setne  %al
   11f2f:	0f b6 c0             	movzbl %al,%eax
}
   11f32:	c9                   	leave  
   11f33:	c3                   	ret    

00011f34 <bitmap_alloc_nbits>:

/**
 * @brief 连续分配若干指定比特位，返回起始索引
 */
int bitmap_alloc_nbits(bitmap_t *bitmap, int bit, int count)
{
   11f34:	55                   	push   %ebp
   11f35:	89 e5                	mov    %esp,%ebp
   11f37:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   11f3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   11f41:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count)
   11f48:	e9 85 00 00 00       	jmp    11fd2 <bitmap_alloc_nbits+0x9e>
    {
        // 定位到第一个相同的索引处
        if (bitmap_get_bit(bitmap, search_idx) != bit)
   11f4d:	ff 75 fc             	pushl  -0x4(%ebp)
   11f50:	ff 75 08             	pushl  0x8(%ebp)
   11f53:	e8 87 ff ff ff       	call   11edf <bitmap_get_bit>
   11f58:	83 c4 08             	add    $0x8,%esp
   11f5b:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11f5e:	74 06                	je     11f66 <bitmap_alloc_nbits+0x32>
        {
            // 不同，继续寻找起始的bit
            search_idx++;
   11f60:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   11f64:	eb 6c                	jmp    11fd2 <bitmap_alloc_nbits+0x9e>
        }

        // 记录起始索引
        ok_idx = search_idx;
   11f66:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11f69:	89 45 f8             	mov    %eax,-0x8(%ebp)

        // 继续计算下一部分
        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++)
   11f6c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   11f73:	eb 27                	jmp    11f9c <bitmap_alloc_nbits+0x68>
        {
            if (bitmap_get_bit(bitmap, search_idx++) != bit)
   11f75:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11f78:	8d 50 01             	lea    0x1(%eax),%edx
   11f7b:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11f7e:	50                   	push   %eax
   11f7f:	ff 75 08             	pushl  0x8(%ebp)
   11f82:	e8 58 ff ff ff       	call   11edf <bitmap_get_bit>
   11f87:	83 c4 08             	add    $0x8,%esp
   11f8a:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11f8d:	74 09                	je     11f98 <bitmap_alloc_nbits+0x64>
            {
                // 不足count个，退出，重新进行最外层的比较
                ok_idx = -1;
   11f8f:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   11f96:	eb 16                	jmp    11fae <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++)
   11f98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11f9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f9f:	3b 45 10             	cmp    0x10(%ebp),%eax
   11fa2:	7d 0a                	jge    11fae <bitmap_alloc_nbits+0x7a>
   11fa4:	8b 45 08             	mov    0x8(%ebp),%eax
   11fa7:	8b 00                	mov    (%eax),%eax
   11fa9:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   11fac:	7c c7                	jl     11f75 <bitmap_alloc_nbits+0x41>
            }
        }

        // 找到，设置各位，然后退出
        if (i >= count)
   11fae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fb1:	3b 45 10             	cmp    0x10(%ebp),%eax
   11fb4:	7c 1c                	jl     11fd2 <bitmap_alloc_nbits+0x9e>
        {
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   11fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fb9:	f7 d0                	not    %eax
   11fbb:	50                   	push   %eax
   11fbc:	ff 75 10             	pushl  0x10(%ebp)
   11fbf:	ff 75 f8             	pushl  -0x8(%ebp)
   11fc2:	ff 75 08             	pushl  0x8(%ebp)
   11fc5:	e8 41 fe ff ff       	call   11e0b <bitmap_set_bit>
   11fca:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   11fcd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11fd0:	eb 13                	jmp    11fe5 <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count)
   11fd2:	8b 45 08             	mov    0x8(%ebp),%eax
   11fd5:	8b 00                	mov    (%eax),%eax
   11fd7:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   11fda:	0f 8c 6d ff ff ff    	jl     11f4d <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   11fe0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11fe5:	c9                   	leave  
   11fe6:	c3                   	ret    

00011fe7 <hlt>:
{
   11fe7:	55                   	push   %ebp
   11fe8:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   11fea:	f4                   	hlt    
}
   11feb:	90                   	nop
   11fec:	5d                   	pop    %ebp
   11fed:	c3                   	ret    

00011fee <kernel_strcpy>:
#include "tools/klib.h"
#include "comm/types.h"
#include "comm/cpu_instr.h"

void kernel_strcpy(char *dest, const char *src)
{
   11fee:	55                   	push   %ebp
   11fef:	89 e5                	mov    %esp,%ebp
    if (!dest || !src)
   11ff1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11ff5:	74 3b                	je     12032 <kernel_strcpy+0x44>
   11ff7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11ffb:	74 35                	je     12032 <kernel_strcpy+0x44>
    {
        return;
    }

    while (*dest && *src)
   11ffd:	eb 17                	jmp    12016 <kernel_strcpy+0x28>
    {
        *dest++ = *src++;
   11fff:	8b 55 0c             	mov    0xc(%ebp),%edx
   12002:	8d 42 01             	lea    0x1(%edx),%eax
   12005:	89 45 0c             	mov    %eax,0xc(%ebp)
   12008:	8b 45 08             	mov    0x8(%ebp),%eax
   1200b:	8d 48 01             	lea    0x1(%eax),%ecx
   1200e:	89 4d 08             	mov    %ecx,0x8(%ebp)
   12011:	0f b6 12             	movzbl (%edx),%edx
   12014:	88 10                	mov    %dl,(%eax)
    while (*dest && *src)
   12016:	8b 45 08             	mov    0x8(%ebp),%eax
   12019:	0f b6 00             	movzbl (%eax),%eax
   1201c:	84 c0                	test   %al,%al
   1201e:	74 0a                	je     1202a <kernel_strcpy+0x3c>
   12020:	8b 45 0c             	mov    0xc(%ebp),%eax
   12023:	0f b6 00             	movzbl (%eax),%eax
   12026:	84 c0                	test   %al,%al
   12028:	75 d5                	jne    11fff <kernel_strcpy+0x11>
    }
    *dest = '\0';
   1202a:	8b 45 08             	mov    0x8(%ebp),%eax
   1202d:	c6 00 00             	movb   $0x0,(%eax)
   12030:	eb 01                	jmp    12033 <kernel_strcpy+0x45>
        return;
   12032:	90                   	nop
}
   12033:	5d                   	pop    %ebp
   12034:	c3                   	ret    

00012035 <kernel_strncpy>:

void kernel_strncpy(char *dest, const char *src, int size)
{
   12035:	55                   	push   %ebp
   12036:	89 e5                	mov    %esp,%ebp
   12038:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   1203b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1203f:	74 61                	je     120a2 <kernel_strncpy+0x6d>
   12041:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   12045:	74 5b                	je     120a2 <kernel_strncpy+0x6d>
   12047:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1204b:	74 55                	je     120a2 <kernel_strncpy+0x6d>
    {
        return;
    }

    char *d = dest;
   1204d:	8b 45 08             	mov    0x8(%ebp),%eax
   12050:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   12053:	8b 45 0c             	mov    0xc(%ebp),%eax
   12056:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while ((size-- > 0) && (*s))
   12059:	eb 17                	jmp    12072 <kernel_strncpy+0x3d>
    {
        *d++ = *s++;
   1205b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1205e:	8d 42 01             	lea    0x1(%edx),%eax
   12061:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12064:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12067:	8d 48 01             	lea    0x1(%eax),%ecx
   1206a:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   1206d:	0f b6 12             	movzbl (%edx),%edx
   12070:	88 10                	mov    %dl,(%eax)
    while ((size-- > 0) && (*s))
   12072:	8b 45 10             	mov    0x10(%ebp),%eax
   12075:	8d 50 ff             	lea    -0x1(%eax),%edx
   12078:	89 55 10             	mov    %edx,0x10(%ebp)
   1207b:	85 c0                	test   %eax,%eax
   1207d:	7e 0a                	jle    12089 <kernel_strncpy+0x54>
   1207f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12082:	0f b6 00             	movzbl (%eax),%eax
   12085:	84 c0                	test   %al,%al
   12087:	75 d2                	jne    1205b <kernel_strncpy+0x26>
    }
    if (size == 0)
   12089:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1208d:	75 0b                	jne    1209a <kernel_strncpy+0x65>
    {
        *(d - 1) = '\0';
   1208f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12092:	83 e8 01             	sub    $0x1,%eax
   12095:	c6 00 00             	movb   $0x0,(%eax)
   12098:	eb 09                	jmp    120a3 <kernel_strncpy+0x6e>
    }
    else
    {
        *d = '\0';
   1209a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1209d:	c6 00 00             	movb   $0x0,(%eax)
   120a0:	eb 01                	jmp    120a3 <kernel_strncpy+0x6e>
        return;
   120a2:	90                   	nop
    }
}
   120a3:	c9                   	leave  
   120a4:	c3                   	ret    

000120a5 <kernel_strncmp>:

int kernel_strncmp(const char *s1, const char *s2, int size)
{
   120a5:	55                   	push   %ebp
   120a6:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2)
   120a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   120ac:	74 06                	je     120b4 <kernel_strncmp+0xf>
   120ae:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   120b2:	75 13                	jne    120c7 <kernel_strncmp+0x22>
    {
        return -1;
   120b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   120b9:	eb 66                	jmp    12121 <kernel_strncmp+0x7c>
    }

    while (*s1 && *s2 && (*s1 == *s2) && size)
    {
        s1++;
   120bb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   120bf:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        size--;
   120c3:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    while (*s1 && *s2 && (*s1 == *s2) && size)
   120c7:	8b 45 08             	mov    0x8(%ebp),%eax
   120ca:	0f b6 00             	movzbl (%eax),%eax
   120cd:	84 c0                	test   %al,%al
   120cf:	74 20                	je     120f1 <kernel_strncmp+0x4c>
   120d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   120d4:	0f b6 00             	movzbl (%eax),%eax
   120d7:	84 c0                	test   %al,%al
   120d9:	74 16                	je     120f1 <kernel_strncmp+0x4c>
   120db:	8b 45 08             	mov    0x8(%ebp),%eax
   120de:	0f b6 10             	movzbl (%eax),%edx
   120e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e4:	0f b6 00             	movzbl (%eax),%eax
   120e7:	38 c2                	cmp    %al,%dl
   120e9:	75 06                	jne    120f1 <kernel_strncmp+0x4c>
   120eb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   120ef:	75 ca                	jne    120bb <kernel_strncmp+0x16>
    }
    // 相等返回0
    // s1="abc",s2="abcdef" 也属于相等
    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   120f1:	8b 45 08             	mov    0x8(%ebp),%eax
   120f4:	0f b6 00             	movzbl (%eax),%eax
   120f7:	84 c0                	test   %al,%al
   120f9:	74 21                	je     1211c <kernel_strncmp+0x77>
   120fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   120fe:	0f b6 00             	movzbl (%eax),%eax
   12101:	84 c0                	test   %al,%al
   12103:	74 17                	je     1211c <kernel_strncmp+0x77>
   12105:	8b 45 08             	mov    0x8(%ebp),%eax
   12108:	0f b6 10             	movzbl (%eax),%edx
   1210b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1210e:	0f b6 00             	movzbl (%eax),%eax
   12111:	38 c2                	cmp    %al,%dl
   12113:	74 07                	je     1211c <kernel_strncmp+0x77>
   12115:	b8 01 00 00 00       	mov    $0x1,%eax
   1211a:	eb 05                	jmp    12121 <kernel_strncmp+0x7c>
   1211c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12121:	5d                   	pop    %ebp
   12122:	c3                   	ret    

00012123 <kernel_strlen>:

int kernel_strlen(const char *str)
{
   12123:	55                   	push   %ebp
   12124:	89 e5                	mov    %esp,%ebp
   12126:	83 ec 10             	sub    $0x10,%esp
    if (str == (const char *)0)
   12129:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1212d:	75 07                	jne    12136 <kernel_strlen+0x13>
    {
        return 0;
   1212f:	b8 00 00 00 00       	mov    $0x0,%eax
   12134:	eb 26                	jmp    1215c <kernel_strlen+0x39>
    }

    const char *c = str;
   12136:	8b 45 08             	mov    0x8(%ebp),%eax
   12139:	89 45 fc             	mov    %eax,-0x4(%ebp)

    int len = 0;
   1213c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (*c++)
   12143:	eb 04                	jmp    12149 <kernel_strlen+0x26>
    {
        len++;
   12145:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (*c++)
   12149:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1214c:	8d 50 01             	lea    0x1(%eax),%edx
   1214f:	89 55 fc             	mov    %edx,-0x4(%ebp)
   12152:	0f b6 00             	movzbl (%eax),%eax
   12155:	84 c0                	test   %al,%al
   12157:	75 ec                	jne    12145 <kernel_strlen+0x22>
    }

    return len;
   12159:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   1215c:	c9                   	leave  
   1215d:	c3                   	ret    

0001215e <kernel_memcpy>:

void kernel_memcpy(void *dest, void *src, int size)
{
   1215e:	55                   	push   %ebp
   1215f:	89 e5                	mov    %esp,%ebp
   12161:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   12164:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12168:	74 40                	je     121aa <kernel_memcpy+0x4c>
   1216a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1216e:	74 3a                	je     121aa <kernel_memcpy+0x4c>
   12170:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   12174:	74 34                	je     121aa <kernel_memcpy+0x4c>
    {
        return;
    }

    uint8_t *s = (uint8_t *)src;
   12176:	8b 45 0c             	mov    0xc(%ebp),%eax
   12179:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *d = (uint8_t *)dest;
   1217c:	8b 45 08             	mov    0x8(%ebp),%eax
   1217f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   12182:	eb 17                	jmp    1219b <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   12184:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12187:	8d 42 01             	lea    0x1(%edx),%eax
   1218a:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1218d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12190:	8d 48 01             	lea    0x1(%eax),%ecx
   12193:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   12196:	0f b6 12             	movzbl (%edx),%edx
   12199:	88 10                	mov    %dl,(%eax)
    while (size--)
   1219b:	8b 45 10             	mov    0x10(%ebp),%eax
   1219e:	8d 50 ff             	lea    -0x1(%eax),%edx
   121a1:	89 55 10             	mov    %edx,0x10(%ebp)
   121a4:	85 c0                	test   %eax,%eax
   121a6:	75 dc                	jne    12184 <kernel_memcpy+0x26>
   121a8:	eb 01                	jmp    121ab <kernel_memcpy+0x4d>
        return;
   121aa:	90                   	nop
    }
}
   121ab:	c9                   	leave  
   121ac:	c3                   	ret    

000121ad <kernel_memset>:

// 内存逐字节设置v
void kernel_memset(void *dest, uint8_t v, int size)
{
   121ad:	55                   	push   %ebp
   121ae:	89 e5                	mov    %esp,%ebp
   121b0:	83 ec 14             	sub    $0x14,%esp
   121b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   121b6:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (!dest || !size)
   121b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   121bd:	74 2c                	je     121eb <kernel_memset+0x3e>
   121bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   121c3:	74 26                	je     121eb <kernel_memset+0x3e>
    {
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   121c5:	8b 45 08             	mov    0x8(%ebp),%eax
   121c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (size--)
   121cb:	eb 0f                	jmp    121dc <kernel_memset+0x2f>
    {
        *d++ = v;
   121cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d0:	8d 50 01             	lea    0x1(%eax),%edx
   121d3:	89 55 fc             	mov    %edx,-0x4(%ebp)
   121d6:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   121da:	88 10                	mov    %dl,(%eax)
    while (size--)
   121dc:	8b 45 10             	mov    0x10(%ebp),%eax
   121df:	8d 50 ff             	lea    -0x1(%eax),%edx
   121e2:	89 55 10             	mov    %edx,0x10(%ebp)
   121e5:	85 c0                	test   %eax,%eax
   121e7:	75 e4                	jne    121cd <kernel_memset+0x20>
   121e9:	eb 01                	jmp    121ec <kernel_memset+0x3f>
        return;
   121eb:	90                   	nop
    }
}
   121ec:	c9                   	leave  
   121ed:	c3                   	ret    

000121ee <kernel_memcmp>:

int kernel_memcmp(void *d1, void *d2, int size)
{
   121ee:	55                   	push   %ebp
   121ef:	89 e5                	mov    %esp,%ebp
   121f1:	83 ec 10             	sub    $0x10,%esp
    if (!d1 || !d2)
   121f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   121f8:	74 06                	je     12200 <kernel_memcmp+0x12>
   121fa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   121fe:	75 07                	jne    12207 <kernel_memcmp+0x19>
    {
        return 1;
   12200:	b8 01 00 00 00       	mov    $0x1,%eax
   12205:	eb 43                	jmp    1224a <kernel_memcmp+0x5c>
    }

    uint8_t *p_d1 = (uint8_t *)d1;
   12207:	8b 45 08             	mov    0x8(%ebp),%eax
   1220a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2 = (uint8_t *)d2;
   1220d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12210:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   12213:	eb 23                	jmp    12238 <kernel_memcmp+0x4a>
    {
        if (*p_d1++ != *p_d2++)
   12215:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12218:	8d 50 01             	lea    0x1(%eax),%edx
   1221b:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1221e:	0f b6 08             	movzbl (%eax),%ecx
   12221:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12224:	8d 50 01             	lea    0x1(%eax),%edx
   12227:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1222a:	0f b6 00             	movzbl (%eax),%eax
   1222d:	38 c1                	cmp    %al,%cl
   1222f:	74 07                	je     12238 <kernel_memcmp+0x4a>
        {
            return 1;
   12231:	b8 01 00 00 00       	mov    $0x1,%eax
   12236:	eb 12                	jmp    1224a <kernel_memcmp+0x5c>
    while (size--)
   12238:	8b 45 10             	mov    0x10(%ebp),%eax
   1223b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1223e:	89 55 10             	mov    %edx,0x10(%ebp)
   12241:	85 c0                	test   %eax,%eax
   12243:	75 d0                	jne    12215 <kernel_memcmp+0x27>
        }
    }

    // 内存一样返回0
    return 0;
   12245:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1224a:	c9                   	leave  
   1224b:	c3                   	ret    

0001224c <kernel_itoa>:

void kernel_itoa(char *buf, int num, int base)
{
   1224c:	55                   	push   %ebp
   1224d:	89 e5                	mov    %esp,%ebp
   1224f:	53                   	push   %ebx
   12250:	83 ec 20             	sub    $0x20,%esp
    // 转换字符索引[-15, -14, ...-1, 0, 1, ...., 14, 15]
    static const char *num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char *p = buf;
   12253:	8b 45 08             	mov    0x8(%ebp),%eax
   12256:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   12259:	8b 45 0c             	mov    0xc(%ebp),%eax
   1225c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 仅支持部分进制
    if ((base != 2) && (base != 8) && (base != 10) && (base != 16))
   1225f:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   12263:	74 1d                	je     12282 <kernel_itoa+0x36>
   12265:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   12269:	74 17                	je     12282 <kernel_itoa+0x36>
   1226b:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1226f:	74 11                	je     12282 <kernel_itoa+0x36>
   12271:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   12275:	74 0b                	je     12282 <kernel_itoa+0x36>
    {
        *p = '\0';
   12277:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1227a:	c6 00 00             	movb   $0x0,(%eax)
        return;
   1227d:	e9 03 01 00 00       	jmp    12385 <kernel_itoa+0x139>
    }

    // 只支持十进制负数
    int signed_num = 0;
   12282:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10))
   12289:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1228d:	79 19                	jns    122a8 <kernel_itoa+0x5c>
   1228f:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   12293:	75 13                	jne    122a8 <kernel_itoa+0x5c>
    {
        *p++ = '-';
   12295:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12298:	8d 50 01             	lea    0x1(%eax),%edx
   1229b:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1229e:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   122a1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num)
   122a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   122ac:	74 3b                	je     122e9 <kernel_itoa+0x9d>
    {
        do
        {
            char ch = num2ch[num % base + 15];
   122ae:	8b 0d 40 30 01 00    	mov    0x13040,%ecx
   122b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   122b7:	99                   	cltd   
   122b8:	f7 7d 10             	idivl  0x10(%ebp)
   122bb:	89 d0                	mov    %edx,%eax
   122bd:	83 c0 0f             	add    $0xf,%eax
   122c0:	01 c8                	add    %ecx,%eax
   122c2:	0f b6 00             	movzbl (%eax),%eax
   122c5:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   122c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   122cb:	8d 50 01             	lea    0x1(%eax),%edx
   122ce:	89 55 f8             	mov    %edx,-0x8(%ebp)
   122d1:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   122d5:	88 10                	mov    %dl,(%eax)
            num /= base;
   122d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   122da:	99                   	cltd   
   122db:	f7 7d 10             	idivl  0x10(%ebp)
   122de:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   122e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   122e5:	75 c7                	jne    122ae <kernel_itoa+0x62>
   122e7:	eb 4b                	jmp    12334 <kernel_itoa+0xe8>
    }
    else
    {
        uint32_t u_num = (uint32_t)num;
   122e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   122ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do
        {
            char ch = num2ch[u_num % base + 15];
   122ef:	8b 0d 40 30 01 00    	mov    0x13040,%ecx
   122f5:	8b 5d 10             	mov    0x10(%ebp),%ebx
   122f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122fb:	ba 00 00 00 00       	mov    $0x0,%edx
   12300:	f7 f3                	div    %ebx
   12302:	89 d0                	mov    %edx,%eax
   12304:	83 c0 0f             	add    $0xf,%eax
   12307:	01 c8                	add    %ecx,%eax
   12309:	0f b6 00             	movzbl (%eax),%eax
   1230c:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   1230f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12312:	8d 50 01             	lea    0x1(%eax),%edx
   12315:	89 55 f8             	mov    %edx,-0x8(%ebp)
   12318:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   1231c:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   1231e:	8b 5d 10             	mov    0x10(%ebp),%ebx
   12321:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12324:	ba 00 00 00 00       	mov    $0x0,%edx
   12329:	f7 f3                	div    %ebx
   1232b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   1232e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12332:	75 bb                	jne    122ef <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   12334:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12337:	8d 50 ff             	lea    -0x1(%eax),%edx
   1233a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1233d:	c6 00 00             	movb   $0x0,(%eax)

    // 将转换结果逆序，生成最终的结果
    char *start = (!signed_num) ? buf : buf + 1;
   12340:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12344:	74 08                	je     1234e <kernel_itoa+0x102>
   12346:	8b 45 08             	mov    0x8(%ebp),%eax
   12349:	83 c0 01             	add    $0x1,%eax
   1234c:	eb 03                	jmp    12351 <kernel_itoa+0x105>
   1234e:	8b 45 08             	mov    0x8(%ebp),%eax
   12351:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p)
   12354:	eb 27                	jmp    1237d <kernel_itoa+0x131>
    {
        char ch = *start;
   12356:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12359:	0f b6 00             	movzbl (%eax),%eax
   1235c:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   1235f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12362:	0f b6 10             	movzbl (%eax),%edx
   12365:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12368:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   1236a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1236d:	8d 50 ff             	lea    -0x1(%eax),%edx
   12370:	89 55 f8             	mov    %edx,-0x8(%ebp)
   12373:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   12377:	88 10                	mov    %dl,(%eax)
        start++;
   12379:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p)
   1237d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12380:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12383:	72 d1                	jb     12356 <kernel_itoa+0x10a>
    }
}
   12385:	83 c4 20             	add    $0x20,%esp
   12388:	5b                   	pop    %ebx
   12389:	5d                   	pop    %ebp
   1238a:	c3                   	ret    

0001238b <kernel_vsprintf>:
// buf 为最终显示的目标
// fmt 为整个字符串
// args 为va_list 可变变量
void kernel_vsprintf(char *buf, const char *fmt, va_list args)
{
   1238b:	55                   	push   %ebp
   1238c:	89 e5                	mov    %esp,%ebp
   1238e:	83 ec 20             	sub    $0x20,%esp
    enum
    {
        NORMAL,
        READ_FMT
    } state = NORMAL;
   12391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char ch;
    char *curr = buf;
   12398:	8b 45 08             	mov    0x8(%ebp),%eax
   1239b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while ((ch = *fmt++))
   1239e:	e9 17 01 00 00       	jmp    124ba <kernel_vsprintf+0x12f>
    {
        switch (state)
   123a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123a6:	85 c0                	test   %eax,%eax
   123a8:	74 0a                	je     123b4 <kernel_vsprintf+0x29>
   123aa:	83 f8 01             	cmp    $0x1,%eax
   123ad:	74 2b                	je     123da <kernel_vsprintf+0x4f>
   123af:	e9 06 01 00 00       	jmp    124ba <kernel_vsprintf+0x12f>
        {
        // 普通字符
        case NORMAL:
            if (ch == '%')
   123b4:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   123b8:	75 0c                	jne    123c6 <kernel_vsprintf+0x3b>
            {
                state = READ_FMT;
   123ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   123c1:	e9 f4 00 00 00       	jmp    124ba <kernel_vsprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   123c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   123c9:	8d 50 01             	lea    0x1(%eax),%edx
   123cc:	89 55 f8             	mov    %edx,-0x8(%ebp)
   123cf:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   123d3:	88 10                	mov    %dl,(%eax)
            }
            break;
   123d5:	e9 e0 00 00 00       	jmp    124ba <kernel_vsprintf+0x12f>
        // 格式化控制字符，只支持部分
        case READ_FMT:
            if (ch == 'd')
   123da:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   123de:	75 31                	jne    12411 <kernel_vsprintf+0x86>
            {
                int num = va_arg(args, int);
   123e0:	8b 45 10             	mov    0x10(%ebp),%eax
   123e3:	8d 50 04             	lea    0x4(%eax),%edx
   123e6:	89 55 10             	mov    %edx,0x10(%ebp)
   123e9:	8b 00                	mov    (%eax),%eax
   123eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr, num, 10);
   123ee:	6a 0a                	push   $0xa
   123f0:	ff 75 e4             	pushl  -0x1c(%ebp)
   123f3:	ff 75 f8             	pushl  -0x8(%ebp)
   123f6:	e8 51 fe ff ff       	call   1224c <kernel_itoa>
   123fb:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr); // 移动到下一个
   123fe:	ff 75 f8             	pushl  -0x8(%ebp)
   12401:	e8 1d fd ff ff       	call   12123 <kernel_strlen>
   12406:	83 c4 04             	add    $0x4,%esp
   12409:	01 45 f8             	add    %eax,-0x8(%ebp)
   1240c:	e9 a1 00 00 00       	jmp    124b2 <kernel_vsprintf+0x127>
            }
            else if (ch == 'x')
   12411:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   12415:	75 2e                	jne    12445 <kernel_vsprintf+0xba>
            {
                int num = va_arg(args, int);
   12417:	8b 45 10             	mov    0x10(%ebp),%eax
   1241a:	8d 50 04             	lea    0x4(%eax),%edx
   1241d:	89 55 10             	mov    %edx,0x10(%ebp)
   12420:	8b 00                	mov    (%eax),%eax
   12422:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr, num, 16);
   12425:	6a 10                	push   $0x10
   12427:	ff 75 e8             	pushl  -0x18(%ebp)
   1242a:	ff 75 f8             	pushl  -0x8(%ebp)
   1242d:	e8 1a fe ff ff       	call   1224c <kernel_itoa>
   12432:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   12435:	ff 75 f8             	pushl  -0x8(%ebp)
   12438:	e8 e6 fc ff ff       	call   12123 <kernel_strlen>
   1243d:	83 c4 04             	add    $0x4,%esp
   12440:	01 45 f8             	add    %eax,-0x8(%ebp)
   12443:	eb 6d                	jmp    124b2 <kernel_vsprintf+0x127>
            }
            else if (ch == 'c')
   12445:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   12449:	75 1f                	jne    1246a <kernel_vsprintf+0xdf>
            {
                char c = va_arg(args, int);
   1244b:	8b 45 10             	mov    0x10(%ebp),%eax
   1244e:	8d 50 04             	lea    0x4(%eax),%edx
   12451:	89 55 10             	mov    %edx,0x10(%ebp)
   12454:	8b 00                	mov    (%eax),%eax
   12456:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = c;
   12459:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1245c:	8d 50 01             	lea    0x1(%eax),%edx
   1245f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   12462:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   12466:	88 10                	mov    %dl,(%eax)
   12468:	eb 48                	jmp    124b2 <kernel_vsprintf+0x127>
            }
            else if (ch == 's')
   1246a:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   1246e:	75 42                	jne    124b2 <kernel_vsprintf+0x127>
            {
                const char *str = va_arg(args, char *);
   12470:	8b 45 10             	mov    0x10(%ebp),%eax
   12473:	8d 50 04             	lea    0x4(%eax),%edx
   12476:	89 55 10             	mov    %edx,0x10(%ebp)
   12479:	8b 00                	mov    (%eax),%eax
   1247b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   1247e:	ff 75 f4             	pushl  -0xc(%ebp)
   12481:	e8 9d fc ff ff       	call   12123 <kernel_strlen>
   12486:	83 c4 04             	add    $0x4,%esp
   12489:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while (len--)
   1248c:	eb 17                	jmp    124a5 <kernel_vsprintf+0x11a>
                {
                    *curr++ = *str++;
   1248e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12491:	8d 42 01             	lea    0x1(%edx),%eax
   12494:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12497:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1249a:	8d 48 01             	lea    0x1(%eax),%ecx
   1249d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   124a0:	0f b6 12             	movzbl (%edx),%edx
   124a3:	88 10                	mov    %dl,(%eax)
                while (len--)
   124a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124a8:	8d 50 ff             	lea    -0x1(%eax),%edx
   124ab:	89 55 f0             	mov    %edx,-0x10(%ebp)
   124ae:	85 c0                	test   %eax,%eax
   124b0:	75 dc                	jne    1248e <kernel_vsprintf+0x103>
                }
            }
            state = NORMAL;
   124b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   124b9:	90                   	nop
    while ((ch = *fmt++))
   124ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   124bd:	8d 50 01             	lea    0x1(%eax),%edx
   124c0:	89 55 0c             	mov    %edx,0xc(%ebp)
   124c3:	0f b6 00             	movzbl (%eax),%eax
   124c6:	88 45 ef             	mov    %al,-0x11(%ebp)
   124c9:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   124cd:	0f 85 d0 fe ff ff    	jne    123a3 <kernel_vsprintf+0x18>
        }
    }
}
   124d3:	90                   	nop
   124d4:	c9                   	leave  
   124d5:	c3                   	ret    

000124d6 <panic>:

void panic(const char *file, int line, const char *func, const char *cond)
{
   124d6:	55                   	push   %ebp
   124d7:	89 e5                	mov    %esp,%ebp
   124d9:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed! %s", cond);
   124dc:	83 ec 08             	sub    $0x8,%esp
   124df:	ff 75 14             	pushl  0x14(%ebp)
   124e2:	68 c0 2c 01 00       	push   $0x12cc0
   124e7:	e8 cd 02 00 00       	call   127b9 <log_printf>
   124ec:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline %d\nfunc: %s\n", file, line, func);
   124ef:	ff 75 10             	pushl  0x10(%ebp)
   124f2:	ff 75 0c             	pushl  0xc(%ebp)
   124f5:	ff 75 08             	pushl  0x8(%ebp)
   124f8:	68 d2 2c 01 00       	push   $0x12cd2
   124fd:	e8 b7 02 00 00       	call   127b9 <log_printf>
   12502:	83 c4 10             	add    $0x10,%esp

    for (;;)
    {
        hlt();
   12505:	e8 dd fa ff ff       	call   11fe7 <hlt>
   1250a:	eb f9                	jmp    12505 <panic+0x2f>

0001250c <list_is_empty>:
{
   1250c:	55                   	push   %ebp
   1250d:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   1250f:	8b 45 08             	mov    0x8(%ebp),%eax
   12512:	8b 40 08             	mov    0x8(%eax),%eax
   12515:	85 c0                	test   %eax,%eax
   12517:	0f 94 c0             	sete   %al
   1251a:	0f b6 c0             	movzbl %al,%eax
}
   1251d:	5d                   	pop    %ebp
   1251e:	c3                   	ret    

0001251f <list_init>:
/**
 * 初始化链表
 * @param list 待初始化的链表
 */
void list_init(list_t *list)
{
   1251f:	55                   	push   %ebp
   12520:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   12522:	8b 45 08             	mov    0x8(%ebp),%eax
   12525:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1252c:	8b 45 08             	mov    0x8(%ebp),%eax
   1252f:	8b 50 04             	mov    0x4(%eax),%edx
   12532:	8b 45 08             	mov    0x8(%ebp),%eax
   12535:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   12537:	8b 45 08             	mov    0x8(%ebp),%eax
   1253a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   12541:	90                   	nop
   12542:	5d                   	pop    %ebp
   12543:	c3                   	ret    

00012544 <list_insert_first>:
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node)
{
   12544:	55                   	push   %ebp
   12545:	89 e5                	mov    %esp,%ebp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
   12547:	8b 45 08             	mov    0x8(%ebp),%eax
   1254a:	8b 10                	mov    (%eax),%edx
   1254c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1254f:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   12552:	8b 45 0c             	mov    0xc(%ebp),%eax
   12555:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list))
   1255b:	ff 75 08             	pushl  0x8(%ebp)
   1255e:	e8 a9 ff ff ff       	call   1250c <list_is_empty>
   12563:	83 c4 04             	add    $0x4,%esp
   12566:	85 c0                	test   %eax,%eax
   12568:	74 15                	je     1257f <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   1256a:	8b 45 08             	mov    0x8(%ebp),%eax
   1256d:	8b 55 0c             	mov    0xc(%ebp),%edx
   12570:	89 10                	mov    %edx,(%eax)
   12572:	8b 45 08             	mov    0x8(%ebp),%eax
   12575:	8b 10                	mov    (%eax),%edx
   12577:	8b 45 08             	mov    0x8(%ebp),%eax
   1257a:	89 50 04             	mov    %edx,0x4(%eax)
   1257d:	eb 12                	jmp    12591 <list_insert_first+0x4d>
    }
    else
    {
        // 否则，设置好原本第一个结点的pre
        list->first->pre = node;
   1257f:	8b 45 08             	mov    0x8(%ebp),%eax
   12582:	8b 00                	mov    (%eax),%eax
   12584:	8b 55 0c             	mov    0xc(%ebp),%edx
   12587:	89 10                	mov    %edx,(%eax)

        // 调整first指向
        list->first = node;
   12589:	8b 45 08             	mov    0x8(%ebp),%eax
   1258c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1258f:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   12591:	8b 45 08             	mov    0x8(%ebp),%eax
   12594:	8b 40 08             	mov    0x8(%eax),%eax
   12597:	8d 50 01             	lea    0x1(%eax),%edx
   1259a:	8b 45 08             	mov    0x8(%ebp),%eax
   1259d:	89 50 08             	mov    %edx,0x8(%eax)
}
   125a0:	90                   	nop
   125a1:	c9                   	leave  
   125a2:	c3                   	ret    

000125a3 <list_insert_last>:
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node)
{
   125a3:	55                   	push   %ebp
   125a4:	89 e5                	mov    %esp,%ebp
    // 设置好结点本身
    node->pre = list->last;
   125a6:	8b 45 08             	mov    0x8(%ebp),%eax
   125a9:	8b 50 04             	mov    0x4(%eax),%edx
   125ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   125af:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t *)0;
   125b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   125b4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list))
   125bb:	ff 75 08             	pushl  0x8(%ebp)
   125be:	e8 49 ff ff ff       	call   1250c <list_is_empty>
   125c3:	83 c4 04             	add    $0x4,%esp
   125c6:	85 c0                	test   %eax,%eax
   125c8:	74 16                	je     125e0 <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   125ca:	8b 45 08             	mov    0x8(%ebp),%eax
   125cd:	8b 55 0c             	mov    0xc(%ebp),%edx
   125d0:	89 50 04             	mov    %edx,0x4(%eax)
   125d3:	8b 45 08             	mov    0x8(%ebp),%eax
   125d6:	8b 50 04             	mov    0x4(%eax),%edx
   125d9:	8b 45 08             	mov    0x8(%ebp),%eax
   125dc:	89 10                	mov    %edx,(%eax)
   125de:	eb 15                	jmp    125f5 <list_insert_last+0x52>
    }
    else
    {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
   125e0:	8b 45 08             	mov    0x8(%ebp),%eax
   125e3:	8b 40 04             	mov    0x4(%eax),%eax
   125e6:	8b 55 0c             	mov    0xc(%ebp),%edx
   125e9:	89 50 04             	mov    %edx,0x4(%eax)

        // node变成了新的后继结点
        list->last = node;
   125ec:	8b 45 08             	mov    0x8(%ebp),%eax
   125ef:	8b 55 0c             	mov    0xc(%ebp),%edx
   125f2:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   125f5:	8b 45 08             	mov    0x8(%ebp),%eax
   125f8:	8b 40 08             	mov    0x8(%eax),%eax
   125fb:	8d 50 01             	lea    0x1(%eax),%edx
   125fe:	8b 45 08             	mov    0x8(%ebp),%eax
   12601:	89 50 08             	mov    %edx,0x8(%eax)
}
   12604:	90                   	nop
   12605:	c9                   	leave  
   12606:	c3                   	ret    

00012607 <list_remove_first>:
 * 移除指定链表的头部
 * @param list 操作的链表
 * @return 链表的第一个结点
 */
list_node_t *list_remove_first(list_t *list)
{
   12607:	55                   	push   %ebp
   12608:	89 e5                	mov    %esp,%ebp
   1260a:	83 ec 10             	sub    $0x10,%esp
    // 表项为空，返回空
    if (list_is_empty(list))
   1260d:	ff 75 08             	pushl  0x8(%ebp)
   12610:	e8 f7 fe ff ff       	call   1250c <list_is_empty>
   12615:	83 c4 04             	add    $0x4,%esp
   12618:	85 c0                	test   %eax,%eax
   1261a:	74 07                	je     12623 <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   1261c:	b8 00 00 00 00       	mov    $0x0,%eax
   12621:	eb 5a                	jmp    1267d <list_remove_first+0x76>
    }

    // 取第一个结点
    list_node_t *remove_node = list->first;
   12623:	8b 45 08             	mov    0x8(%ebp),%eax
   12626:	8b 00                	mov    (%eax),%eax
   12628:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 将first往表尾移1个，跳过刚才移过的那个，如果没有后继，则first=0
    list->first = remove_node->next;
   1262b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1262e:	8b 50 04             	mov    0x4(%eax),%edx
   12631:	8b 45 08             	mov    0x8(%ebp),%eax
   12634:	89 10                	mov    %edx,(%eax)
    if (list->first == (list_node_t *)0)
   12636:	8b 45 08             	mov    0x8(%ebp),%eax
   12639:	8b 00                	mov    (%eax),%eax
   1263b:	85 c0                	test   %eax,%eax
   1263d:	75 0c                	jne    1264b <list_remove_first+0x44>
    {
        // node为最后一个结点
        list->last = (list_node_t *)0;
   1263f:	8b 45 08             	mov    0x8(%ebp),%eax
   12642:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   12649:	eb 0c                	jmp    12657 <list_remove_first+0x50>
    }
    else
    {
        // 非最后一结点，将后继的前驱清0
        remove_node->next->pre = (list_node_t *)0;
   1264b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1264e:	8b 40 04             	mov    0x4(%eax),%eax
   12651:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

    // 调整node自己，置0，因为没有后继结点
    remove_node->next = remove_node->pre = (list_node_t *)0;
   12657:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1265a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   12660:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12663:	8b 10                	mov    (%eax),%edx
   12665:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12668:	89 50 04             	mov    %edx,0x4(%eax)

    // 同时调整计数值
    list->count--;
   1266b:	8b 45 08             	mov    0x8(%ebp),%eax
   1266e:	8b 40 08             	mov    0x8(%eax),%eax
   12671:	8d 50 ff             	lea    -0x1(%eax),%edx
   12674:	8b 45 08             	mov    0x8(%ebp),%eax
   12677:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   1267a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1267d:	c9                   	leave  
   1267e:	c3                   	ret    

0001267f <list_remove>:
/**
 * 移除指定链表的中的表项
 * 不检查node是否在结点中
 */
list_node_t *list_remove(list_t *list, list_node_t *remove_node)
{
   1267f:	55                   	push   %ebp
   12680:	89 e5                	mov    %esp,%ebp
    // 如果是头，头往前移
    if (remove_node == list->first)
   12682:	8b 45 08             	mov    0x8(%ebp),%eax
   12685:	8b 00                	mov    (%eax),%eax
   12687:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1268a:	75 0b                	jne    12697 <list_remove+0x18>
    {
        list->first = remove_node->next;
   1268c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1268f:	8b 50 04             	mov    0x4(%eax),%edx
   12692:	8b 45 08             	mov    0x8(%ebp),%eax
   12695:	89 10                	mov    %edx,(%eax)
    }

    // 如果是尾，则尾往回移
    if (remove_node == list->last)
   12697:	8b 45 08             	mov    0x8(%ebp),%eax
   1269a:	8b 40 04             	mov    0x4(%eax),%eax
   1269d:	39 45 0c             	cmp    %eax,0xc(%ebp)
   126a0:	75 0b                	jne    126ad <list_remove+0x2e>
    {
        list->last = remove_node->pre;
   126a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   126a5:	8b 10                	mov    (%eax),%edx
   126a7:	8b 45 08             	mov    0x8(%ebp),%eax
   126aa:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有前，则调整前的后继
    if (remove_node->pre)
   126ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   126b0:	8b 00                	mov    (%eax),%eax
   126b2:	85 c0                	test   %eax,%eax
   126b4:	74 0e                	je     126c4 <list_remove+0x45>
    {
        remove_node->pre->next = remove_node->next;
   126b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   126b9:	8b 00                	mov    (%eax),%eax
   126bb:	8b 55 0c             	mov    0xc(%ebp),%edx
   126be:	8b 52 04             	mov    0x4(%edx),%edx
   126c1:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有后，则调整后往前的
    if (remove_node->next)
   126c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c7:	8b 40 04             	mov    0x4(%eax),%eax
   126ca:	85 c0                	test   %eax,%eax
   126cc:	74 0d                	je     126db <list_remove+0x5c>
    {
        remove_node->next->pre = remove_node->pre;
   126ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   126d1:	8b 40 04             	mov    0x4(%eax),%eax
   126d4:	8b 55 0c             	mov    0xc(%ebp),%edx
   126d7:	8b 12                	mov    (%edx),%edx
   126d9:	89 10                	mov    %edx,(%eax)
    }

    // 清空node指向
    remove_node->pre = remove_node->next = (list_node_t *)0;
   126db:	8b 45 0c             	mov    0xc(%ebp),%eax
   126de:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   126e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   126e8:	8b 50 04             	mov    0x4(%eax),%edx
   126eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   126ee:	89 10                	mov    %edx,(%eax)
    --list->count;
   126f0:	8b 45 08             	mov    0x8(%ebp),%eax
   126f3:	8b 40 08             	mov    0x8(%eax),%eax
   126f6:	8d 50 ff             	lea    -0x1(%eax),%edx
   126f9:	8b 45 08             	mov    0x8(%ebp),%eax
   126fc:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   126ff:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   12702:	5d                   	pop    %ebp
   12703:	c3                   	ret    

00012704 <inb>:
{
   12704:	55                   	push   %ebp
   12705:	89 e5                	mov    %esp,%ebp
   12707:	83 ec 14             	sub    $0x14,%esp
   1270a:	8b 45 08             	mov    0x8(%ebp),%eax
   1270d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12711:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12715:	89 c2                	mov    %eax,%edx
   12717:	ec                   	in     (%dx),%al
   12718:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1271b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1271f:	c9                   	leave  
   12720:	c3                   	ret    

00012721 <outb>:
{
   12721:	55                   	push   %ebp
   12722:	89 e5                	mov    %esp,%ebp
   12724:	83 ec 08             	sub    $0x8,%esp
   12727:	8b 55 08             	mov    0x8(%ebp),%edx
   1272a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1272d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12731:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   12734:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12738:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1273c:	ee                   	out    %al,(%dx)
}
   1273d:	90                   	nop
   1273e:	c9                   	leave  
   1273f:	c3                   	ret    

00012740 <log_init>:
#define COM1_PORT 0x3F8 // RS232端口0初始化

static mutex_t mutex;

void log_init(void)
{
   12740:	55                   	push   %ebp
   12741:	89 e5                	mov    %esp,%ebp
   12743:	83 ec 08             	sub    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); // Disable all interrupts
   12746:	6a 00                	push   $0x0
   12748:	68 f9 03 00 00       	push   $0x3f9
   1274d:	e8 cf ff ff ff       	call   12721 <outb>
   12752:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor)
   12755:	68 80 00 00 00       	push   $0x80
   1275a:	68 fb 03 00 00       	push   $0x3fb
   1275f:	e8 bd ff ff ff       	call   12721 <outb>
   12764:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud
   12767:	6a 03                	push   $0x3
   12769:	68 f8 03 00 00       	push   $0x3f8
   1276e:	e8 ae ff ff ff       	call   12721 <outb>
   12773:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); //                  (hi byte)
   12776:	6a 00                	push   $0x0
   12778:	68 f9 03 00 00       	push   $0x3f9
   1277d:	e8 9f ff ff ff       	call   12721 <outb>
   12782:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x03); // 8 bits, no parity, one stop bit
   12785:	6a 03                	push   $0x3
   12787:	68 fb 03 00 00       	push   $0x3fb
   1278c:	e8 90 ff ff ff       	call   12721 <outb>
   12791:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 2, 0xC7); // Enable FIFO, clear them, with 14-byte threshold
   12794:	68 c7 00 00 00       	push   $0xc7
   12799:	68 fa 03 00 00       	push   $0x3fa
   1279e:	e8 7e ff ff ff       	call   12721 <outb>
   127a3:	83 c4 08             	add    $0x8,%esp
    mutex_init(&mutex);
   127a6:	83 ec 0c             	sub    $0xc,%esp
   127a9:	68 b0 8e 01 00       	push   $0x18eb0
   127ae:	e8 2c f3 ff ff       	call   11adf <mutex_init>
   127b3:	83 c4 10             	add    $0x10,%esp
}
   127b6:	90                   	nop
   127b7:	c9                   	leave  
   127b8:	c3                   	ret    

000127b9 <log_printf>:

void log_printf(const char *fmt, ...)
{
   127b9:	55                   	push   %ebp
   127ba:	89 e5                	mov    %esp,%ebp
   127bc:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf, '\0', sizeof(str_buf));
   127c2:	83 ec 04             	sub    $0x4,%esp
   127c5:	68 80 00 00 00       	push   $0x80
   127ca:	6a 00                	push   $0x0
   127cc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   127d2:	50                   	push   %eax
   127d3:	e8 d5 f9 ff ff       	call   121ad <kernel_memset>
   127d8:	83 c4 10             	add    $0x10,%esp
    va_start(args, fmt);
   127db:	8d 45 0c             	lea    0xc(%ebp),%eax
   127de:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    kernel_vsprintf(str_buf, fmt, args);
   127e4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
   127ea:	83 ec 04             	sub    $0x4,%esp
   127ed:	50                   	push   %eax
   127ee:	ff 75 08             	pushl  0x8(%ebp)
   127f1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   127f7:	50                   	push   %eax
   127f8:	e8 8e fb ff ff       	call   1238b <kernel_vsprintf>
   127fd:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    // 临界区进入
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   12800:	83 ec 0c             	sub    $0xc,%esp
   12803:	68 b0 8e 01 00       	push   $0x18eb0
   12808:	e8 00 f3 ff ff       	call   11b0d <mutex_lock>
   1280d:	83 c4 10             	add    $0x10,%esp
    const char *p = str_buf;
   12810:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12816:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != '\0')
   12819:	eb 3b                	jmp    12856 <log_printf+0x9d>
    {
        // 检查串口是否忙
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0)
   1281b:	90                   	nop
   1281c:	83 ec 0c             	sub    $0xc,%esp
   1281f:	68 fd 03 00 00       	push   $0x3fd
   12824:	e8 db fe ff ff       	call   12704 <inb>
   12829:	83 c4 10             	add    $0x10,%esp
   1282c:	0f b6 c0             	movzbl %al,%eax
   1282f:	83 e0 40             	and    $0x40,%eax
   12832:	85 c0                	test   %eax,%eax
   12834:	74 e6                	je     1281c <log_printf+0x63>
        {
        }
        outb(COM1_PORT, *p++);
   12836:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12839:	8d 50 01             	lea    0x1(%eax),%edx
   1283c:	89 55 f4             	mov    %edx,-0xc(%ebp)
   1283f:	0f b6 00             	movzbl (%eax),%eax
   12842:	0f b6 c0             	movzbl %al,%eax
   12845:	83 ec 08             	sub    $0x8,%esp
   12848:	50                   	push   %eax
   12849:	68 f8 03 00 00       	push   $0x3f8
   1284e:	e8 ce fe ff ff       	call   12721 <outb>
   12853:	83 c4 10             	add    $0x10,%esp
    while (*p != '\0')
   12856:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12859:	0f b6 00             	movzbl (%eax),%eax
   1285c:	84 c0                	test   %al,%al
   1285e:	75 bb                	jne    1281b <log_printf+0x62>
    }
    // 增加默认换行
    outb(COM1_PORT, '\r'); // 行号不变，列号归零
   12860:	83 ec 08             	sub    $0x8,%esp
   12863:	6a 0d                	push   $0xd
   12865:	68 f8 03 00 00       	push   $0x3f8
   1286a:	e8 b2 fe ff ff       	call   12721 <outb>
   1286f:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT, '\n'); // 列号不变，行号+1
   12872:	83 ec 08             	sub    $0x8,%esp
   12875:	6a 0a                	push   $0xa
   12877:	68 f8 03 00 00       	push   $0x3f8
   1287c:	e8 a0 fe ff ff       	call   12721 <outb>
   12881:	83 c4 10             	add    $0x10,%esp
    // irq_leave_protection(state); // 临界区退出
    mutex_unlock(&mutex);
   12884:	83 ec 0c             	sub    $0xc,%esp
   12887:	68 b0 8e 01 00       	push   $0x18eb0
   1288c:	e8 10 f3 ff ff       	call   11ba1 <mutex_unlock>
   12891:	83 c4 10             	add    $0x10,%esp
   12894:	90                   	nop
   12895:	c9                   	leave  
   12896:	c3                   	ret    
