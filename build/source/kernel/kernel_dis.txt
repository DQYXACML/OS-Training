
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
C:/diy-x86os-master/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000023dc memsz 0x000072b0 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000203d  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000398  00012040  00012040  00003040  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000004  000123d8  000123d8  000033d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00004ed0  000123e0  000123e0  000033dc  2**5
                  ALLOC
  4 .debug_line   000013f1  00000000  00000000  000033dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000030f9  00000000  00000000  000047cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000db8  00000000  00000000  000078c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000160  00000000  00000000  00008680  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000c99  00000000  00000000  000087e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000011  00000000  00000000  00009479  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000e38  00000000  00000000  0000948c  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00012040 l    d  .rodata	00000000 .rodata
000123d8 l    d  .data	00000000 .data
000123e0 l    d  .bss	00000000 .bss
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 task.c
000102c7 l     F .text	0000001b list_node_init
000102e2 l     F .text	0000000b list_node_next
000102ed l     F .text	0000000b list_count
000102f8 l     F .text	0000000a list_first
00010302 l     F .text	00000007 hlt
00010309 l     F .text	0000000c write_tr
000123e0 l     O .bss	00001000 idle_task_stack
000133e0 l     O .bss	00000190 task_manager
00010315 l     F .text	00000104 tss_init
000120b8 l     O .rodata	0000000a __func__.2091
0001056c l     F .text	0000000a idle_task_entry
000106a6 l     F .text	00000040 task_next_run
00000000 l    df *ABS*	00000000 cpu.c
000108e9 l     F .text	00000028 lgdt
00010911 l     F .text	0000001a far_jump
00013580 l     O .bss	00000800 gdt_table
00013d80 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
00010b04 l     F .text	0000001d inb
00010b21 l     F .text	0000001f outb
00010b40 l     F .text	00000007 cli
00010b47 l     F .text	00000007 sti
00010b4e l     F .text	00000028 lidt
00010b76 l     F .text	00000007 hlt
00010b7d l     F .text	00000010 read_eflags
00010b8d l     F .text	0000000b write_eflags
00013da0 l     O .bss	00000400 idt_table
00010b98 l     F .text	000000d2 dump_core_regs
00010c6a l     F .text	0000004e do_default_handler
00010ee8 l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 time.c
000112df l     F .text	0000001f outb
000141a0 l     O .bss	00000004 sys_tick
000112fe l     F .text	00000060 init_pic
00000000 l    df *ABS*	00000000 init.c
000141c0 l     O .bss	000000b4 init_task
00014280 l     O .bss	00001000 init_task_stack
00015280 l     O .bss	00000010 sem
00000000 l    df *ABS*	00000000 mutex.c
000114bf l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
00011649 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 klib.c
0001178d l     F .text	00000007 hlt
000123d8 l     O .data	00000004 num2ch.1899
00000000 l    df *ABS*	00000000 list.c
00011cb2 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00011eaa l     F .text	0000001d inb
00011ec7 l     F .text	0000001f outb
00015290 l     O .bss	00000014 mutex
00011904 g     F .text	0000004f kernel_memcpy
0001063b g     F .text	0000000a task_current
00011280 g     F .text	0000000b irq_enable_global
00011d49 g     F .text	00000064 list_insert_last
00010885 g     F .text	00000064 sys_msleep
00010dec g     F .text	0000001c do_handler_segment_not_present
000105dc g     F .text	00000034 task_set_ready
00011953 g     F .text	00000041 kernel_memset
00010274 g       .text	00000000 exception_handler_virtual_exception
00010ad3 g     F .text	0000001e cpu_init
00011ee6 g     F .text	00000079 log_init
000113f9 g     F .text	000000c6 init_main
00010219 g       .text	00000000 exception_handler_alignment_check
00011794 g     F .text	00000047 kernel_strcpy
00011163 g     F .text	0000008b irq_enable
00010035 g       .text	00000000 exception_handler_unknown
000100b1 g       .text	00000000 exception_handler_breakpoint
00010d44 g     F .text	0000001c do_handler_overflow
00010e40 g     F .text	0000001c do_handler_alignment_check
000101c0 g       .text	00000000 exception_handler_general_protection
00010eb0 g     F .text	0000001c do_handler_general_protection
00011764 g     F .text	00000029 sem_count
00010cd4 g     F .text	0000001c do_handler_divider
00010db4 g     F .text	0000001c do_handler_double_fault
000113c0 g     F .text	00000039 init_task_entry
00010ecc g     F .text	0000001c do_handler_page_fault
0001014c g       .text	00000000 exception_handler_double_fault
0001128b g     F .text	0000002b pic_send_eoi
00010562 g     F .text	0000000a task_first_task
00011677 g     F .text	0000006b sem_wait
0001135e g     F .text	00000028 do_handler_timer
000101a3 g       .text	00000000 exception_handler_stack_segment_fault
00010e94 g     F .text	0000001c do_handler_virtual_exception
000100d0 g       .text	00000000 exception_handler_overflow
000109aa g     F .text	00000075 get_alloc_desc
000102b2 g       .text	00000000 simple_switch
000152b0 g     O .bss	00002000 stack
000100ef g       .text	00000000 exception_handler_bound_range
000116e2 g     F .text	00000082 sem_notify
00010d7c g     F .text	0000001c do_handler_invalid_opcode
00010169 g       .text	00000000 exception_handler_invalid_tss
00010e24 g     F .text	0000001c do_handler_fpu_error
00010528 g     F .text	0000003a task_first_init
00010e5c g     F .text	0000001c do_handler_machine_check
00010cf0 g     F .text	0000001c do_handler_Debug
00011cea g     F .text	0000005f list_insert_first
00010865 g     F .text	00000020 task_set_wakeup
00010d0c g     F .text	0000001c do_handler_NMI
00010054 g       .text	00000000 exception_handler_divider
000117db g     F .text	00000070 kernel_strncpy
00011275 g     F .text	0000000b irq_disable_global
00010645 g     F .text	00000061 sys_sched_yield
0001139e g     F .text	00000022 kernel_init
00011654 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00011b31 g     F .text	0000014b kernel_vsprintf
0001012d g       .text	00000000 exception_handler_device_unavailable
0001010e g       .text	00000000 exception_handler_invalid_opcode
000114f8 g     F .text	00000094 mutex_lock
00010236 g       .text	00000000 exception_handler_machine_check
00010dd0 g     F .text	0000001c do_handler_invalid_tss
0001082b g     F .text	0000003a task_set_sleep
00011c7c g     F .text	00000036 panic
00010293 g       .text	00000000 exception_handler_timer
00011129 g     F .text	0000003a irq_install
00010a1f g     F .text	0000006d init_gdt
000112b6 g     F .text	00000018 irq_enter_protection
000114ca g     F .text	0000002e mutex_init
000111ee g     F .text	00000087 irq_disable
00010255 g       .text	00000000 exception_handler_smd_exception
00010d98 g     F .text	0000001c do_handler_device_unavailable
000106e6 g     F .text	0000005b task_dispatch
00010af1 g     F .text	00000013 switch_to_tss
00011994 g     F .text	0000005e kernel_memcmp
00011cc5 g     F .text	00000025 list_init
00010e78 g     F .text	0000001c do_handler_smd_exception
000101dd g       .text	00000000 exception_handler_page_fault
00010610 g     F .text	0000002b task_set_block
00010cb8 g     F .text	0000001c do_handler_unknown
000101fa g       .text	00000000 exception_handler_fpu_error
0001050a g     F .text	0000001e task_switch_from_to
00010f7b g     F .text	000001ae irq_init
0001158c g     F .text	000000bd mutex_unlock
000112ce g     F .text	00000011 irq_leave_protection
000118c9 g     F .text	0000003b kernel_strlen
0001092b g     F .text	0000007f segment_desc_set
00010d60 g     F .text	0000001c do_handler_bound_range
00011dad g     F .text	00000078 list_remove_first
0001184b g     F .text	0000007e kernel_strncmp
00010186 g       .text	00000000 exception_handler_segment_not_present
00010092 g       .text	00000000 exception_handler_NMI
00010576 g     F .text	00000066 task_manager_init
00010073 g       .text	00000000 exception_handler_Debug
00010741 g     F .text	000000ea task_time_tick
00010e08 g     F .text	0000001c do_handler_stack_segment_fault
00010d28 g     F .text	0000001c do_handler_breakpoint
00011f5f g     F .text	000000de log_printf
00010419 g     F .text	000000f1 task_init
000119f2 g     F .text	0000013f kernel_itoa
00011e25 g     F .text	00000085 list_remove
00010a8c g     F .text	00000047 gate_desc_set
00011386 g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .extern kernel_init
    .extern init_main
    .global _start
    # void start (boot_info_t *boot_info)
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax
    # kernel_init(boot_info)
    push %eax
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 92 13 00 00       	call   1139e <kernel_init>
    jmp $KERNEL_SELECTOR_CS, $gdt_reload # 重新加载GDT
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs

    ; mov $stack, %eax
   10021:	b8 b0 52 01 00       	mov    $0x152b0,%eax
    ; mov $KERNEL_STACK_SIZE, %ebx
   10026:	bb 00 20 00 00       	mov    $0x2000,%ebx

    mov $(stack + KERNEL_STACK_SIZE), %esp
   1002b:	bc b0 72 01 00       	mov    $0x172b0,%esp
    jmp init_main
   10030:	e9 c4 13 00 00       	jmp    113f9 <init_main>

00010035 <exception_handler_unknown>:
    add $(2*4), %esp

    iret
.endm

exception_handler unknown, -1, 0
   10035:	6a 00                	push   $0x0
   10037:	6a ff                	push   $0xffffffff
   10039:	60                   	pusha  
   1003a:	1e                   	push   %ds
   1003b:	06                   	push   %es
   1003c:	0f a0                	push   %fs
   1003e:	0f a8                	push   %gs
   10040:	54                   	push   %esp
   10041:	e8 72 0c 00 00       	call   10cb8 <do_handler_unknown>
   10046:	83 c4 04             	add    $0x4,%esp
   10049:	0f a9                	pop    %gs
   1004b:	0f a1                	pop    %fs
   1004d:	07                   	pop    %es
   1004e:	1f                   	pop    %ds
   1004f:	61                   	popa   
   10050:	83 c4 08             	add    $0x8,%esp
   10053:	cf                   	iret   

00010054 <exception_handler_divider>:
exception_handler divider, 0, 0
   10054:	6a 00                	push   $0x0
   10056:	6a 00                	push   $0x0
   10058:	60                   	pusha  
   10059:	1e                   	push   %ds
   1005a:	06                   	push   %es
   1005b:	0f a0                	push   %fs
   1005d:	0f a8                	push   %gs
   1005f:	54                   	push   %esp
   10060:	e8 6f 0c 00 00       	call   10cd4 <do_handler_divider>
   10065:	83 c4 04             	add    $0x4,%esp
   10068:	0f a9                	pop    %gs
   1006a:	0f a1                	pop    %fs
   1006c:	07                   	pop    %es
   1006d:	1f                   	pop    %ds
   1006e:	61                   	popa   
   1006f:	83 c4 08             	add    $0x8,%esp
   10072:	cf                   	iret   

00010073 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10073:	6a 00                	push   $0x0
   10075:	6a 01                	push   $0x1
   10077:	60                   	pusha  
   10078:	1e                   	push   %ds
   10079:	06                   	push   %es
   1007a:	0f a0                	push   %fs
   1007c:	0f a8                	push   %gs
   1007e:	54                   	push   %esp
   1007f:	e8 6c 0c 00 00       	call   10cf0 <do_handler_Debug>
   10084:	83 c4 04             	add    $0x4,%esp
   10087:	0f a9                	pop    %gs
   10089:	0f a1                	pop    %fs
   1008b:	07                   	pop    %es
   1008c:	1f                   	pop    %ds
   1008d:	61                   	popa   
   1008e:	83 c4 08             	add    $0x8,%esp
   10091:	cf                   	iret   

00010092 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10092:	6a 00                	push   $0x0
   10094:	6a 02                	push   $0x2
   10096:	60                   	pusha  
   10097:	1e                   	push   %ds
   10098:	06                   	push   %es
   10099:	0f a0                	push   %fs
   1009b:	0f a8                	push   %gs
   1009d:	54                   	push   %esp
   1009e:	e8 69 0c 00 00       	call   10d0c <do_handler_NMI>
   100a3:	83 c4 04             	add    $0x4,%esp
   100a6:	0f a9                	pop    %gs
   100a8:	0f a1                	pop    %fs
   100aa:	07                   	pop    %es
   100ab:	1f                   	pop    %ds
   100ac:	61                   	popa   
   100ad:	83 c4 08             	add    $0x8,%esp
   100b0:	cf                   	iret   

000100b1 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100b1:	6a 00                	push   $0x0
   100b3:	6a 03                	push   $0x3
   100b5:	60                   	pusha  
   100b6:	1e                   	push   %ds
   100b7:	06                   	push   %es
   100b8:	0f a0                	push   %fs
   100ba:	0f a8                	push   %gs
   100bc:	54                   	push   %esp
   100bd:	e8 66 0c 00 00       	call   10d28 <do_handler_breakpoint>
   100c2:	83 c4 04             	add    $0x4,%esp
   100c5:	0f a9                	pop    %gs
   100c7:	0f a1                	pop    %fs
   100c9:	07                   	pop    %es
   100ca:	1f                   	pop    %ds
   100cb:	61                   	popa   
   100cc:	83 c4 08             	add    $0x8,%esp
   100cf:	cf                   	iret   

000100d0 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100d0:	6a 00                	push   $0x0
   100d2:	6a 04                	push   $0x4
   100d4:	60                   	pusha  
   100d5:	1e                   	push   %ds
   100d6:	06                   	push   %es
   100d7:	0f a0                	push   %fs
   100d9:	0f a8                	push   %gs
   100db:	54                   	push   %esp
   100dc:	e8 63 0c 00 00       	call   10d44 <do_handler_overflow>
   100e1:	83 c4 04             	add    $0x4,%esp
   100e4:	0f a9                	pop    %gs
   100e6:	0f a1                	pop    %fs
   100e8:	07                   	pop    %es
   100e9:	1f                   	pop    %ds
   100ea:	61                   	popa   
   100eb:	83 c4 08             	add    $0x8,%esp
   100ee:	cf                   	iret   

000100ef <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100ef:	6a 00                	push   $0x0
   100f1:	6a 05                	push   $0x5
   100f3:	60                   	pusha  
   100f4:	1e                   	push   %ds
   100f5:	06                   	push   %es
   100f6:	0f a0                	push   %fs
   100f8:	0f a8                	push   %gs
   100fa:	54                   	push   %esp
   100fb:	e8 60 0c 00 00       	call   10d60 <do_handler_bound_range>
   10100:	83 c4 04             	add    $0x4,%esp
   10103:	0f a9                	pop    %gs
   10105:	0f a1                	pop    %fs
   10107:	07                   	pop    %es
   10108:	1f                   	pop    %ds
   10109:	61                   	popa   
   1010a:	83 c4 08             	add    $0x8,%esp
   1010d:	cf                   	iret   

0001010e <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   1010e:	6a 00                	push   $0x0
   10110:	6a 06                	push   $0x6
   10112:	60                   	pusha  
   10113:	1e                   	push   %ds
   10114:	06                   	push   %es
   10115:	0f a0                	push   %fs
   10117:	0f a8                	push   %gs
   10119:	54                   	push   %esp
   1011a:	e8 5d 0c 00 00       	call   10d7c <do_handler_invalid_opcode>
   1011f:	83 c4 04             	add    $0x4,%esp
   10122:	0f a9                	pop    %gs
   10124:	0f a1                	pop    %fs
   10126:	07                   	pop    %es
   10127:	1f                   	pop    %ds
   10128:	61                   	popa   
   10129:	83 c4 08             	add    $0x8,%esp
   1012c:	cf                   	iret   

0001012d <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   1012d:	6a 00                	push   $0x0
   1012f:	6a 07                	push   $0x7
   10131:	60                   	pusha  
   10132:	1e                   	push   %ds
   10133:	06                   	push   %es
   10134:	0f a0                	push   %fs
   10136:	0f a8                	push   %gs
   10138:	54                   	push   %esp
   10139:	e8 5a 0c 00 00       	call   10d98 <do_handler_device_unavailable>
   1013e:	83 c4 04             	add    $0x4,%esp
   10141:	0f a9                	pop    %gs
   10143:	0f a1                	pop    %fs
   10145:	07                   	pop    %es
   10146:	1f                   	pop    %ds
   10147:	61                   	popa   
   10148:	83 c4 08             	add    $0x8,%esp
   1014b:	cf                   	iret   

0001014c <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   1014c:	6a 08                	push   $0x8
   1014e:	60                   	pusha  
   1014f:	1e                   	push   %ds
   10150:	06                   	push   %es
   10151:	0f a0                	push   %fs
   10153:	0f a8                	push   %gs
   10155:	54                   	push   %esp
   10156:	e8 59 0c 00 00       	call   10db4 <do_handler_double_fault>
   1015b:	83 c4 04             	add    $0x4,%esp
   1015e:	0f a9                	pop    %gs
   10160:	0f a1                	pop    %fs
   10162:	07                   	pop    %es
   10163:	1f                   	pop    %ds
   10164:	61                   	popa   
   10165:	83 c4 08             	add    $0x8,%esp
   10168:	cf                   	iret   

00010169 <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   10169:	6a 0a                	push   $0xa
   1016b:	60                   	pusha  
   1016c:	1e                   	push   %ds
   1016d:	06                   	push   %es
   1016e:	0f a0                	push   %fs
   10170:	0f a8                	push   %gs
   10172:	54                   	push   %esp
   10173:	e8 58 0c 00 00       	call   10dd0 <do_handler_invalid_tss>
   10178:	83 c4 04             	add    $0x4,%esp
   1017b:	0f a9                	pop    %gs
   1017d:	0f a1                	pop    %fs
   1017f:	07                   	pop    %es
   10180:	1f                   	pop    %ds
   10181:	61                   	popa   
   10182:	83 c4 08             	add    $0x8,%esp
   10185:	cf                   	iret   

00010186 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10186:	6a 0b                	push   $0xb
   10188:	60                   	pusha  
   10189:	1e                   	push   %ds
   1018a:	06                   	push   %es
   1018b:	0f a0                	push   %fs
   1018d:	0f a8                	push   %gs
   1018f:	54                   	push   %esp
   10190:	e8 57 0c 00 00       	call   10dec <do_handler_segment_not_present>
   10195:	83 c4 04             	add    $0x4,%esp
   10198:	0f a9                	pop    %gs
   1019a:	0f a1                	pop    %fs
   1019c:	07                   	pop    %es
   1019d:	1f                   	pop    %ds
   1019e:	61                   	popa   
   1019f:	83 c4 08             	add    $0x8,%esp
   101a2:	cf                   	iret   

000101a3 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   101a3:	6a 0c                	push   $0xc
   101a5:	60                   	pusha  
   101a6:	1e                   	push   %ds
   101a7:	06                   	push   %es
   101a8:	0f a0                	push   %fs
   101aa:	0f a8                	push   %gs
   101ac:	54                   	push   %esp
   101ad:	e8 56 0c 00 00       	call   10e08 <do_handler_stack_segment_fault>
   101b2:	83 c4 04             	add    $0x4,%esp
   101b5:	0f a9                	pop    %gs
   101b7:	0f a1                	pop    %fs
   101b9:	07                   	pop    %es
   101ba:	1f                   	pop    %ds
   101bb:	61                   	popa   
   101bc:	83 c4 08             	add    $0x8,%esp
   101bf:	cf                   	iret   

000101c0 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101c0:	6a 0d                	push   $0xd
   101c2:	60                   	pusha  
   101c3:	1e                   	push   %ds
   101c4:	06                   	push   %es
   101c5:	0f a0                	push   %fs
   101c7:	0f a8                	push   %gs
   101c9:	54                   	push   %esp
   101ca:	e8 e1 0c 00 00       	call   10eb0 <do_handler_general_protection>
   101cf:	83 c4 04             	add    $0x4,%esp
   101d2:	0f a9                	pop    %gs
   101d4:	0f a1                	pop    %fs
   101d6:	07                   	pop    %es
   101d7:	1f                   	pop    %ds
   101d8:	61                   	popa   
   101d9:	83 c4 08             	add    $0x8,%esp
   101dc:	cf                   	iret   

000101dd <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101dd:	6a 0e                	push   $0xe
   101df:	60                   	pusha  
   101e0:	1e                   	push   %ds
   101e1:	06                   	push   %es
   101e2:	0f a0                	push   %fs
   101e4:	0f a8                	push   %gs
   101e6:	54                   	push   %esp
   101e7:	e8 e0 0c 00 00       	call   10ecc <do_handler_page_fault>
   101ec:	83 c4 04             	add    $0x4,%esp
   101ef:	0f a9                	pop    %gs
   101f1:	0f a1                	pop    %fs
   101f3:	07                   	pop    %es
   101f4:	1f                   	pop    %ds
   101f5:	61                   	popa   
   101f6:	83 c4 08             	add    $0x8,%esp
   101f9:	cf                   	iret   

000101fa <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101fa:	6a 00                	push   $0x0
   101fc:	6a 10                	push   $0x10
   101fe:	60                   	pusha  
   101ff:	1e                   	push   %ds
   10200:	06                   	push   %es
   10201:	0f a0                	push   %fs
   10203:	0f a8                	push   %gs
   10205:	54                   	push   %esp
   10206:	e8 19 0c 00 00       	call   10e24 <do_handler_fpu_error>
   1020b:	83 c4 04             	add    $0x4,%esp
   1020e:	0f a9                	pop    %gs
   10210:	0f a1                	pop    %fs
   10212:	07                   	pop    %es
   10213:	1f                   	pop    %ds
   10214:	61                   	popa   
   10215:	83 c4 08             	add    $0x8,%esp
   10218:	cf                   	iret   

00010219 <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   10219:	6a 11                	push   $0x11
   1021b:	60                   	pusha  
   1021c:	1e                   	push   %ds
   1021d:	06                   	push   %es
   1021e:	0f a0                	push   %fs
   10220:	0f a8                	push   %gs
   10222:	54                   	push   %esp
   10223:	e8 18 0c 00 00       	call   10e40 <do_handler_alignment_check>
   10228:	83 c4 04             	add    $0x4,%esp
   1022b:	0f a9                	pop    %gs
   1022d:	0f a1                	pop    %fs
   1022f:	07                   	pop    %es
   10230:	1f                   	pop    %ds
   10231:	61                   	popa   
   10232:	83 c4 08             	add    $0x8,%esp
   10235:	cf                   	iret   

00010236 <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   10236:	6a 00                	push   $0x0
   10238:	6a 12                	push   $0x12
   1023a:	60                   	pusha  
   1023b:	1e                   	push   %ds
   1023c:	06                   	push   %es
   1023d:	0f a0                	push   %fs
   1023f:	0f a8                	push   %gs
   10241:	54                   	push   %esp
   10242:	e8 15 0c 00 00       	call   10e5c <do_handler_machine_check>
   10247:	83 c4 04             	add    $0x4,%esp
   1024a:	0f a9                	pop    %gs
   1024c:	0f a1                	pop    %fs
   1024e:	07                   	pop    %es
   1024f:	1f                   	pop    %ds
   10250:	61                   	popa   
   10251:	83 c4 08             	add    $0x8,%esp
   10254:	cf                   	iret   

00010255 <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   10255:	6a 00                	push   $0x0
   10257:	6a 13                	push   $0x13
   10259:	60                   	pusha  
   1025a:	1e                   	push   %ds
   1025b:	06                   	push   %es
   1025c:	0f a0                	push   %fs
   1025e:	0f a8                	push   %gs
   10260:	54                   	push   %esp
   10261:	e8 12 0c 00 00       	call   10e78 <do_handler_smd_exception>
   10266:	83 c4 04             	add    $0x4,%esp
   10269:	0f a9                	pop    %gs
   1026b:	0f a1                	pop    %fs
   1026d:	07                   	pop    %es
   1026e:	1f                   	pop    %ds
   1026f:	61                   	popa   
   10270:	83 c4 08             	add    $0x8,%esp
   10273:	cf                   	iret   

00010274 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10274:	6a 00                	push   $0x0
   10276:	6a 14                	push   $0x14
   10278:	60                   	pusha  
   10279:	1e                   	push   %ds
   1027a:	06                   	push   %es
   1027b:	0f a0                	push   %fs
   1027d:	0f a8                	push   %gs
   1027f:	54                   	push   %esp
   10280:	e8 0f 0c 00 00       	call   10e94 <do_handler_virtual_exception>
   10285:	83 c4 04             	add    $0x4,%esp
   10288:	0f a9                	pop    %gs
   1028a:	0f a1                	pop    %fs
   1028c:	07                   	pop    %es
   1028d:	1f                   	pop    %ds
   1028e:	61                   	popa   
   1028f:	83 c4 08             	add    $0x8,%esp
   10292:	cf                   	iret   

00010293 <exception_handler_timer>:

# 硬件中断
exception_handler timer, 0x20, 0
   10293:	6a 00                	push   $0x0
   10295:	6a 20                	push   $0x20
   10297:	60                   	pusha  
   10298:	1e                   	push   %ds
   10299:	06                   	push   %es
   1029a:	0f a0                	push   %fs
   1029c:	0f a8                	push   %gs
   1029e:	54                   	push   %esp
   1029f:	e8 ba 10 00 00       	call   1135e <do_handler_timer>
   102a4:	83 c4 04             	add    $0x4,%esp
   102a7:	0f a9                	pop    %gs
   102a9:	0f a1                	pop    %fs
   102ab:	07                   	pop    %es
   102ac:	1f                   	pop    %ds
   102ad:	61                   	popa   
   102ae:	83 c4 08             	add    $0x8,%esp
   102b1:	cf                   	iret   

000102b2 <simple_switch>:
// esp不用保存，只需要让esp保存在调用之前的状态
// eflags ?
    .text
    .global simple_switch
simple_switch:
    movl 4(%esp), %eax   // 取from->stack
   102b2:	8b 44 24 04          	mov    0x4(%esp),%eax
	movl 8(%esp), %edx   // 取to->stack
   102b6:	8b 54 24 08          	mov    0x8(%esp),%edx

	// 保存前一任务的状态
	push %ebp
   102ba:	55                   	push   %ebp
	push %ebx
   102bb:	53                   	push   %ebx
	push %esi
   102bc:	56                   	push   %esi
	push %edi
   102bd:	57                   	push   %edi

	// 切换栈
	mov %esp, (%eax)    // from->stack = esp
   102be:	89 20                	mov    %esp,(%eax)
  	mov %edx, %esp      // esp = to->stack
   102c0:	89 d4                	mov    %edx,%esp

	// 加载下一任务的栈
	pop %edi
   102c2:	5f                   	pop    %edi
	pop %esi
   102c3:	5e                   	pop    %esi
	pop %ebx
   102c4:	5b                   	pop    %ebx
	pop %ebp
   102c5:	5d                   	pop    %ebp
   102c6:	c3                   	ret    

000102c7 <list_node_init>:
/**
 * 头结点的初始化
 * @param node 待初始化的结果
 */
static inline void list_node_init(list_node_t *node)
{
   102c7:	55                   	push   %ebp
   102c8:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   102ca:	8b 45 08             	mov    0x8(%ebp),%eax
   102cd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   102d4:	8b 45 08             	mov    0x8(%ebp),%eax
   102d7:	8b 50 04             	mov    0x4(%eax),%edx
   102da:	8b 45 08             	mov    0x8(%ebp),%eax
   102dd:	89 10                	mov    %edx,(%eax)
}
   102df:	90                   	nop
   102e0:	5d                   	pop    %ebp
   102e1:	c3                   	ret    

000102e2 <list_node_next>:
 * 获取结点的后一结点
 * @param node 查询的结点
 * @return 后继结点
 */
static inline list_node_t *list_node_next(list_node_t *node)
{
   102e2:	55                   	push   %ebp
   102e3:	89 e5                	mov    %esp,%ebp
    return node->next;
   102e5:	8b 45 08             	mov    0x8(%ebp),%eax
   102e8:	8b 40 04             	mov    0x4(%eax),%eax
}
   102eb:	5d                   	pop    %ebp
   102ec:	c3                   	ret    

000102ed <list_count>:
 * 获取链表的结点数量
 * @param list 查询的链表
 * @return 结果的数据
 */
static inline int list_count(list_t *list)
{
   102ed:	55                   	push   %ebp
   102ee:	89 e5                	mov    %esp,%ebp
    return list->count;
   102f0:	8b 45 08             	mov    0x8(%ebp),%eax
   102f3:	8b 40 08             	mov    0x8(%eax),%eax
}
   102f6:	5d                   	pop    %ebp
   102f7:	c3                   	ret    

000102f8 <list_first>:
 * 获取指定链表的第一个表项
 * @param list 查询的链表
 * @return 第一个表项
 */
static inline list_node_t *list_first(list_t *list)
{
   102f8:	55                   	push   %ebp
   102f9:	89 e5                	mov    %esp,%ebp
    return list->first;
   102fb:	8b 45 08             	mov    0x8(%ebp),%eax
   102fe:	8b 00                	mov    (%eax),%eax
}
   10300:	5d                   	pop    %ebp
   10301:	c3                   	ret    

00010302 <hlt>:
    uint32_t addr[] = {offset, selector};
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
}

static inline void hlt(void)
{
   10302:	55                   	push   %ebp
   10303:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10305:	f4                   	hlt    
}
   10306:	90                   	nop
   10307:	5d                   	pop    %ebp
   10308:	c3                   	ret    

00010309 <write_tr>:

// 写tss register 当前运行那个进程
static inline void write_tr(uint32_t tss_selector)
{
   10309:	55                   	push   %ebp
   1030a:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("ltr %%ax" ::"a"(tss_selector));
   1030c:	8b 45 08             	mov    0x8(%ebp),%eax
   1030f:	0f 00 d8             	ltr    %ax
}
   10312:	90                   	nop
   10313:	5d                   	pop    %ebp
   10314:	c3                   	ret    

00010315 <tss_init>:

static uint32_t idle_task_stack[1024];
static task_manager_t task_manager; // 任务管理器

static int tss_init(task_t *task, uint32_t entry, uint32_t esp)
{
   10315:	55                   	push   %ebp
   10316:	89 e5                	mov    %esp,%ebp
   10318:	83 ec 18             	sub    $0x18,%esp
    int tss_sel = get_alloc_desc();
   1031b:	e8 8a 06 00 00       	call   109aa <get_alloc_desc>
   10320:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (tss_sel < 0)
   10323:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10327:	79 1a                	jns    10343 <tss_init+0x2e>
    {
        log_printf("alloc tss failed.\n");
   10329:	83 ec 0c             	sub    $0xc,%esp
   1032c:	68 40 20 01 00       	push   $0x12040
   10331:	e8 29 1c 00 00       	call   11f5f <log_printf>
   10336:	83 c4 10             	add    $0x10,%esp
        return -1;
   10339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1033e:	e9 d4 00 00 00       	jmp    10417 <tss_init+0x102>
    }

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t), SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); // 设置GDT表项内容
   10343:	8b 45 08             	mov    0x8(%ebp),%eax
   10346:	83 c0 48             	add    $0x48,%eax
   10349:	68 89 00 00 00       	push   $0x89
   1034e:	6a 68                	push   $0x68
   10350:	50                   	push   %eax
   10351:	ff 75 f4             	pushl  -0xc(%ebp)
   10354:	e8 d2 05 00 00       	call   1092b <segment_desc_set>
   10359:	83 c4 10             	add    $0x10,%esp

    // tss段初始化
    kernel_memset(&task->tss, 0, sizeof(tss_t));
   1035c:	8b 45 08             	mov    0x8(%ebp),%eax
   1035f:	83 c0 48             	add    $0x48,%eax
   10362:	83 ec 04             	sub    $0x4,%esp
   10365:	6a 68                	push   $0x68
   10367:	6a 00                	push   $0x0
   10369:	50                   	push   %eax
   1036a:	e8 e4 15 00 00       	call   11953 <kernel_memset>
   1036f:	83 c4 10             	add    $0x10,%esp
    task->tss.eip = entry;
   10372:	8b 45 08             	mov    0x8(%ebp),%eax
   10375:	8b 55 0c             	mov    0xc(%ebp),%edx
   10378:	89 50 68             	mov    %edx,0x68(%eax)
    task->tss.esp = task->tss.esp0 = esp;
   1037b:	8b 45 08             	mov    0x8(%ebp),%eax
   1037e:	8b 55 10             	mov    0x10(%ebp),%edx
   10381:	89 50 4c             	mov    %edx,0x4c(%eax)
   10384:	8b 45 08             	mov    0x8(%ebp),%eax
   10387:	8b 50 4c             	mov    0x4c(%eax),%edx
   1038a:	8b 45 08             	mov    0x8(%ebp),%eax
   1038d:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
    task->tss.ss = task->tss.ss0 = KERNEL_SELECTOR_DS;
   10393:	8b 45 08             	mov    0x8(%ebp),%eax
   10396:	c7 40 50 10 00 00 00 	movl   $0x10,0x50(%eax)
   1039d:	8b 45 08             	mov    0x8(%ebp),%eax
   103a0:	8b 50 50             	mov    0x50(%eax),%edx
   103a3:	8b 45 08             	mov    0x8(%ebp),%eax
   103a6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = KERNEL_SELECTOR_DS;
   103ac:	8b 45 08             	mov    0x8(%ebp),%eax
   103af:	c7 80 a4 00 00 00 10 	movl   $0x10,0xa4(%eax)
   103b6:	00 00 00 
   103b9:	8b 45 08             	mov    0x8(%ebp),%eax
   103bc:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   103c2:	8b 45 08             	mov    0x8(%ebp),%eax
   103c5:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
   103cb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ce:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
   103d4:	8b 45 08             	mov    0x8(%ebp),%eax
   103d7:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
   103dd:	8b 45 08             	mov    0x8(%ebp),%eax
   103e0:	8b 90 9c 00 00 00    	mov    0x9c(%eax),%edx
   103e6:	8b 45 08             	mov    0x8(%ebp),%eax
   103e9:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
    task->tss.cs = KERNEL_SELECTOR_CS;
   103ef:	8b 45 08             	mov    0x8(%ebp),%eax
   103f2:	c7 80 94 00 00 00 08 	movl   $0x8,0x94(%eax)
   103f9:	00 00 00 
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
   103fc:	8b 45 08             	mov    0x8(%ebp),%eax
   103ff:	c7 40 6c 02 02 00 00 	movl   $0x202,0x6c(%eax)

    task->tss_sel = tss_sel;
   10406:	8b 45 08             	mov    0x8(%ebp),%eax
   10409:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1040c:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
    return 0;
   10412:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10417:	c9                   	leave  
   10418:	c3                   	ret    

00010419 <task_init>:

int task_init(task_t *task, const char *name, uint32_t entry, uint32_t esp)
{
   10419:	55                   	push   %ebp
   1041a:	89 e5                	mov    %esp,%ebp
   1041c:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task_t *)0);
   1041f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10423:	75 19                	jne    1043e <task_init+0x25>
   10425:	68 53 20 01 00       	push   $0x12053
   1042a:	68 b8 20 01 00       	push   $0x120b8
   1042f:	6a 26                	push   $0x26
   10431:	68 68 20 01 00       	push   $0x12068
   10436:	e8 41 18 00 00       	call   11c7c <panic>
   1043b:	83 c4 10             	add    $0x10,%esp
    tss_init(task, entry, esp);
   1043e:	83 ec 04             	sub    $0x4,%esp
   10441:	ff 75 14             	pushl  0x14(%ebp)
   10444:	ff 75 10             	pushl  0x10(%ebp)
   10447:	ff 75 08             	pushl  0x8(%ebp)
   1044a:	e8 c6 fe ff ff       	call   10315 <tss_init>
   1044f:	83 c4 10             	add    $0x10,%esp

    // 任务字段初始化
    kernel_strncpy(task->name, name, TASK_NAME_SIZE);
   10452:	8b 45 08             	mov    0x8(%ebp),%eax
   10455:	83 c0 04             	add    $0x4,%eax
   10458:	83 ec 04             	sub    $0x4,%esp
   1045b:	6a 20                	push   $0x20
   1045d:	ff 75 0c             	pushl  0xc(%ebp)
   10460:	50                   	push   %eax
   10461:	e8 75 13 00 00       	call   117db <kernel_strncpy>
   10466:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_CREATED;
   10469:	8b 45 08             	mov    0x8(%ebp),%eax
   1046c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->sleep_ticks = 0;
   10472:	8b 45 08             	mov    0x8(%ebp),%eax
   10475:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   1047c:	8b 45 08             	mov    0x8(%ebp),%eax
   1047f:	c7 40 28 0a 00 00 00 	movl   $0xa,0x28(%eax)
    task->slice_ticks = task->time_ticks;
   10486:	8b 45 08             	mov    0x8(%ebp),%eax
   10489:	8b 50 28             	mov    0x28(%eax),%edx
   1048c:	8b 45 08             	mov    0x8(%ebp),%eax
   1048f:	89 50 2c             	mov    %edx,0x2c(%eax)
    list_node_init(&task->all_node);
   10492:	8b 45 08             	mov    0x8(%ebp),%eax
   10495:	83 c0 40             	add    $0x40,%eax
   10498:	83 ec 0c             	sub    $0xc,%esp
   1049b:	50                   	push   %eax
   1049c:	e8 26 fe ff ff       	call   102c7 <list_node_init>
   104a1:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   104a4:	8b 45 08             	mov    0x8(%ebp),%eax
   104a7:	83 c0 30             	add    $0x30,%eax
   104aa:	83 ec 0c             	sub    $0xc,%esp
   104ad:	50                   	push   %eax
   104ae:	e8 14 fe ff ff       	call   102c7 <list_node_init>
   104b3:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   104b6:	8b 45 08             	mov    0x8(%ebp),%eax
   104b9:	83 c0 38             	add    $0x38,%eax
   104bc:	83 ec 0c             	sub    $0xc,%esp
   104bf:	50                   	push   %eax
   104c0:	e8 02 fe ff ff       	call   102c7 <list_node_init>
   104c5:	83 c4 10             	add    $0x10,%esp

    irq_state_t state = irq_enter_protection();
   104c8:	e8 e9 0d 00 00       	call   112b6 <irq_enter_protection>
   104cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   104d0:	83 ec 0c             	sub    $0xc,%esp
   104d3:	ff 75 08             	pushl  0x8(%ebp)
   104d6:	e8 01 01 00 00       	call   105dc <task_set_ready>
   104db:	83 c4 10             	add    $0x10,%esp
    list_insert_last(&task_manager.task_list, &task->all_node); // 插入所有task进队尾
   104de:	8b 45 08             	mov    0x8(%ebp),%eax
   104e1:	83 c0 40             	add    $0x40,%eax
   104e4:	83 ec 08             	sub    $0x8,%esp
   104e7:	50                   	push   %eax
   104e8:	68 f0 33 01 00       	push   $0x133f0
   104ed:	e8 57 18 00 00       	call   11d49 <list_insert_last>
   104f2:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   104f5:	83 ec 0c             	sub    $0xc,%esp
   104f8:	ff 75 f4             	pushl  -0xc(%ebp)
   104fb:	e8 ce 0d 00 00       	call   112ce <irq_leave_protection>
   10500:	83 c4 10             	add    $0x10,%esp
    return 0;
   10503:	b8 00 00 00 00       	mov    $0x0,%eax
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    // }
}
   10508:	c9                   	leave  
   10509:	c3                   	ret    

0001050a <task_switch_from_to>:

void task_switch_from_to(task_t *from, task_t *to)
{
   1050a:	55                   	push   %ebp
   1050b:	89 e5                	mov    %esp,%ebp
   1050d:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   10510:	8b 45 0c             	mov    0xc(%ebp),%eax
   10513:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   10519:	83 ec 0c             	sub    $0xc,%esp
   1051c:	50                   	push   %eax
   1051d:	e8 cf 05 00 00       	call   10af1 <switch_to_tss>
   10522:	83 c4 10             	add    $0x10,%esp
    // simple_switch(&from->stack, to->stack);
}
   10525:	90                   	nop
   10526:	c9                   	leave  
   10527:	c3                   	ret    

00010528 <task_first_init>:

void task_first_init(void)
{
   10528:	55                   	push   %ebp
   10529:	89 e5                	mov    %esp,%ebp
   1052b:	83 ec 08             	sub    $0x8,%esp
    task_init(&task_manager.first_task, "first task", 0, 0);
   1052e:	6a 00                	push   $0x0
   10530:	6a 00                	push   $0x0
   10532:	68 a2 20 01 00       	push   $0x120a2
   10537:	68 08 34 01 00       	push   $0x13408
   1053c:	e8 d8 fe ff ff       	call   10419 <task_init>
   10541:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = &task_manager.first_task;
   10544:	c7 05 e0 33 01 00 08 	movl   $0x13408,0x133e0
   1054b:	34 01 00 

    // 写TR寄存器，指示当前运行的第一个任务
    write_tr(task_manager.first_task.tss_sel);
   1054e:	a1 b8 34 01 00       	mov    0x134b8,%eax
   10553:	83 ec 0c             	sub    $0xc,%esp
   10556:	50                   	push   %eax
   10557:	e8 ad fd ff ff       	call   10309 <write_tr>
   1055c:	83 c4 10             	add    $0x10,%esp
}
   1055f:	90                   	nop
   10560:	c9                   	leave  
   10561:	c3                   	ret    

00010562 <task_first_task>:

/**
 * @brief 返回初始任务
 */
task_t *task_first_task(void)
{
   10562:	55                   	push   %ebp
   10563:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   10565:	b8 08 34 01 00       	mov    $0x13408,%eax
}
   1056a:	5d                   	pop    %ebp
   1056b:	c3                   	ret    

0001056c <idle_task_entry>:

static void idle_task_entry(void)
{
   1056c:	55                   	push   %ebp
   1056d:	89 e5                	mov    %esp,%ebp
    for (;;)
    {
        hlt();
   1056f:	e8 8e fd ff ff       	call   10302 <hlt>
   10574:	eb f9                	jmp    1056f <idle_task_entry+0x3>

00010576 <task_manager_init>:
    }
}

void task_manager_init(void)
{
   10576:	55                   	push   %ebp
   10577:	89 e5                	mov    %esp,%ebp
   10579:	83 ec 08             	sub    $0x8,%esp
    // 各队列初始化
    list_init(&task_manager.ready_list);
   1057c:	83 ec 0c             	sub    $0xc,%esp
   1057f:	68 e4 33 01 00       	push   $0x133e4
   10584:	e8 3c 17 00 00       	call   11cc5 <list_init>
   10589:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   1058c:	83 ec 0c             	sub    $0xc,%esp
   1058f:	68 f0 33 01 00       	push   $0x133f0
   10594:	e8 2c 17 00 00       	call   11cc5 <list_init>
   10599:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   1059c:	83 ec 0c             	sub    $0xc,%esp
   1059f:	68 fc 33 01 00       	push   $0x133fc
   105a4:	e8 1c 17 00 00       	call   11cc5 <list_init>
   105a9:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = (task_t *)0;
   105ac:	c7 05 e0 33 01 00 00 	movl   $0x0,0x133e0
   105b3:	00 00 00 

    task_init(&task_manager.idle_task, "idle_task", (uint32_t)idle_task_entry, (uint32_t)idle_task_stack + 1024);
   105b6:	b8 e0 23 01 00       	mov    $0x123e0,%eax
   105bb:	05 00 04 00 00       	add    $0x400,%eax
   105c0:	ba 6c 05 01 00       	mov    $0x1056c,%edx
   105c5:	50                   	push   %eax
   105c6:	52                   	push   %edx
   105c7:	68 ad 20 01 00       	push   $0x120ad
   105cc:	68 bc 34 01 00       	push   $0x134bc
   105d1:	e8 43 fe ff ff       	call   10419 <task_init>
   105d6:	83 c4 10             	add    $0x10,%esp
}
   105d9:	90                   	nop
   105da:	c9                   	leave  
   105db:	c3                   	ret    

000105dc <task_set_ready>:

/**
 * @brief 将任务插入就绪队列
 */
void task_set_ready(task_t *task)
{
   105dc:	55                   	push   %ebp
   105dd:	89 e5                	mov    %esp,%ebp
   105df:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   105e2:	81 7d 08 bc 34 01 00 	cmpl   $0x134bc,0x8(%ebp)
   105e9:	74 22                	je     1060d <task_set_ready+0x31>
    {
        return;
    }
    list_insert_last(&task_manager.ready_list, &task->run_node);
   105eb:	8b 45 08             	mov    0x8(%ebp),%eax
   105ee:	83 c0 30             	add    $0x30,%eax
   105f1:	83 ec 08             	sub    $0x8,%esp
   105f4:	50                   	push   %eax
   105f5:	68 e4 33 01 00       	push   $0x133e4
   105fa:	e8 4a 17 00 00       	call   11d49 <list_insert_last>
   105ff:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;
   10602:	8b 45 08             	mov    0x8(%ebp),%eax
   10605:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1060b:	eb 01                	jmp    1060e <task_set_ready+0x32>
        return;
   1060d:	90                   	nop
}
   1060e:	c9                   	leave  
   1060f:	c3                   	ret    

00010610 <task_set_block>:

/**
 * @brief 将任务从就绪队列移除
 */
void task_set_block(task_t *task)
{
   10610:	55                   	push   %ebp
   10611:	89 e5                	mov    %esp,%ebp
   10613:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   10616:	81 7d 08 bc 34 01 00 	cmpl   $0x134bc,0x8(%ebp)
   1061d:	74 19                	je     10638 <task_set_block+0x28>
    {
        return;
    }
    list_remove(&task_manager.ready_list, &task->run_node);
   1061f:	8b 45 08             	mov    0x8(%ebp),%eax
   10622:	83 c0 30             	add    $0x30,%eax
   10625:	83 ec 08             	sub    $0x8,%esp
   10628:	50                   	push   %eax
   10629:	68 e4 33 01 00       	push   $0x133e4
   1062e:	e8 f2 17 00 00       	call   11e25 <list_remove>
   10633:	83 c4 10             	add    $0x10,%esp
   10636:	eb 01                	jmp    10639 <task_set_block+0x29>
        return;
   10638:	90                   	nop
}
   10639:	c9                   	leave  
   1063a:	c3                   	ret    

0001063b <task_current>:

/**
 * @brief 获取当前正在运行的任务
 */
task_t *task_current(void)
{
   1063b:	55                   	push   %ebp
   1063c:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   1063e:	a1 e0 33 01 00       	mov    0x133e0,%eax
}
   10643:	5d                   	pop    %ebp
   10644:	c3                   	ret    

00010645 <sys_sched_yield>:

int sys_sched_yield(void)
{
   10645:	55                   	push   %ebp
   10646:	89 e5                	mov    %esp,%ebp
   10648:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1064b:	e8 66 0c 00 00       	call   112b6 <irq_enter_protection>
   10650:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (list_count(&task_manager.ready_list) > 1)
   10653:	83 ec 0c             	sub    $0xc,%esp
   10656:	68 e4 33 01 00       	push   $0x133e4
   1065b:	e8 8d fc ff ff       	call   102ed <list_count>
   10660:	83 c4 10             	add    $0x10,%esp
   10663:	83 f8 01             	cmp    $0x1,%eax
   10666:	7e 29                	jle    10691 <sys_sched_yield+0x4c>
    {
        task_t *curr_task = task_current();
   10668:	e8 ce ff ff ff       	call   1063b <task_current>
   1066d:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        task_set_block(curr_task);
   10670:	83 ec 0c             	sub    $0xc,%esp
   10673:	ff 75 f0             	pushl  -0x10(%ebp)
   10676:	e8 95 ff ff ff       	call   10610 <task_set_block>
   1067b:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   1067e:	83 ec 0c             	sub    $0xc,%esp
   10681:	ff 75 f0             	pushl  -0x10(%ebp)
   10684:	e8 53 ff ff ff       	call   105dc <task_set_ready>
   10689:	83 c4 10             	add    $0x10,%esp

        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
   1068c:	e8 55 00 00 00       	call   106e6 <task_dispatch>
    }
    irq_leave_protection(state);
   10691:	83 ec 0c             	sub    $0xc,%esp
   10694:	ff 75 f4             	pushl  -0xc(%ebp)
   10697:	e8 32 0c 00 00       	call   112ce <irq_leave_protection>
   1069c:	83 c4 10             	add    $0x10,%esp
    return 0;
   1069f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   106a4:	c9                   	leave  
   106a5:	c3                   	ret    

000106a6 <task_next_run>:

/**
 * @brief 获取下一将要运行的任务
 */
static task_t *task_next_run(void)
{
   106a6:	55                   	push   %ebp
   106a7:	89 e5                	mov    %esp,%ebp
   106a9:	83 ec 10             	sub    $0x10,%esp
    if (list_count(&task_manager.ready_list == 0))
   106ac:	6a 00                	push   $0x0
   106ae:	e8 3a fc ff ff       	call   102ed <list_count>
   106b3:	83 c4 04             	add    $0x4,%esp
   106b6:	85 c0                	test   %eax,%eax
   106b8:	74 07                	je     106c1 <task_next_run+0x1b>
    {
        return &task_manager.idle_task;
   106ba:	b8 bc 34 01 00       	mov    $0x134bc,%eax
   106bf:	eb 23                	jmp    106e4 <task_next_run+0x3e>
    }

    // 普通任务
    list_node_t *task_node = list_first(&task_manager.ready_list);
   106c1:	68 e4 33 01 00       	push   $0x133e4
   106c6:	e8 2d fc ff ff       	call   102f8 <list_first>
   106cb:	83 c4 04             	add    $0x4,%esp
   106ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node, task_t, run_node);
   106d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   106d5:	74 08                	je     106df <task_next_run+0x39>
   106d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   106da:	83 e8 30             	sub    $0x30,%eax
   106dd:	eb 05                	jmp    106e4 <task_next_run+0x3e>
   106df:	b8 00 00 00 00       	mov    $0x0,%eax
}
   106e4:	c9                   	leave  
   106e5:	c3                   	ret    

000106e6 <task_dispatch>:

/**
 * @brief 进行一次任务调度
 */
void task_dispatch(void)
{
   106e6:	55                   	push   %ebp
   106e7:	89 e5                	mov    %esp,%ebp
   106e9:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   106ec:	e8 c5 0b 00 00       	call   112b6 <irq_enter_protection>
   106f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *to = task_next_run();
   106f4:	e8 ad ff ff ff       	call   106a6 <task_next_run>
   106f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (to != task_manager.curr_task)
   106fc:	a1 e0 33 01 00       	mov    0x133e0,%eax
   10701:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   10704:	74 2a                	je     10730 <task_dispatch+0x4a>
    {
        task_t *from = task_manager.curr_task;
   10706:	a1 e0 33 01 00       	mov    0x133e0,%eax
   1070b:	89 45 ec             	mov    %eax,-0x14(%ebp)

        task_manager.curr_task = to;
   1070e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10711:	a3 e0 33 01 00       	mov    %eax,0x133e0
        to->state = TASK_RUNNING;
   10716:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10719:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from, to);
   1071f:	83 ec 08             	sub    $0x8,%esp
   10722:	ff 75 f0             	pushl  -0x10(%ebp)
   10725:	ff 75 ec             	pushl  -0x14(%ebp)
   10728:	e8 dd fd ff ff       	call   1050a <task_switch_from_to>
   1072d:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   10730:	83 ec 0c             	sub    $0xc,%esp
   10733:	ff 75 f4             	pushl  -0xc(%ebp)
   10736:	e8 93 0b 00 00       	call   112ce <irq_leave_protection>
   1073b:	83 c4 10             	add    $0x10,%esp
}
   1073e:	90                   	nop
   1073f:	c9                   	leave  
   10740:	c3                   	ret    

00010741 <task_time_tick>:
/**
 * @brief 时间处理
 * 该函数在中断处理函数中调用
 */
void task_time_tick(void)
{
   10741:	55                   	push   %ebp
   10742:	89 e5                	mov    %esp,%ebp
   10744:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   10747:	e8 ef fe ff ff       	call   1063b <task_current>
   1074c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_state_t state = irq_enter_protection();
   1074f:	e8 62 0b 00 00       	call   112b6 <irq_enter_protection>
   10754:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (--curr_task->slice_ticks == 0)
   10757:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1075a:	8b 40 2c             	mov    0x2c(%eax),%eax
   1075d:	8d 50 ff             	lea    -0x1(%eax),%edx
   10760:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10763:	89 50 2c             	mov    %edx,0x2c(%eax)
   10766:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10769:	8b 40 2c             	mov    0x2c(%eax),%eax
   1076c:	85 c0                	test   %eax,%eax
   1076e:	75 28                	jne    10798 <task_time_tick+0x57>
    {
        // 时间片用完，重新加载时间片
        // 对于空闲任务，此处减未用
        curr_task->slice_ticks = curr_task->time_ticks;
   10770:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10773:	8b 50 28             	mov    0x28(%eax),%edx
   10776:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10779:	89 50 2c             	mov    %edx,0x2c(%eax)

        // 调整队列的位置到尾部，不用直接操作队列
        task_set_block(curr_task);
   1077c:	83 ec 0c             	sub    $0xc,%esp
   1077f:	ff 75 f0             	pushl  -0x10(%ebp)
   10782:	e8 89 fe ff ff       	call   10610 <task_set_block>
   10787:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   1078a:	83 ec 0c             	sub    $0xc,%esp
   1078d:	ff 75 f0             	pushl  -0x10(%ebp)
   10790:	e8 47 fe ff ff       	call   105dc <task_set_ready>
   10795:	83 c4 10             	add    $0x10,%esp
    }

    // 睡眠处理
    list_node_t *curr = list_first(&task_manager.sleep_list);
   10798:	83 ec 0c             	sub    $0xc,%esp
   1079b:	68 fc 33 01 00       	push   $0x133fc
   107a0:	e8 53 fb ff ff       	call   102f8 <list_first>
   107a5:	83 c4 10             	add    $0x10,%esp
   107a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   107ab:	eb 62                	jmp    1080f <task_time_tick+0xce>
    {
        list_node_t *next = list_node_next(curr);
   107ad:	83 ec 0c             	sub    $0xc,%esp
   107b0:	ff 75 f4             	pushl  -0xc(%ebp)
   107b3:	e8 2a fb ff ff       	call   102e2 <list_node_next>
   107b8:	83 c4 10             	add    $0x10,%esp
   107bb:	89 45 e8             	mov    %eax,-0x18(%ebp)

        task_t *task = list_node_parent(curr, task_t, run_node);
   107be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   107c2:	74 08                	je     107cc <task_time_tick+0x8b>
   107c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107c7:	83 e8 30             	sub    $0x30,%eax
   107ca:	eb 05                	jmp    107d1 <task_time_tick+0x90>
   107cc:	b8 00 00 00 00       	mov    $0x0,%eax
   107d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (--task->sleep_ticks == 0)
   107d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   107d7:	8b 40 24             	mov    0x24(%eax),%eax
   107da:	8d 50 ff             	lea    -0x1(%eax),%edx
   107dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   107e0:	89 50 24             	mov    %edx,0x24(%eax)
   107e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   107e6:	8b 40 24             	mov    0x24(%eax),%eax
   107e9:	85 c0                	test   %eax,%eax
   107eb:	75 1c                	jne    10809 <task_time_tick+0xc8>
        {
            // 延时时间到达，从睡眠队列中移除，送至就绪队列
            task_set_wakeup(task);
   107ed:	83 ec 0c             	sub    $0xc,%esp
   107f0:	ff 75 e4             	pushl  -0x1c(%ebp)
   107f3:	e8 6d 00 00 00       	call   10865 <task_set_wakeup>
   107f8:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   107fb:	83 ec 0c             	sub    $0xc,%esp
   107fe:	ff 75 e4             	pushl  -0x1c(%ebp)
   10801:	e8 d6 fd ff ff       	call   105dc <task_set_ready>
   10806:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   10809:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1080c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   1080f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10813:	75 98                	jne    107ad <task_time_tick+0x6c>
    }
    task_dispatch();
   10815:	e8 cc fe ff ff       	call   106e6 <task_dispatch>
    irq_leave_protection(state);
   1081a:	83 ec 0c             	sub    $0xc,%esp
   1081d:	ff 75 ec             	pushl  -0x14(%ebp)
   10820:	e8 a9 0a 00 00       	call   112ce <irq_leave_protection>
   10825:	83 c4 10             	add    $0x10,%esp
}
   10828:	90                   	nop
   10829:	c9                   	leave  
   1082a:	c3                   	ret    

0001082b <task_set_sleep>:

/**
 * @brief 将任务加入睡眠状态
 */
void task_set_sleep(task_t *task, uint32_t ticks)
{
   1082b:	55                   	push   %ebp
   1082c:	89 e5                	mov    %esp,%ebp
   1082e:	83 ec 08             	sub    $0x8,%esp
    if (ticks <= 0)
   10831:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10835:	74 2b                	je     10862 <task_set_sleep+0x37>
    {
        return;
    }

    task->sleep_ticks = ticks;
   10837:	8b 55 0c             	mov    0xc(%ebp),%edx
   1083a:	8b 45 08             	mov    0x8(%ebp),%eax
   1083d:	89 50 24             	mov    %edx,0x24(%eax)
    task->state = TASK_SLEEP;
   10840:	8b 45 08             	mov    0x8(%ebp),%eax
   10843:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list, &task->run_node);
   10849:	8b 45 08             	mov    0x8(%ebp),%eax
   1084c:	83 c0 30             	add    $0x30,%eax
   1084f:	83 ec 08             	sub    $0x8,%esp
   10852:	50                   	push   %eax
   10853:	68 fc 33 01 00       	push   $0x133fc
   10858:	e8 ec 14 00 00       	call   11d49 <list_insert_last>
   1085d:	83 c4 10             	add    $0x10,%esp
   10860:	eb 01                	jmp    10863 <task_set_sleep+0x38>
        return;
   10862:	90                   	nop
}
   10863:	c9                   	leave  
   10864:	c3                   	ret    

00010865 <task_set_wakeup>:
 * @brief 将任务从延时队列移除
 *
 * @param task
 */
void task_set_wakeup(task_t *task)
{
   10865:	55                   	push   %ebp
   10866:	89 e5                	mov    %esp,%ebp
   10868:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list, &task->run_node);
   1086b:	8b 45 08             	mov    0x8(%ebp),%eax
   1086e:	83 c0 30             	add    $0x30,%eax
   10871:	83 ec 08             	sub    $0x8,%esp
   10874:	50                   	push   %eax
   10875:	68 fc 33 01 00       	push   $0x133fc
   1087a:	e8 a6 15 00 00       	call   11e25 <list_remove>
   1087f:	83 c4 10             	add    $0x10,%esp
}
   10882:	90                   	nop
   10883:	c9                   	leave  
   10884:	c3                   	ret    

00010885 <sys_msleep>:
 * @brief 任务进入睡眠状态
 *
 * @param ms
 */
void sys_msleep(uint32_t ms)
{
   10885:	55                   	push   %ebp
   10886:	89 e5                	mov    %esp,%ebp
   10888:	83 ec 18             	sub    $0x18,%esp
    // 至少延时1个tick
    if (ms < OS_TICK_MS)
   1088b:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   1088f:	77 07                	ja     10898 <sys_msleep+0x13>
    {
        ms = OS_TICK_MS;
   10891:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   10898:	e8 19 0a 00 00       	call   112b6 <irq_enter_protection>
   1089d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 从就绪队列移除，加入睡眠队列
    task_set_block(task_manager.curr_task);
   108a0:	a1 e0 33 01 00       	mov    0x133e0,%eax
   108a5:	83 ec 0c             	sub    $0xc,%esp
   108a8:	50                   	push   %eax
   108a9:	e8 62 fd ff ff       	call   10610 <task_set_block>
   108ae:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   108b1:	8b 45 08             	mov    0x8(%ebp),%eax
   108b4:	83 c0 09             	add    $0x9,%eax
   108b7:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   108bc:	f7 e2                	mul    %edx
   108be:	c1 ea 03             	shr    $0x3,%edx
   108c1:	a1 e0 33 01 00       	mov    0x133e0,%eax
   108c6:	83 ec 08             	sub    $0x8,%esp
   108c9:	52                   	push   %edx
   108ca:	50                   	push   %eax
   108cb:	e8 5b ff ff ff       	call   1082b <task_set_sleep>
   108d0:	83 c4 10             	add    $0x10,%esp

    // 进行一次调度
    task_dispatch();
   108d3:	e8 0e fe ff ff       	call   106e6 <task_dispatch>

    irq_leave_protection(state);
   108d8:	83 ec 0c             	sub    $0xc,%esp
   108db:	ff 75 f4             	pushl  -0xc(%ebp)
   108de:	e8 eb 09 00 00       	call   112ce <irq_leave_protection>
   108e3:	83 c4 10             	add    $0x10,%esp
   108e6:	90                   	nop
   108e7:	c9                   	leave  
   108e8:	c3                   	ret    

000108e9 <lgdt>:
{
   108e9:	55                   	push   %ebp
   108ea:	89 e5                	mov    %esp,%ebp
   108ec:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   108ef:	8b 45 08             	mov    0x8(%ebp),%eax
   108f2:	c1 e8 10             	shr    $0x10,%eax
   108f5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   108f9:	8b 45 08             	mov    0x8(%ebp),%eax
   108fc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   10900:	8b 45 0c             	mov    0xc(%ebp),%eax
   10903:	83 e8 01             	sub    $0x1,%eax
   10906:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]" ::[g] "m"(gdt));
   1090a:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   1090e:	90                   	nop
   1090f:	c9                   	leave  
   10910:	c3                   	ret    

00010911 <far_jump>:
{
   10911:	55                   	push   %ebp
   10912:	89 e5                	mov    %esp,%ebp
   10914:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset, selector};
   10917:	8b 45 0c             	mov    0xc(%ebp),%eax
   1091a:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1091d:	8b 45 08             	mov    0x8(%ebp),%eax
   10920:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
   10923:	8d 45 f8             	lea    -0x8(%ebp),%eax
   10926:	ff 28                	ljmp   *(%eax)
}
   10928:	90                   	nop
   10929:	c9                   	leave  
   1092a:	c3                   	ret    

0001092b <segment_desc_set>:

static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;

void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   1092b:	55                   	push   %ebp
   1092c:	89 e5                	mov    %esp,%ebp
   1092e:	83 ec 14             	sub    $0x14,%esp
   10931:	8b 45 14             	mov    0x14(%ebp),%eax
   10934:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + (selector / sizeof(segment_desc_t)); //
   10938:	8b 45 08             	mov    0x8(%ebp),%eax
   1093b:	83 e0 f8             	and    $0xfffffff8,%eax
   1093e:	05 80 35 01 00       	add    $0x13580,%eax
   10943:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置limit单位为4kB
    if (limit > 0xFFFF)
   10946:	81 7d 10 ff ff 00 00 	cmpl   $0xffff,0x10(%ebp)
   1094d:	76 0f                	jbe    1095e <segment_desc_set+0x33>
    {
        attr |= SEG_G; // G 标志位
   1094f:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit /= 0x1000;
   10955:	8b 45 10             	mov    0x10(%ebp),%eax
   10958:	c1 e8 0c             	shr    $0xc,%eax
   1095b:	89 45 10             	mov    %eax,0x10(%ebp)
    }

    desc->limit15_0 = limit & 0xFFFF;
   1095e:	8b 45 10             	mov    0x10(%ebp),%eax
   10961:	89 c2                	mov    %eax,%edx
   10963:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10966:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xFFFF;
   10969:	8b 45 0c             	mov    0xc(%ebp),%eax
   1096c:	89 c2                	mov    %eax,%edx
   1096e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10971:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xFF;
   10975:	8b 45 0c             	mov    0xc(%ebp),%eax
   10978:	c1 e8 10             	shr    $0x10,%eax
   1097b:	89 c2                	mov    %eax,%edx
   1097d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10980:	88 50 04             	mov    %dl,0x4(%eax)
    desc->base31_24 = (base >> 24) & 0xFF;
   10983:	8b 45 0c             	mov    0xc(%ebp),%eax
   10986:	c1 e8 18             	shr    $0x18,%eax
   10989:	89 c2                	mov    %eax,%edx
   1098b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1098e:	88 50 07             	mov    %dl,0x7(%eax)
    desc->attr = attr | (((limit >> 16) & 0xFF) << 8);
   10991:	8b 45 10             	mov    0x10(%ebp),%eax
   10994:	c1 e8 10             	shr    $0x10,%eax
   10997:	c1 e0 08             	shl    $0x8,%eax
   1099a:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1099e:	89 c2                	mov    %eax,%edx
   109a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   109a3:	66 89 50 05          	mov    %dx,0x5(%eax)
}
   109a7:	90                   	nop
   109a8:	c9                   	leave  
   109a9:	c3                   	ret    

000109aa <get_alloc_desc>:

int get_alloc_desc()
{
   109aa:	55                   	push   %ebp
   109ab:	89 e5                	mov    %esp,%ebp
   109ad:	83 ec 18             	sub    $0x18,%esp
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   109b0:	83 ec 0c             	sub    $0xc,%esp
   109b3:	68 80 3d 01 00       	push   $0x13d80
   109b8:	e8 3b 0b 00 00       	call   114f8 <mutex_lock>
   109bd:	83 c4 10             	add    $0x10,%esp

    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   109c0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   109c7:	eb 36                	jmp    109ff <get_alloc_desc+0x55>
    {
        segment_desc_t *desc = gdt_table + i;
   109c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109cc:	c1 e0 03             	shl    $0x3,%eax
   109cf:	05 80 35 01 00       	add    $0x13580,%eax
   109d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (desc->attr == 0) // 根据属性是否为0判断
   109d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109da:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   109de:	66 85 c0             	test   %ax,%ax
   109e1:	75 18                	jne    109fb <get_alloc_desc+0x51>
        {
            // irq_leave_protection(state);
            mutex_unlock(&mutex);
   109e3:	83 ec 0c             	sub    $0xc,%esp
   109e6:	68 80 3d 01 00       	push   $0x13d80
   109eb:	e8 9c 0b 00 00       	call   1158c <mutex_unlock>
   109f0:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   109f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109f6:	c1 e0 03             	shl    $0x3,%eax
   109f9:	eb 22                	jmp    10a1d <get_alloc_desc+0x73>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   109fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   109ff:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   10a06:	7e c1                	jle    109c9 <get_alloc_desc+0x1f>
        }
    }
    // irq_leave_protection(state);
    mutex_unlock(&mutex);
   10a08:	83 ec 0c             	sub    $0xc,%esp
   10a0b:	68 80 3d 01 00       	push   $0x13d80
   10a10:	e8 77 0b 00 00       	call   1158c <mutex_unlock>
   10a15:	83 c4 10             	add    $0x10,%esp
    return -1;
   10a18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10a1d:	c9                   	leave  
   10a1e:	c3                   	ret    

00010a1f <init_gdt>:

void init_gdt(void)
{
   10a1f:	55                   	push   %ebp
   10a20:	89 e5                	mov    %esp,%ebp
   10a22:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   10a25:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10a2c:	eb 19                	jmp    10a47 <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0); // 找到第几个GDT表项
   10a2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a31:	c1 e0 03             	shl    $0x3,%eax
   10a34:	6a 00                	push   $0x0
   10a36:	6a 00                	push   $0x0
   10a38:	6a 00                	push   $0x0
   10a3a:	50                   	push   %eax
   10a3b:	e8 eb fe ff ff       	call   1092b <segment_desc_set>
   10a40:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   10a43:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10a47:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   10a4e:	7e de                	jle    10a2e <init_gdt+0xf>
    }
    // 数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xFFFFFFFF,
   10a50:	68 92 40 00 00       	push   $0x4092
   10a55:	6a ff                	push   $0xffffffff
   10a57:	6a 00                	push   $0x0
   10a59:	6a 10                	push   $0x10
   10a5b:	e8 cb fe ff ff       	call   1092b <segment_desc_set>
   10a60:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    // 代码段
    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xFFFFFFFF,
   10a63:	68 9a 40 00 00       	push   $0x409a
   10a68:	6a ff                	push   $0xffffffff
   10a6a:	6a 00                	push   $0x0
   10a6c:	6a 08                	push   $0x8
   10a6e:	e8 b8 fe ff ff       	call   1092b <segment_desc_set>
   10a73:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);

    // 重新加载GDT
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   10a76:	b8 80 35 01 00       	mov    $0x13580,%eax
   10a7b:	68 00 08 00 00       	push   $0x800
   10a80:	50                   	push   %eax
   10a81:	e8 63 fe ff ff       	call   108e9 <lgdt>
   10a86:	83 c4 08             	add    $0x8,%esp
}
   10a89:	90                   	nop
   10a8a:	c9                   	leave  
   10a8b:	c3                   	ret    

00010a8c <gate_desc_set>:

void gate_desc_set(gate_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   10a8c:	55                   	push   %ebp
   10a8d:	89 e5                	mov    %esp,%ebp
   10a8f:	83 ec 08             	sub    $0x8,%esp
   10a92:	8b 55 0c             	mov    0xc(%ebp),%edx
   10a95:	8b 45 14             	mov    0x14(%ebp),%eax
   10a98:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10a9c:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0 = offset & 0xFFFF;
   10aa0:	8b 45 10             	mov    0x10(%ebp),%eax
   10aa3:	89 c2                	mov    %eax,%edx
   10aa5:	8b 45 08             	mov    0x8(%ebp),%eax
   10aa8:	66 89 10             	mov    %dx,(%eax)
    desc->selector = selector;
   10aab:	8b 45 08             	mov    0x8(%ebp),%eax
   10aae:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10ab2:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr = attr;
   10ab6:	8b 45 08             	mov    0x8(%ebp),%eax
   10ab9:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   10abd:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16 = (offset >> 16) & 0xFFFFF;
   10ac1:	8b 45 10             	mov    0x10(%ebp),%eax
   10ac4:	c1 e8 10             	shr    $0x10,%eax
   10ac7:	89 c2                	mov    %eax,%edx
   10ac9:	8b 45 08             	mov    0x8(%ebp),%eax
   10acc:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   10ad0:	90                   	nop
   10ad1:	c9                   	leave  
   10ad2:	c3                   	ret    

00010ad3 <cpu_init>:

void cpu_init(void)
{
   10ad3:	55                   	push   %ebp
   10ad4:	89 e5                	mov    %esp,%ebp
   10ad6:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   10ad9:	83 ec 0c             	sub    $0xc,%esp
   10adc:	68 80 3d 01 00       	push   $0x13d80
   10ae1:	e8 e4 09 00 00       	call   114ca <mutex_init>
   10ae6:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   10ae9:	e8 31 ff ff ff       	call   10a1f <init_gdt>
}
   10aee:	90                   	nop
   10aef:	c9                   	leave  
   10af0:	c3                   	ret    

00010af1 <switch_to_tss>:

void switch_to_tss(uint32_t tss_selector)
{
   10af1:	55                   	push   %ebp
   10af2:	89 e5                	mov    %esp,%ebp
    far_jump(tss_selector, 0);
   10af4:	6a 00                	push   $0x0
   10af6:	ff 75 08             	pushl  0x8(%ebp)
   10af9:	e8 13 fe ff ff       	call   10911 <far_jump>
   10afe:	83 c4 08             	add    $0x8,%esp
   10b01:	90                   	nop
   10b02:	c9                   	leave  
   10b03:	c3                   	ret    

00010b04 <inb>:
{
   10b04:	55                   	push   %ebp
   10b05:	89 e5                	mov    %esp,%ebp
   10b07:	83 ec 14             	sub    $0x14,%esp
   10b0a:	8b 45 08             	mov    0x8(%ebp),%eax
   10b0d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   10b11:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10b15:	89 c2                	mov    %eax,%edx
   10b17:	ec                   	in     (%dx),%al
   10b18:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   10b1b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   10b1f:	c9                   	leave  
   10b20:	c3                   	ret    

00010b21 <outb>:
{
   10b21:	55                   	push   %ebp
   10b22:	89 e5                	mov    %esp,%ebp
   10b24:	83 ec 08             	sub    $0x8,%esp
   10b27:	8b 55 08             	mov    0x8(%ebp),%edx
   10b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b2d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10b31:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   10b34:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10b38:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   10b3c:	ee                   	out    %al,(%dx)
}
   10b3d:	90                   	nop
   10b3e:	c9                   	leave  
   10b3f:	c3                   	ret    

00010b40 <cli>:
{
   10b40:	55                   	push   %ebp
   10b41:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   10b43:	fa                   	cli    
}
   10b44:	90                   	nop
   10b45:	5d                   	pop    %ebp
   10b46:	c3                   	ret    

00010b47 <sti>:
{
   10b47:	55                   	push   %ebp
   10b48:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   10b4a:	fb                   	sti    
}
   10b4b:	90                   	nop
   10b4c:	5d                   	pop    %ebp
   10b4d:	c3                   	ret    

00010b4e <lidt>:
{
   10b4e:	55                   	push   %ebp
   10b4f:	89 e5                	mov    %esp,%ebp
   10b51:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   10b54:	8b 45 08             	mov    0x8(%ebp),%eax
   10b57:	c1 e8 10             	shr    $0x10,%eax
   10b5a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xFFFF;
   10b5e:	8b 45 08             	mov    0x8(%ebp),%eax
   10b61:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   10b65:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b68:	83 e8 01             	sub    $0x1,%eax
   10b6b:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[g]" ::[g] "m"(idt));
   10b6f:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   10b73:	90                   	nop
   10b74:	c9                   	leave  
   10b75:	c3                   	ret    

00010b76 <hlt>:
{
   10b76:	55                   	push   %ebp
   10b77:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10b79:	f4                   	hlt    
}
   10b7a:	90                   	nop
   10b7b:	5d                   	pop    %ebp
   10b7c:	c3                   	ret    

00010b7d <read_eflags>:

static inline uint32_t read_eflags(void)
{
   10b7d:	55                   	push   %ebp
   10b7e:	89 e5                	mov    %esp,%ebp
   10b80:	83 ec 10             	sub    $0x10,%esp
    uint32_t eflags;

    __asm__ __volatile__("pushfl\n\tpopl %%eax" : "=a"(eflags));
   10b83:	9c                   	pushf  
   10b84:	58                   	pop    %eax
   10b85:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   10b88:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10b8b:	c9                   	leave  
   10b8c:	c3                   	ret    

00010b8d <write_eflags>:

static inline void write_eflags(uint32_t eflags)
{
   10b8d:	55                   	push   %ebp
   10b8e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("pushl %%eax\n\tpopfl" ::"a"(eflags));
   10b90:	8b 45 08             	mov    0x8(%ebp),%eax
   10b93:	50                   	push   %eax
   10b94:	9d                   	popf   
}
   10b95:	90                   	nop
   10b96:	5d                   	pop    %ebp
   10b97:	c3                   	ret    

00010b98 <dump_core_regs>:
#define IDT_TABLE_NR 128

static gate_desc_t idt_table[IDT_TABLE_NR];

static void dump_core_regs(exception_frame_t *frame)
{
   10b98:	55                   	push   %ebp
   10b99:	89 e5                	mov    %esp,%ebp
   10b9b:	57                   	push   %edi
   10b9c:	56                   	push   %esi
   10b9d:	53                   	push   %ebx
   10b9e:	83 ec 1c             	sub    $0x1c,%esp
    // 打印CPU寄存器相关内容
    log_printf("IRQ: %d, error code: %d.", frame->num, frame->err_code);
   10ba1:	8b 45 08             	mov    0x8(%ebp),%eax
   10ba4:	8b 50 34             	mov    0x34(%eax),%edx
   10ba7:	8b 45 08             	mov    0x8(%ebp),%eax
   10baa:	8b 40 30             	mov    0x30(%eax),%eax
   10bad:	83 ec 04             	sub    $0x4,%esp
   10bb0:	52                   	push   %edx
   10bb1:	50                   	push   %eax
   10bb2:	68 c4 20 01 00       	push   $0x120c4
   10bb7:	e8 a3 13 00 00       	call   11f5f <log_printf>
   10bbc:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS:%d\nGS:%d",
   10bbf:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc2:	8b 30                	mov    (%eax),%esi
   10bc4:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc7:	8b 58 04             	mov    0x4(%eax),%ebx
   10bca:	8b 45 08             	mov    0x8(%ebp),%eax
   10bcd:	8b 48 08             	mov    0x8(%eax),%ecx
   10bd0:	8b 45 08             	mov    0x8(%ebp),%eax
   10bd3:	8b 50 0c             	mov    0xc(%eax),%edx
   10bd6:	8b 45 08             	mov    0x8(%ebp),%eax
   10bd9:	8b 40 3c             	mov    0x3c(%eax),%eax
   10bdc:	83 ec 08             	sub    $0x8,%esp
   10bdf:	56                   	push   %esi
   10be0:	53                   	push   %ebx
   10be1:	51                   	push   %ecx
   10be2:	52                   	push   %edx
   10be3:	50                   	push   %eax
   10be4:	68 e0 20 01 00       	push   $0x120e0
   10be9:	e8 71 13 00 00       	call   11f5f <log_printf>
   10bee:	83 c4 20             	add    $0x20,%esp
               frame->cs, frame->ds, frame->es, frame->fs, frame->gs);
    log_printf("EAX:0x%x\n"
   10bf1:	8b 45 08             	mov    0x8(%ebp),%eax
   10bf4:	8b 48 1c             	mov    0x1c(%eax),%ecx
   10bf7:	8b 45 08             	mov    0x8(%ebp),%eax
   10bfa:	8b 40 18             	mov    0x18(%eax),%eax
   10bfd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   10c00:	8b 45 08             	mov    0x8(%ebp),%eax
   10c03:	8b 78 14             	mov    0x14(%eax),%edi
   10c06:	89 7d e0             	mov    %edi,-0x20(%ebp)
   10c09:	8b 45 08             	mov    0x8(%ebp),%eax
   10c0c:	8b 78 10             	mov    0x10(%eax),%edi
   10c0f:	8b 45 08             	mov    0x8(%ebp),%eax
   10c12:	8b 70 24             	mov    0x24(%eax),%esi
   10c15:	8b 45 08             	mov    0x8(%ebp),%eax
   10c18:	8b 58 28             	mov    0x28(%eax),%ebx
   10c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   10c1e:	8b 50 20             	mov    0x20(%eax),%edx
   10c21:	8b 45 08             	mov    0x8(%ebp),%eax
   10c24:	8b 40 2c             	mov    0x2c(%eax),%eax
   10c27:	83 ec 0c             	sub    $0xc,%esp
   10c2a:	51                   	push   %ecx
   10c2b:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c2e:	ff 75 e0             	pushl  -0x20(%ebp)
   10c31:	57                   	push   %edi
   10c32:	56                   	push   %esi
   10c33:	53                   	push   %ebx
   10c34:	52                   	push   %edx
   10c35:	50                   	push   %eax
   10c36:	68 08 21 01 00       	push   $0x12108
   10c3b:	e8 1f 13 00 00       	call   11f5f <log_printf>
   10c40:	83 c4 30             	add    $0x30,%esp
               "ESI:0x%x\n"
               "EBP:0x%x\n"
               "ESP:0x%x\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, frame->esp);
    log_printf("EIP:0x%x\nEFLAGS:0x%x\n", frame->eip, frame->eflags);
   10c43:	8b 45 08             	mov    0x8(%ebp),%eax
   10c46:	8b 50 40             	mov    0x40(%eax),%edx
   10c49:	8b 45 08             	mov    0x8(%ebp),%eax
   10c4c:	8b 40 38             	mov    0x38(%eax),%eax
   10c4f:	83 ec 04             	sub    $0x4,%esp
   10c52:	52                   	push   %edx
   10c53:	50                   	push   %eax
   10c54:	68 51 21 01 00       	push   $0x12151
   10c59:	e8 01 13 00 00       	call   11f5f <log_printf>
   10c5e:	83 c4 10             	add    $0x10,%esp
}
   10c61:	90                   	nop
   10c62:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10c65:	5b                   	pop    %ebx
   10c66:	5e                   	pop    %esi
   10c67:	5f                   	pop    %edi
   10c68:	5d                   	pop    %ebp
   10c69:	c3                   	ret    

00010c6a <do_default_handler>:

static void do_default_handler(exception_frame_t *frame, const char *msg)
{
   10c6a:	55                   	push   %ebp
   10c6b:	89 e5                	mov    %esp,%ebp
   10c6d:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   10c70:	83 ec 0c             	sub    $0xc,%esp
   10c73:	68 68 21 01 00       	push   $0x12168
   10c78:	e8 e2 12 00 00       	call   11f5f <log_printf>
   10c7d:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s.", msg);
   10c80:	83 ec 08             	sub    $0x8,%esp
   10c83:	ff 75 0c             	pushl  0xc(%ebp)
   10c86:	68 89 21 01 00       	push   $0x12189
   10c8b:	e8 cf 12 00 00       	call   11f5f <log_printf>
   10c90:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame); // 打印寄存器
   10c93:	83 ec 0c             	sub    $0xc,%esp
   10c96:	ff 75 08             	pushl  0x8(%ebp)
   10c99:	e8 fa fe ff ff       	call   10b98 <dump_core_regs>
   10c9e:	83 c4 10             	add    $0x10,%esp
    log_printf("--------------------------------");
   10ca1:	83 ec 0c             	sub    $0xc,%esp
   10ca4:	68 68 21 01 00       	push   $0x12168
   10ca9:	e8 b1 12 00 00       	call   11f5f <log_printf>
   10cae:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   10cb1:	e8 c0 fe ff ff       	call   10b76 <hlt>
   10cb6:	eb f9                	jmp    10cb1 <do_default_handler+0x47>

00010cb8 <do_handler_unknown>:
    }
}

void do_handler_unknown(exception_frame_t *frame)
{
   10cb8:	55                   	push   %ebp
   10cb9:	89 e5                	mov    %esp,%ebp
   10cbb:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "unknown exception");
   10cbe:	83 ec 08             	sub    $0x8,%esp
   10cc1:	68 a4 21 01 00       	push   $0x121a4
   10cc6:	ff 75 08             	pushl  0x8(%ebp)
   10cc9:	e8 9c ff ff ff       	call   10c6a <do_default_handler>
   10cce:	83 c4 10             	add    $0x10,%esp
}
   10cd1:	90                   	nop
   10cd2:	c9                   	leave  
   10cd3:	c3                   	ret    

00010cd4 <do_handler_divider>:

void do_handler_divider(exception_frame_t *frame)
{
   10cd4:	55                   	push   %ebp
   10cd5:	89 e5                	mov    %esp,%ebp
   10cd7:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "divider exception");
   10cda:	83 ec 08             	sub    $0x8,%esp
   10cdd:	68 b6 21 01 00       	push   $0x121b6
   10ce2:	ff 75 08             	pushl  0x8(%ebp)
   10ce5:	e8 80 ff ff ff       	call   10c6a <do_default_handler>
   10cea:	83 c4 10             	add    $0x10,%esp
}
   10ced:	90                   	nop
   10cee:	c9                   	leave  
   10cef:	c3                   	ret    

00010cf0 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t *frame)
{
   10cf0:	55                   	push   %ebp
   10cf1:	89 e5                	mov    %esp,%ebp
   10cf3:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Debug Exception");
   10cf6:	83 ec 08             	sub    $0x8,%esp
   10cf9:	68 c8 21 01 00       	push   $0x121c8
   10cfe:	ff 75 08             	pushl  0x8(%ebp)
   10d01:	e8 64 ff ff ff       	call   10c6a <do_default_handler>
   10d06:	83 c4 10             	add    $0x10,%esp
}
   10d09:	90                   	nop
   10d0a:	c9                   	leave  
   10d0b:	c3                   	ret    

00010d0c <do_handler_NMI>:

void do_handler_NMI(exception_frame_t *frame)
{
   10d0c:	55                   	push   %ebp
   10d0d:	89 e5                	mov    %esp,%ebp
   10d0f:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "NMI Interrupt.");
   10d12:	83 ec 08             	sub    $0x8,%esp
   10d15:	68 d8 21 01 00       	push   $0x121d8
   10d1a:	ff 75 08             	pushl  0x8(%ebp)
   10d1d:	e8 48 ff ff ff       	call   10c6a <do_default_handler>
   10d22:	83 c4 10             	add    $0x10,%esp
}
   10d25:	90                   	nop
   10d26:	c9                   	leave  
   10d27:	c3                   	ret    

00010d28 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t *frame)
{
   10d28:	55                   	push   %ebp
   10d29:	89 e5                	mov    %esp,%ebp
   10d2b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Breakpoint.");
   10d2e:	83 ec 08             	sub    $0x8,%esp
   10d31:	68 e7 21 01 00       	push   $0x121e7
   10d36:	ff 75 08             	pushl  0x8(%ebp)
   10d39:	e8 2c ff ff ff       	call   10c6a <do_default_handler>
   10d3e:	83 c4 10             	add    $0x10,%esp
}
   10d41:	90                   	nop
   10d42:	c9                   	leave  
   10d43:	c3                   	ret    

00010d44 <do_handler_overflow>:

void do_handler_overflow(exception_frame_t *frame)
{
   10d44:	55                   	push   %ebp
   10d45:	89 e5                	mov    %esp,%ebp
   10d47:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Overflow.");
   10d4a:	83 ec 08             	sub    $0x8,%esp
   10d4d:	68 f3 21 01 00       	push   $0x121f3
   10d52:	ff 75 08             	pushl  0x8(%ebp)
   10d55:	e8 10 ff ff ff       	call   10c6a <do_default_handler>
   10d5a:	83 c4 10             	add    $0x10,%esp
}
   10d5d:	90                   	nop
   10d5e:	c9                   	leave  
   10d5f:	c3                   	ret    

00010d60 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t *frame)
{
   10d60:	55                   	push   %ebp
   10d61:	89 e5                	mov    %esp,%ebp
   10d63:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "BOUND Range Exceeded.");
   10d66:	83 ec 08             	sub    $0x8,%esp
   10d69:	68 fd 21 01 00       	push   $0x121fd
   10d6e:	ff 75 08             	pushl  0x8(%ebp)
   10d71:	e8 f4 fe ff ff       	call   10c6a <do_default_handler>
   10d76:	83 c4 10             	add    $0x10,%esp
}
   10d79:	90                   	nop
   10d7a:	c9                   	leave  
   10d7b:	c3                   	ret    

00010d7c <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t *frame)
{
   10d7c:	55                   	push   %ebp
   10d7d:	89 e5                	mov    %esp,%ebp
   10d7f:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid Opcode.");
   10d82:	83 ec 08             	sub    $0x8,%esp
   10d85:	68 13 22 01 00       	push   $0x12213
   10d8a:	ff 75 08             	pushl  0x8(%ebp)
   10d8d:	e8 d8 fe ff ff       	call   10c6a <do_default_handler>
   10d92:	83 c4 10             	add    $0x10,%esp
}
   10d95:	90                   	nop
   10d96:	c9                   	leave  
   10d97:	c3                   	ret    

00010d98 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t *frame)
{
   10d98:	55                   	push   %ebp
   10d99:	89 e5                	mov    %esp,%ebp
   10d9b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Device Not Available.");
   10d9e:	83 ec 08             	sub    $0x8,%esp
   10da1:	68 23 22 01 00       	push   $0x12223
   10da6:	ff 75 08             	pushl  0x8(%ebp)
   10da9:	e8 bc fe ff ff       	call   10c6a <do_default_handler>
   10dae:	83 c4 10             	add    $0x10,%esp
}
   10db1:	90                   	nop
   10db2:	c9                   	leave  
   10db3:	c3                   	ret    

00010db4 <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t *frame)
{
   10db4:	55                   	push   %ebp
   10db5:	89 e5                	mov    %esp,%ebp
   10db7:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Double Fault.");
   10dba:	83 ec 08             	sub    $0x8,%esp
   10dbd:	68 39 22 01 00       	push   $0x12239
   10dc2:	ff 75 08             	pushl  0x8(%ebp)
   10dc5:	e8 a0 fe ff ff       	call   10c6a <do_default_handler>
   10dca:	83 c4 10             	add    $0x10,%esp
}
   10dcd:	90                   	nop
   10dce:	c9                   	leave  
   10dcf:	c3                   	ret    

00010dd0 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t *frame)
{
   10dd0:	55                   	push   %ebp
   10dd1:	89 e5                	mov    %esp,%ebp
   10dd3:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid TSS");
   10dd6:	83 ec 08             	sub    $0x8,%esp
   10dd9:	68 47 22 01 00       	push   $0x12247
   10dde:	ff 75 08             	pushl  0x8(%ebp)
   10de1:	e8 84 fe ff ff       	call   10c6a <do_default_handler>
   10de6:	83 c4 10             	add    $0x10,%esp
}
   10de9:	90                   	nop
   10dea:	c9                   	leave  
   10deb:	c3                   	ret    

00010dec <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t *frame)
{
   10dec:	55                   	push   %ebp
   10ded:	89 e5                	mov    %esp,%ebp
   10def:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Segment Not Present.");
   10df2:	83 ec 08             	sub    $0x8,%esp
   10df5:	68 53 22 01 00       	push   $0x12253
   10dfa:	ff 75 08             	pushl  0x8(%ebp)
   10dfd:	e8 68 fe ff ff       	call   10c6a <do_default_handler>
   10e02:	83 c4 10             	add    $0x10,%esp
}
   10e05:	90                   	nop
   10e06:	c9                   	leave  
   10e07:	c3                   	ret    

00010e08 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   10e08:	55                   	push   %ebp
   10e09:	89 e5                	mov    %esp,%ebp
   10e0b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Stack-Segment Fault.");
   10e0e:	83 ec 08             	sub    $0x8,%esp
   10e11:	68 68 22 01 00       	push   $0x12268
   10e16:	ff 75 08             	pushl  0x8(%ebp)
   10e19:	e8 4c fe ff ff       	call   10c6a <do_default_handler>
   10e1e:	83 c4 10             	add    $0x10,%esp
}
   10e21:	90                   	nop
   10e22:	c9                   	leave  
   10e23:	c3                   	ret    

00010e24 <do_handler_fpu_error>:

void do_handler_fpu_error(exception_frame_t *frame)
{
   10e24:	55                   	push   %ebp
   10e25:	89 e5                	mov    %esp,%ebp
   10e27:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "X87 FPU Floating Point Error.");
   10e2a:	83 ec 08             	sub    $0x8,%esp
   10e2d:	68 7d 22 01 00       	push   $0x1227d
   10e32:	ff 75 08             	pushl  0x8(%ebp)
   10e35:	e8 30 fe ff ff       	call   10c6a <do_default_handler>
   10e3a:	83 c4 10             	add    $0x10,%esp
}
   10e3d:	90                   	nop
   10e3e:	c9                   	leave  
   10e3f:	c3                   	ret    

00010e40 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t *frame)
{
   10e40:	55                   	push   %ebp
   10e41:	89 e5                	mov    %esp,%ebp
   10e43:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Alignment Check.");
   10e46:	83 ec 08             	sub    $0x8,%esp
   10e49:	68 9b 22 01 00       	push   $0x1229b
   10e4e:	ff 75 08             	pushl  0x8(%ebp)
   10e51:	e8 14 fe ff ff       	call   10c6a <do_default_handler>
   10e56:	83 c4 10             	add    $0x10,%esp
}
   10e59:	90                   	nop
   10e5a:	c9                   	leave  
   10e5b:	c3                   	ret    

00010e5c <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t *frame)
{
   10e5c:	55                   	push   %ebp
   10e5d:	89 e5                	mov    %esp,%ebp
   10e5f:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Machine Check.");
   10e62:	83 ec 08             	sub    $0x8,%esp
   10e65:	68 ac 22 01 00       	push   $0x122ac
   10e6a:	ff 75 08             	pushl  0x8(%ebp)
   10e6d:	e8 f8 fd ff ff       	call   10c6a <do_default_handler>
   10e72:	83 c4 10             	add    $0x10,%esp
}
   10e75:	90                   	nop
   10e76:	c9                   	leave  
   10e77:	c3                   	ret    

00010e78 <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t *frame)
{
   10e78:	55                   	push   %ebp
   10e79:	89 e5                	mov    %esp,%ebp
   10e7b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "SIMD Floating Point Exception.");
   10e7e:	83 ec 08             	sub    $0x8,%esp
   10e81:	68 bc 22 01 00       	push   $0x122bc
   10e86:	ff 75 08             	pushl  0x8(%ebp)
   10e89:	e8 dc fd ff ff       	call   10c6a <do_default_handler>
   10e8e:	83 c4 10             	add    $0x10,%esp
}
   10e91:	90                   	nop
   10e92:	c9                   	leave  
   10e93:	c3                   	ret    

00010e94 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t *frame)
{
   10e94:	55                   	push   %ebp
   10e95:	89 e5                	mov    %esp,%ebp
   10e97:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Virtualization Exception.");
   10e9a:	83 ec 08             	sub    $0x8,%esp
   10e9d:	68 db 22 01 00       	push   $0x122db
   10ea2:	ff 75 08             	pushl  0x8(%ebp)
   10ea5:	e8 c0 fd ff ff       	call   10c6a <do_default_handler>
   10eaa:	83 c4 10             	add    $0x10,%esp
}
   10ead:	90                   	nop
   10eae:	c9                   	leave  
   10eaf:	c3                   	ret    

00010eb0 <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t *frame)
{
   10eb0:	55                   	push   %ebp
   10eb1:	89 e5                	mov    %esp,%ebp
   10eb3:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "General_protection Exception.");
   10eb6:	83 ec 08             	sub    $0x8,%esp
   10eb9:	68 f5 22 01 00       	push   $0x122f5
   10ebe:	ff 75 08             	pushl  0x8(%ebp)
   10ec1:	e8 a4 fd ff ff       	call   10c6a <do_default_handler>
   10ec6:	83 c4 10             	add    $0x10,%esp
}
   10ec9:	90                   	nop
   10eca:	c9                   	leave  
   10ecb:	c3                   	ret    

00010ecc <do_handler_page_fault>:

void do_handler_page_fault(exception_frame_t *frame)
{
   10ecc:	55                   	push   %ebp
   10ecd:	89 e5                	mov    %esp,%ebp
   10ecf:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Page_fault Exception.");
   10ed2:	83 ec 08             	sub    $0x8,%esp
   10ed5:	68 13 23 01 00       	push   $0x12313
   10eda:	ff 75 08             	pushl  0x8(%ebp)
   10edd:	e8 88 fd ff ff       	call   10c6a <do_default_handler>
   10ee2:	83 c4 10             	add    $0x10,%esp
}
   10ee5:	90                   	nop
   10ee6:	c9                   	leave  
   10ee7:	c3                   	ret    

00010ee8 <init_pic>:

static void init_pic(void)
{
   10ee8:	55                   	push   %ebp
   10ee9:	89 e5                	mov    %esp,%ebp
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   10eeb:	6a 11                	push   $0x11
   10eed:	6a 20                	push   $0x20
   10eef:	e8 2d fc ff ff       	call   10b21 <outb>
   10ef4:	83 c4 08             	add    $0x8,%esp
    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
   10ef7:	6a 20                	push   $0x20
   10ef9:	6a 21                	push   $0x21
   10efb:	e8 21 fc ff ff       	call   10b21 <outb>
   10f00:	83 c4 08             	add    $0x8,%esp
    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
   10f03:	6a 04                	push   $0x4
   10f05:	6a 21                	push   $0x21
   10f07:	e8 15 fc ff ff       	call   10b21 <outb>
   10f0c:	83 c4 08             	add    $0x8,%esp
    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086);
   10f0f:	6a 01                	push   $0x1
   10f11:	6a 21                	push   $0x21
   10f13:	e8 09 fc ff ff       	call   10b21 <outb>
   10f18:	83 c4 08             	add    $0x8,%esp

    // 第二块芯片
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   10f1b:	6a 11                	push   $0x11
   10f1d:	68 a0 00 00 00       	push   $0xa0
   10f22:	e8 fa fb ff ff       	call   10b21 <outb>
   10f27:	83 c4 08             	add    $0x8,%esp

    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   10f2a:	6a 28                	push   $0x28
   10f2c:	68 a1 00 00 00       	push   $0xa1
   10f31:	e8 eb fb ff ff       	call   10b21 <outb>
   10f36:	83 c4 08             	add    $0x8,%esp

    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
   10f39:	6a 02                	push   $0x2
   10f3b:	68 a1 00 00 00       	push   $0xa1
   10f40:	e8 dc fb ff ff       	call   10b21 <outb>
   10f45:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
   10f48:	6a 01                	push   $0x1
   10f4a:	68 a1 00 00 00       	push   $0xa1
   10f4f:	e8 cd fb ff ff       	call   10b21 <outb>
   10f54:	83 c4 08             	add    $0x8,%esp

    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   10f57:	68 fb 00 00 00       	push   $0xfb
   10f5c:	6a 21                	push   $0x21
   10f5e:	e8 be fb ff ff       	call   10b21 <outb>
   10f63:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   10f66:	68 ff 00 00 00       	push   $0xff
   10f6b:	68 a1 00 00 00       	push   $0xa1
   10f70:	e8 ac fb ff ff       	call   10b21 <outb>
   10f75:	83 c4 08             	add    $0x8,%esp
}
   10f78:	90                   	nop
   10f79:	c9                   	leave  
   10f7a:	c3                   	ret    

00010f7b <irq_init>:

void irq_init(void)
{
   10f7b:	55                   	push   %ebp
   10f7c:	89 e5                	mov    %esp,%ebp
   10f7e:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   10f81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10f88:	eb 25                	jmp    10faf <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   10f8a:	ba 35 00 01 00       	mov    $0x10035,%edx
   10f8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f92:	c1 e0 03             	shl    $0x3,%eax
   10f95:	05 a0 3d 01 00       	add    $0x13da0,%eax
   10f9a:	68 00 8e 00 00       	push   $0x8e00
   10f9f:	52                   	push   %edx
   10fa0:	6a 08                	push   $0x8
   10fa2:	50                   	push   %eax
   10fa3:	e8 e4 fa ff ff       	call   10a8c <gate_desc_set>
   10fa8:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < IDT_TABLE_NR; i++)
   10fab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10faf:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   10fb3:	7e d5                	jle    10f8a <irq_init+0xf>
    }
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   10fb5:	83 ec 08             	sub    $0x8,%esp
   10fb8:	68 54 00 01 00       	push   $0x10054
   10fbd:	6a 00                	push   $0x0
   10fbf:	e8 65 01 00 00       	call   11129 <irq_install>
   10fc4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   10fc7:	83 ec 08             	sub    $0x8,%esp
   10fca:	68 73 00 01 00       	push   $0x10073
   10fcf:	6a 01                	push   $0x1
   10fd1:	e8 53 01 00 00       	call   11129 <irq_install>
   10fd6:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   10fd9:	83 ec 08             	sub    $0x8,%esp
   10fdc:	68 92 00 01 00       	push   $0x10092
   10fe1:	6a 02                	push   $0x2
   10fe3:	e8 41 01 00 00       	call   11129 <irq_install>
   10fe8:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   10feb:	83 ec 08             	sub    $0x8,%esp
   10fee:	68 b1 00 01 00       	push   $0x100b1
   10ff3:	6a 03                	push   $0x3
   10ff5:	e8 2f 01 00 00       	call   11129 <irq_install>
   10ffa:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   10ffd:	83 ec 08             	sub    $0x8,%esp
   11000:	68 d0 00 01 00       	push   $0x100d0
   11005:	6a 04                	push   $0x4
   11007:	e8 1d 01 00 00       	call   11129 <irq_install>
   1100c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   1100f:	83 ec 08             	sub    $0x8,%esp
   11012:	68 ef 00 01 00       	push   $0x100ef
   11017:	6a 05                	push   $0x5
   11019:	e8 0b 01 00 00       	call   11129 <irq_install>
   1101e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   11021:	83 ec 08             	sub    $0x8,%esp
   11024:	68 0e 01 01 00       	push   $0x1010e
   11029:	6a 06                	push   $0x6
   1102b:	e8 f9 00 00 00       	call   11129 <irq_install>
   11030:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   11033:	83 ec 08             	sub    $0x8,%esp
   11036:	68 2d 01 01 00       	push   $0x1012d
   1103b:	6a 07                	push   $0x7
   1103d:	e8 e7 00 00 00       	call   11129 <irq_install>
   11042:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   11045:	83 ec 08             	sub    $0x8,%esp
   11048:	68 4c 01 01 00       	push   $0x1014c
   1104d:	6a 08                	push   $0x8
   1104f:	e8 d5 00 00 00       	call   11129 <irq_install>
   11054:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   11057:	83 ec 08             	sub    $0x8,%esp
   1105a:	68 69 01 01 00       	push   $0x10169
   1105f:	6a 0a                	push   $0xa
   11061:	e8 c3 00 00 00       	call   11129 <irq_install>
   11066:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   11069:	83 ec 08             	sub    $0x8,%esp
   1106c:	68 86 01 01 00       	push   $0x10186
   11071:	6a 0b                	push   $0xb
   11073:	e8 b1 00 00 00       	call   11129 <irq_install>
   11078:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   1107b:	83 ec 08             	sub    $0x8,%esp
   1107e:	68 a3 01 01 00       	push   $0x101a3
   11083:	6a 0c                	push   $0xc
   11085:	e8 9f 00 00 00       	call   11129 <irq_install>
   1108a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   1108d:	83 ec 08             	sub    $0x8,%esp
   11090:	68 c0 01 01 00       	push   $0x101c0
   11095:	6a 0d                	push   $0xd
   11097:	e8 8d 00 00 00       	call   11129 <irq_install>
   1109c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   1109f:	83 ec 08             	sub    $0x8,%esp
   110a2:	68 dd 01 01 00       	push   $0x101dd
   110a7:	6a 0e                	push   $0xe
   110a9:	e8 7b 00 00 00       	call   11129 <irq_install>
   110ae:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   110b1:	83 ec 08             	sub    $0x8,%esp
   110b4:	68 fa 01 01 00       	push   $0x101fa
   110b9:	6a 10                	push   $0x10
   110bb:	e8 69 00 00 00       	call   11129 <irq_install>
   110c0:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   110c3:	83 ec 08             	sub    $0x8,%esp
   110c6:	68 19 02 01 00       	push   $0x10219
   110cb:	6a 11                	push   $0x11
   110cd:	e8 57 00 00 00       	call   11129 <irq_install>
   110d2:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   110d5:	83 ec 08             	sub    $0x8,%esp
   110d8:	68 36 02 01 00       	push   $0x10236
   110dd:	6a 12                	push   $0x12
   110df:	e8 45 00 00 00       	call   11129 <irq_install>
   110e4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   110e7:	83 ec 08             	sub    $0x8,%esp
   110ea:	68 55 02 01 00       	push   $0x10255
   110ef:	6a 13                	push   $0x13
   110f1:	e8 33 00 00 00       	call   11129 <irq_install>
   110f6:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   110f9:	83 ec 08             	sub    $0x8,%esp
   110fc:	68 74 02 01 00       	push   $0x10274
   11101:	6a 14                	push   $0x14
   11103:	e8 21 00 00 00       	call   11129 <irq_install>
   11108:	83 c4 10             	add    $0x10,%esp
    lidt((uint32_t)idt_table, sizeof(idt_table));
   1110b:	b8 a0 3d 01 00       	mov    $0x13da0,%eax
   11110:	83 ec 08             	sub    $0x8,%esp
   11113:	68 00 04 00 00       	push   $0x400
   11118:	50                   	push   %eax
   11119:	e8 30 fa ff ff       	call   10b4e <lidt>
   1111e:	83 c4 10             	add    $0x10,%esp

    init_pic();
   11121:	e8 c2 fd ff ff       	call   10ee8 <init_pic>
}
   11126:	90                   	nop
   11127:	c9                   	leave  
   11128:	c3                   	ret    

00011129 <irq_install>:

int irq_install(int irq_num, irq_handler_t handler)
{
   11129:	55                   	push   %ebp
   1112a:	89 e5                	mov    %esp,%ebp
   1112c:	83 ec 08             	sub    $0x8,%esp
    if (irq_num >= IDT_TABLE_NR)
   1112f:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11133:	7e 07                	jle    1113c <irq_install+0x13>
    {
        return -1;
   11135:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1113a:	eb 25                	jmp    11161 <irq_install+0x38>
    }

    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
   1113c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1113f:	8b 55 08             	mov    0x8(%ebp),%edx
   11142:	c1 e2 03             	shl    $0x3,%edx
   11145:	81 c2 a0 3d 01 00    	add    $0x13da0,%edx
   1114b:	68 00 8e 00 00       	push   $0x8e00
   11150:	50                   	push   %eax
   11151:	6a 08                	push   $0x8
   11153:	52                   	push   %edx
   11154:	e8 33 f9 ff ff       	call   10a8c <gate_desc_set>
   11159:	83 c4 10             	add    $0x10,%esp
    return 0;
   1115c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11161:	c9                   	leave  
   11162:	c3                   	ret    

00011163 <irq_enable>:

void irq_enable(int irq_num)
{
   11163:	55                   	push   %ebp
   11164:	89 e5                	mov    %esp,%ebp
   11166:	53                   	push   %ebx
   11167:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   1116a:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1116e:	7e 78                	jle    111e8 <irq_enable+0x85>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   11170:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   11174:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   11178:	7f 32                	jg     111ac <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   1117a:	6a 21                	push   $0x21
   1117c:	e8 83 f9 ff ff       	call   10b04 <inb>
   11181:	83 c4 04             	add    $0x4,%esp
   11184:	89 c2                	mov    %eax,%edx
   11186:	8b 45 08             	mov    0x8(%ebp),%eax
   11189:	bb 01 00 00 00       	mov    $0x1,%ebx
   1118e:	89 c1                	mov    %eax,%ecx
   11190:	d3 e3                	shl    %cl,%ebx
   11192:	89 d8                	mov    %ebx,%eax
   11194:	f7 d0                	not    %eax
   11196:	21 d0                	and    %edx,%eax
   11198:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   1119b:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1119f:	50                   	push   %eax
   111a0:	6a 21                	push   $0x21
   111a2:	e8 7a f9 ff ff       	call   10b21 <outb>
   111a7:	83 c4 08             	add    $0x8,%esp
   111aa:	eb 3d                	jmp    111e9 <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   111ac:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   111b0:	68 a1 00 00 00       	push   $0xa1
   111b5:	e8 4a f9 ff ff       	call   10b04 <inb>
   111ba:	83 c4 04             	add    $0x4,%esp
   111bd:	89 c2                	mov    %eax,%edx
   111bf:	8b 45 08             	mov    0x8(%ebp),%eax
   111c2:	bb 01 00 00 00       	mov    $0x1,%ebx
   111c7:	89 c1                	mov    %eax,%ecx
   111c9:	d3 e3                	shl    %cl,%ebx
   111cb:	89 d8                	mov    %ebx,%eax
   111cd:	f7 d0                	not    %eax
   111cf:	21 d0                	and    %edx,%eax
   111d1:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   111d4:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   111d8:	50                   	push   %eax
   111d9:	68 a1 00 00 00       	push   $0xa1
   111de:	e8 3e f9 ff ff       	call   10b21 <outb>
   111e3:	83 c4 08             	add    $0x8,%esp
   111e6:	eb 01                	jmp    111e9 <irq_enable+0x86>
        return;
   111e8:	90                   	nop
    }
}
   111e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   111ec:	c9                   	leave  
   111ed:	c3                   	ret    

000111ee <irq_disable>:

void irq_disable(int irq_num)
{
   111ee:	55                   	push   %ebp
   111ef:	89 e5                	mov    %esp,%ebp
   111f1:	53                   	push   %ebx
   111f2:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   111f5:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   111f9:	7e 74                	jle    1126f <irq_disable+0x81>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   111fb:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   111ff:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   11203:	7f 30                	jg     11235 <irq_disable+0x47>
    {
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   11205:	6a 21                	push   $0x21
   11207:	e8 f8 f8 ff ff       	call   10b04 <inb>
   1120c:	83 c4 04             	add    $0x4,%esp
   1120f:	89 c3                	mov    %eax,%ebx
   11211:	8b 45 08             	mov    0x8(%ebp),%eax
   11214:	ba 01 00 00 00       	mov    $0x1,%edx
   11219:	89 c1                	mov    %eax,%ecx
   1121b:	d3 e2                	shl    %cl,%edx
   1121d:	89 d0                	mov    %edx,%eax
   1121f:	09 d8                	or     %ebx,%eax
   11221:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   11224:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   11228:	50                   	push   %eax
   11229:	6a 21                	push   $0x21
   1122b:	e8 f1 f8 ff ff       	call   10b21 <outb>
   11230:	83 c4 08             	add    $0x8,%esp
   11233:	eb 3b                	jmp    11270 <irq_disable+0x82>
    }
    else
    {
        irq_num -= 8;
   11235:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   11239:	68 a1 00 00 00       	push   $0xa1
   1123e:	e8 c1 f8 ff ff       	call   10b04 <inb>
   11243:	83 c4 04             	add    $0x4,%esp
   11246:	89 c3                	mov    %eax,%ebx
   11248:	8b 45 08             	mov    0x8(%ebp),%eax
   1124b:	ba 01 00 00 00       	mov    $0x1,%edx
   11250:	89 c1                	mov    %eax,%ecx
   11252:	d3 e2                	shl    %cl,%edx
   11254:	89 d0                	mov    %edx,%eax
   11256:	09 d8                	or     %ebx,%eax
   11258:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   1125b:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1125f:	50                   	push   %eax
   11260:	68 a1 00 00 00       	push   $0xa1
   11265:	e8 b7 f8 ff ff       	call   10b21 <outb>
   1126a:	83 c4 08             	add    $0x8,%esp
   1126d:	eb 01                	jmp    11270 <irq_disable+0x82>
        return;
   1126f:	90                   	nop
    }
}
   11270:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11273:	c9                   	leave  
   11274:	c3                   	ret    

00011275 <irq_disable_global>:

void irq_disable_global(void)
{
   11275:	55                   	push   %ebp
   11276:	89 e5                	mov    %esp,%ebp
    cli();
   11278:	e8 c3 f8 ff ff       	call   10b40 <cli>
}
   1127d:	90                   	nop
   1127e:	5d                   	pop    %ebp
   1127f:	c3                   	ret    

00011280 <irq_enable_global>:

void irq_enable_global(void)
{
   11280:	55                   	push   %ebp
   11281:	89 e5                	mov    %esp,%ebp
    sti();
   11283:	e8 bf f8 ff ff       	call   10b47 <sti>
}
   11288:	90                   	nop
   11289:	5d                   	pop    %ebp
   1128a:	c3                   	ret    

0001128b <pic_send_eoi>:

void pic_send_eoi(int irq_num)
{
   1128b:	55                   	push   %ebp
   1128c:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   1128e:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    // 从片也可能需要发送EOI
    if (irq_num >= 8)
   11292:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   11296:	7e 0f                	jle    112a7 <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   11298:	6a 20                	push   $0x20
   1129a:	68 a0 00 00 00       	push   $0xa0
   1129f:	e8 7d f8 ff ff       	call   10b21 <outb>
   112a4:	83 c4 08             	add    $0x8,%esp
    }

    outb(PIC0_OCW2, PIC_OCW2_EOI);
   112a7:	6a 20                	push   $0x20
   112a9:	6a 20                	push   $0x20
   112ab:	e8 71 f8 ff ff       	call   10b21 <outb>
   112b0:	83 c4 08             	add    $0x8,%esp
}
   112b3:	90                   	nop
   112b4:	c9                   	leave  
   112b5:	c3                   	ret    

000112b6 <irq_enter_protection>:

/**
 * @brief 进入中断保护
 */
irq_state_t irq_enter_protection(void)
{
   112b6:	55                   	push   %ebp
   112b7:	89 e5                	mov    %esp,%ebp
   112b9:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags(); // 保存之前的中断状态
   112bc:	e8 bc f8 ff ff       	call   10b7d <read_eflags>
   112c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   112c4:	e8 ac ff ff ff       	call   11275 <irq_disable_global>
    return state;
   112c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   112cc:	c9                   	leave  
   112cd:	c3                   	ret    

000112ce <irq_leave_protection>:

/**
 * @brief 退出中断保护
 */
void irq_leave_protection(irq_state_t state)
{
   112ce:	55                   	push   %ebp
   112cf:	89 e5                	mov    %esp,%ebp
    write_eflags(state); // 恢复之前的中断状态
   112d1:	ff 75 08             	pushl  0x8(%ebp)
   112d4:	e8 b4 f8 ff ff       	call   10b8d <write_eflags>
   112d9:	83 c4 04             	add    $0x4,%esp
   112dc:	90                   	nop
   112dd:	c9                   	leave  
   112de:	c3                   	ret    

000112df <outb>:
{
   112df:	55                   	push   %ebp
   112e0:	89 e5                	mov    %esp,%ebp
   112e2:	83 ec 08             	sub    $0x8,%esp
   112e5:	8b 55 08             	mov    0x8(%ebp),%edx
   112e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   112eb:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   112ef:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   112f2:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   112f6:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   112fa:	ee                   	out    %al,(%dx)
}
   112fb:	90                   	nop
   112fc:	c9                   	leave  
   112fd:	c3                   	ret    

000112fe <init_pic>:
#include "cpu/irq.h"
#include "os_cfg.h"
#include "comm/cpu_instr.h"
static uint32_t sys_tick;
static void init_pic(void)
{
   112fe:	55                   	push   %ebp
   112ff:	89 e5                	mov    %esp,%ebp
   11301:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS); // 每隔10ms+1
   11304:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
   1130b:	6a 36                	push   $0x36
   1130d:	6a 43                	push   $0x43
   1130f:	e8 cb ff ff ff       	call   112df <outb>
   11314:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);        // 加载低8位
   11317:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1131a:	0f b6 c0             	movzbl %al,%eax
   1131d:	50                   	push   %eax
   1131e:	6a 40                	push   $0x40
   11320:	e8 ba ff ff ff       	call   112df <outb>
   11325:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   11328:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1132b:	c1 e8 08             	shr    $0x8,%eax
   1132e:	0f b6 c0             	movzbl %al,%eax
   11331:	50                   	push   %eax
   11332:	6a 40                	push   $0x40
   11334:	e8 a6 ff ff ff       	call   112df <outb>
   11339:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_timer);
   1133c:	83 ec 08             	sub    $0x8,%esp
   1133f:	68 93 02 01 00       	push   $0x10293
   11344:	6a 20                	push   $0x20
   11346:	e8 de fd ff ff       	call   11129 <irq_install>
   1134b:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   1134e:	83 ec 0c             	sub    $0xc,%esp
   11351:	6a 20                	push   $0x20
   11353:	e8 0b fe ff ff       	call   11163 <irq_enable>
   11358:	83 c4 10             	add    $0x10,%esp
}
   1135b:	90                   	nop
   1135c:	c9                   	leave  
   1135d:	c3                   	ret    

0001135e <do_handler_timer>:
void do_handler_timer(exception_frame_t *frame)
{
   1135e:	55                   	push   %ebp
   1135f:	89 e5                	mov    %esp,%ebp
   11361:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   11364:	a1 a0 41 01 00       	mov    0x141a0,%eax
   11369:	83 c0 01             	add    $0x1,%eax
   1136c:	a3 a0 41 01 00       	mov    %eax,0x141a0
    // 先发EOI，而不是放在最后
    // 放最后将从任务中切换出去之后，除非任务再切换回来才能继续响应
    pic_send_eoi(IRQ0_TIMER);
   11371:	83 ec 0c             	sub    $0xc,%esp
   11374:	6a 20                	push   $0x20
   11376:	e8 10 ff ff ff       	call   1128b <pic_send_eoi>
   1137b:	83 c4 10             	add    $0x10,%esp

    task_time_tick();
   1137e:	e8 be f3 ff ff       	call   10741 <task_time_tick>
}
   11383:	90                   	nop
   11384:	c9                   	leave  
   11385:	c3                   	ret    

00011386 <time_init>:
void time_init(void)
{
   11386:	55                   	push   %ebp
   11387:	89 e5                	mov    %esp,%ebp
   11389:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   1138c:	c7 05 a0 41 01 00 00 	movl   $0x0,0x141a0
   11393:	00 00 00 
    init_pic();
   11396:	e8 63 ff ff ff       	call   112fe <init_pic>
   1139b:	90                   	nop
   1139c:	c9                   	leave  
   1139d:	c3                   	ret    

0001139e <kernel_init>:
#include "tools/list.h"
#include "comm/cpu_instr.h"
#include "ipc/sem.h"

void kernel_init(boot_info_t *boot_info)
{
   1139e:	55                   	push   %ebp
   1139f:	89 e5                	mov    %esp,%ebp
   113a1:	83 ec 08             	sub    $0x8,%esp
    cpu_init();
   113a4:	e8 2a f7 ff ff       	call   10ad3 <cpu_init>
    log_init();
   113a9:	e8 38 0b 00 00       	call   11ee6 <log_init>
    irq_init();
   113ae:	e8 c8 fb ff ff       	call   10f7b <irq_init>
    time_init();
   113b3:	e8 ce ff ff ff       	call   11386 <time_init>

    task_manager_init();
   113b8:	e8 b9 f1 ff ff       	call   10576 <task_manager_init>
}
   113bd:	90                   	nop
   113be:	c9                   	leave  
   113bf:	c3                   	ret    

000113c0 <init_task_entry>:
static uint32_t init_task_stack[1024];
static sem_t sem;
// static task_t first_task;

void init_task_entry(void)
{
   113c0:	55                   	push   %ebp
   113c1:	89 e5                	mov    %esp,%ebp
   113c3:	83 ec 18             	sub    $0x18,%esp
    int count = 0;
   113c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;;)
    {
        sem_wait(&sem);
   113cd:	83 ec 0c             	sub    $0xc,%esp
   113d0:	68 80 52 01 00       	push   $0x15280
   113d5:	e8 9d 02 00 00       	call   11677 <sem_wait>
   113da:	83 c4 10             	add    $0x10,%esp
        log_printf("init_task_entry: %d", count++);
   113dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113e0:	8d 50 01             	lea    0x1(%eax),%edx
   113e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
   113e6:	83 ec 08             	sub    $0x8,%esp
   113e9:	50                   	push   %eax
   113ea:	68 29 23 01 00       	push   $0x12329
   113ef:	e8 6b 0b 00 00       	call   11f5f <log_printf>
   113f4:	83 c4 10             	add    $0x10,%esp
        sem_wait(&sem);
   113f7:	eb d4                	jmp    113cd <init_task_entry+0xd>

000113f9 <init_main>:
//     }
//     log_printf("list: first=0x%x, last=0x%x, count=%d", list_first(&list), list_last(&list), list_count(&list));
// }

void init_main(void)
{
   113f9:	55                   	push   %ebp
   113fa:	89 e5                	mov    %esp,%ebp
   113fc:	83 ec 18             	sub    $0x18,%esp
    // list_test();

    log_printf("Kernel is running...");
   113ff:	83 ec 0c             	sub    $0xc,%esp
   11402:	68 3d 23 01 00       	push   $0x1233d
   11407:	e8 53 0b 00 00       	call   11f5f <log_printf>
   1140c:	83 c4 10             	add    $0x10,%esp
    log_printf("Version: %s", OS_VERSION);
   1140f:	83 ec 08             	sub    $0x8,%esp
   11412:	68 52 23 01 00       	push   $0x12352
   11417:	68 58 23 01 00       	push   $0x12358
   1141c:	e8 3e 0b 00 00       	call   11f5f <log_printf>
   11421:	83 c4 10             	add    $0x10,%esp
    log_printf("%d %d %x %c", 123456, -123, 0x123456, 'a');
   11424:	83 ec 0c             	sub    $0xc,%esp
   11427:	6a 61                	push   $0x61
   11429:	68 56 34 12 00       	push   $0x123456
   1142e:	6a 85                	push   $0xffffff85
   11430:	68 40 e2 01 00       	push   $0x1e240
   11435:	68 64 23 01 00       	push   $0x12364
   1143a:	e8 20 0b 00 00       	call   11f5f <log_printf>
   1143f:	83 c4 20             	add    $0x20,%esp

    task_init(&init_task, "init task", (uint32_t)init_task_entry, (uint32_t)&init_task_stack[1024]); // 压栈先-4再入栈
   11442:	ba 80 52 01 00       	mov    $0x15280,%edx
   11447:	b8 c0 13 01 00       	mov    $0x113c0,%eax
   1144c:	52                   	push   %edx
   1144d:	50                   	push   %eax
   1144e:	68 70 23 01 00       	push   $0x12370
   11453:	68 c0 41 01 00       	push   $0x141c0
   11458:	e8 bc ef ff ff       	call   10419 <task_init>
   1145d:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   11460:	e8 c3 f0 ff ff       	call   10528 <task_first_init>

    sem_init(&sem, 0);
   11465:	83 ec 08             	sub    $0x8,%esp
   11468:	6a 00                	push   $0x0
   1146a:	68 80 52 01 00       	push   $0x15280
   1146f:	e8 e0 01 00 00       	call   11654 <sem_init>
   11474:	83 c4 10             	add    $0x10,%esp
    irq_enable_global(); // 用时间片中断来调度
   11477:	e8 04 fe ff ff       	call   11280 <irq_enable_global>

    int count = 0;
   1147c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;;)
    {
        log_printf("init_main: %d", count++);
   11483:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11486:	8d 50 01             	lea    0x1(%eax),%edx
   11489:	89 55 f4             	mov    %edx,-0xc(%ebp)
   1148c:	83 ec 08             	sub    $0x8,%esp
   1148f:	50                   	push   %eax
   11490:	68 7a 23 01 00       	push   $0x1237a
   11495:	e8 c5 0a 00 00       	call   11f5f <log_printf>
   1149a:	83 c4 10             	add    $0x10,%esp
        sem_notify(&sem);
   1149d:	83 ec 0c             	sub    $0xc,%esp
   114a0:	68 80 52 01 00       	push   $0x15280
   114a5:	e8 38 02 00 00       	call   116e2 <sem_notify>
   114aa:	83 c4 10             	add    $0x10,%esp
        sys_msleep(1000);
   114ad:	83 ec 0c             	sub    $0xc,%esp
   114b0:	68 e8 03 00 00       	push   $0x3e8
   114b5:	e8 cb f3 ff ff       	call   10885 <sys_msleep>
   114ba:	83 c4 10             	add    $0x10,%esp
        log_printf("init_main: %d", count++);
   114bd:	eb c4                	jmp    11483 <init_main+0x8a>

000114bf <list_count>:
{
   114bf:	55                   	push   %ebp
   114c0:	89 e5                	mov    %esp,%ebp
    return list->count;
   114c2:	8b 45 08             	mov    0x8(%ebp),%eax
   114c5:	8b 40 08             	mov    0x8(%eax),%eax
}
   114c8:	5d                   	pop    %ebp
   114c9:	c3                   	ret    

000114ca <mutex_init>:

/**
 * 锁初始化
 */
void mutex_init(mutex_t *mutex)
{
   114ca:	55                   	push   %ebp
   114cb:	89 e5                	mov    %esp,%ebp
   114cd:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count = 0;
   114d0:	8b 45 08             	mov    0x8(%ebp),%eax
   114d3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner = (task_t *)0;
   114da:	8b 45 08             	mov    0x8(%ebp),%eax
   114dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   114e3:	8b 45 08             	mov    0x8(%ebp),%eax
   114e6:	83 c0 08             	add    $0x8,%eax
   114e9:	83 ec 0c             	sub    $0xc,%esp
   114ec:	50                   	push   %eax
   114ed:	e8 d3 07 00 00       	call   11cc5 <list_init>
   114f2:	83 c4 10             	add    $0x10,%esp
}
   114f5:	90                   	nop
   114f6:	c9                   	leave  
   114f7:	c3                   	ret    

000114f8 <mutex_lock>:

/**
 * 申请锁
 */
void mutex_lock(mutex_t *mutex)
{
   114f8:	55                   	push   %ebp
   114f9:	89 e5                	mov    %esp,%ebp
   114fb:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   114fe:	e8 b3 fd ff ff       	call   112b6 <irq_enter_protection>
   11503:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *curr = task_current();
   11506:	e8 30 f1 ff ff       	call   1063b <task_current>
   1150b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->locked_count == 0)
   1150e:	8b 45 08             	mov    0x8(%ebp),%eax
   11511:	8b 40 04             	mov    0x4(%eax),%eax
   11514:	85 c0                	test   %eax,%eax
   11516:	75 14                	jne    1152c <mutex_lock+0x34>
    {
        // 没有任务占用，占用之
        mutex->locked_count = 1;
   11518:	8b 45 08             	mov    0x8(%ebp),%eax
   1151b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner = curr;
   11522:	8b 45 08             	mov    0x8(%ebp),%eax
   11525:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11528:	89 10                	mov    %edx,(%eax)
   1152a:	eb 4f                	jmp    1157b <mutex_lock+0x83>
    }
    else if (mutex->owner == curr)
   1152c:	8b 45 08             	mov    0x8(%ebp),%eax
   1152f:	8b 00                	mov    (%eax),%eax
   11531:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11534:	75 11                	jne    11547 <mutex_lock+0x4f>
    {
        // 已经为当前任务所有，只增加计数
        mutex->locked_count++;
   11536:	8b 45 08             	mov    0x8(%ebp),%eax
   11539:	8b 40 04             	mov    0x4(%eax),%eax
   1153c:	8d 50 01             	lea    0x1(%eax),%edx
   1153f:	8b 45 08             	mov    0x8(%ebp),%eax
   11542:	89 50 04             	mov    %edx,0x4(%eax)
   11545:	eb 34                	jmp    1157b <mutex_lock+0x83>
    }
    else
    {
        // 有其它任务占用，则进入队列等待
        task_t *curr = task_current();
   11547:	e8 ef f0 ff ff       	call   1063b <task_current>
   1154c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr);
   1154f:	83 ec 0c             	sub    $0xc,%esp
   11552:	ff 75 ec             	pushl  -0x14(%ebp)
   11555:	e8 b6 f0 ff ff       	call   10610 <task_set_block>
   1155a:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   1155d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11560:	8d 50 38             	lea    0x38(%eax),%edx
   11563:	8b 45 08             	mov    0x8(%ebp),%eax
   11566:	83 c0 08             	add    $0x8,%eax
   11569:	83 ec 08             	sub    $0x8,%esp
   1156c:	52                   	push   %edx
   1156d:	50                   	push   %eax
   1156e:	e8 d6 07 00 00       	call   11d49 <list_insert_last>
   11573:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   11576:	e8 6b f1 ff ff       	call   106e6 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   1157b:	83 ec 0c             	sub    $0xc,%esp
   1157e:	ff 75 f4             	pushl  -0xc(%ebp)
   11581:	e8 48 fd ff ff       	call   112ce <irq_leave_protection>
   11586:	83 c4 10             	add    $0x10,%esp
}
   11589:	90                   	nop
   1158a:	c9                   	leave  
   1158b:	c3                   	ret    

0001158c <mutex_unlock>:

/**
 * 释放锁
 */
void mutex_unlock(mutex_t *mutex)
{
   1158c:	55                   	push   %ebp
   1158d:	89 e5                	mov    %esp,%ebp
   1158f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   11592:	e8 1f fd ff ff       	call   112b6 <irq_enter_protection>
   11597:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 只有锁的拥有者才能释放锁
    task_t *curr = task_current();
   1159a:	e8 9c f0 ff ff       	call   1063b <task_current>
   1159f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->owner == curr)
   115a2:	8b 45 08             	mov    0x8(%ebp),%eax
   115a5:	8b 00                	mov    (%eax),%eax
   115a7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   115aa:	0f 85 88 00 00 00    	jne    11638 <mutex_unlock+0xac>
    {
        if (--mutex->locked_count == 0)
   115b0:	8b 45 08             	mov    0x8(%ebp),%eax
   115b3:	8b 40 04             	mov    0x4(%eax),%eax
   115b6:	8d 50 ff             	lea    -0x1(%eax),%edx
   115b9:	8b 45 08             	mov    0x8(%ebp),%eax
   115bc:	89 50 04             	mov    %edx,0x4(%eax)
   115bf:	8b 45 08             	mov    0x8(%ebp),%eax
   115c2:	8b 40 04             	mov    0x4(%eax),%eax
   115c5:	85 c0                	test   %eax,%eax
   115c7:	75 6f                	jne    11638 <mutex_unlock+0xac>
        {
            // 减到0，释放锁
            mutex->owner = (task_t *)0;
   115c9:	8b 45 08             	mov    0x8(%ebp),%eax
   115cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            // 如果队列中有任务等待，则立即唤醒并占用锁
            if (list_count(&mutex->wait_list))
   115d2:	8b 45 08             	mov    0x8(%ebp),%eax
   115d5:	83 c0 08             	add    $0x8,%eax
   115d8:	83 ec 0c             	sub    $0xc,%esp
   115db:	50                   	push   %eax
   115dc:	e8 de fe ff ff       	call   114bf <list_count>
   115e1:	83 c4 10             	add    $0x10,%esp
   115e4:	85 c0                	test   %eax,%eax
   115e6:	74 50                	je     11638 <mutex_unlock+0xac>
            {
                list_node_t *task_node = list_remove_first(&mutex->wait_list);
   115e8:	8b 45 08             	mov    0x8(%ebp),%eax
   115eb:	83 c0 08             	add    $0x8,%eax
   115ee:	83 ec 0c             	sub    $0xc,%esp
   115f1:	50                   	push   %eax
   115f2:	e8 b6 07 00 00       	call   11dad <list_remove_first>
   115f7:	83 c4 10             	add    $0x10,%esp
   115fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t *task = list_node_parent(task_node, task_t, wait_node);
   115fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11601:	74 08                	je     1160b <mutex_unlock+0x7f>
   11603:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11606:	83 e8 38             	sub    $0x38,%eax
   11609:	eb 05                	jmp    11610 <mutex_unlock+0x84>
   1160b:	b8 00 00 00 00       	mov    $0x0,%eax
   11610:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   11613:	83 ec 0c             	sub    $0xc,%esp
   11616:	ff 75 e8             	pushl  -0x18(%ebp)
   11619:	e8 be ef ff ff       	call   105dc <task_set_ready>
   1161e:	83 c4 10             	add    $0x10,%esp

                // 在这里占用，而不是在任务醒后占用，因为可能抢不到
                mutex->locked_count = 1;
   11621:	8b 45 08             	mov    0x8(%ebp),%eax
   11624:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner = task;
   1162b:	8b 45 08             	mov    0x8(%ebp),%eax
   1162e:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11631:	89 10                	mov    %edx,(%eax)

                task_dispatch();
   11633:	e8 ae f0 ff ff       	call   106e6 <task_dispatch>
            }
        }
    }

    irq_leave_protection(irq_state);
   11638:	83 ec 0c             	sub    $0xc,%esp
   1163b:	ff 75 f4             	pushl  -0xc(%ebp)
   1163e:	e8 8b fc ff ff       	call   112ce <irq_leave_protection>
   11643:	83 c4 10             	add    $0x10,%esp
   11646:	90                   	nop
   11647:	c9                   	leave  
   11648:	c3                   	ret    

00011649 <list_count>:
{
   11649:	55                   	push   %ebp
   1164a:	89 e5                	mov    %esp,%ebp
    return list->count;
   1164c:	8b 45 08             	mov    0x8(%ebp),%eax
   1164f:	8b 40 08             	mov    0x8(%eax),%eax
}
   11652:	5d                   	pop    %ebp
   11653:	c3                   	ret    

00011654 <sem_init>:

/**
 * 信号量初始化
 */
void sem_init(sem_t *sem, int init_count)
{
   11654:	55                   	push   %ebp
   11655:	89 e5                	mov    %esp,%ebp
   11657:	83 ec 08             	sub    $0x8,%esp
    sem->count = init_count;
   1165a:	8b 45 08             	mov    0x8(%ebp),%eax
   1165d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11660:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   11662:	8b 45 08             	mov    0x8(%ebp),%eax
   11665:	83 c0 04             	add    $0x4,%eax
   11668:	83 ec 0c             	sub    $0xc,%esp
   1166b:	50                   	push   %eax
   1166c:	e8 54 06 00 00       	call   11cc5 <list_init>
   11671:	83 c4 10             	add    $0x10,%esp
}
   11674:	90                   	nop
   11675:	c9                   	leave  
   11676:	c3                   	ret    

00011677 <sem_wait>:

/**
 * 申请信号量
 */
void sem_wait(sem_t *sem)
{
   11677:	55                   	push   %ebp
   11678:	89 e5                	mov    %esp,%ebp
   1167a:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   1167d:	e8 34 fc ff ff       	call   112b6 <irq_enter_protection>
   11682:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (sem->count > 0)
   11685:	8b 45 08             	mov    0x8(%ebp),%eax
   11688:	8b 00                	mov    (%eax),%eax
   1168a:	85 c0                	test   %eax,%eax
   1168c:	7e 0f                	jle    1169d <sem_wait+0x26>
    {
        sem->count--;
   1168e:	8b 45 08             	mov    0x8(%ebp),%eax
   11691:	8b 00                	mov    (%eax),%eax
   11693:	8d 50 ff             	lea    -0x1(%eax),%edx
   11696:	8b 45 08             	mov    0x8(%ebp),%eax
   11699:	89 10                	mov    %edx,(%eax)
   1169b:	eb 34                	jmp    116d1 <sem_wait+0x5a>
    }
    else
    {
        // 从就绪队列中移除，然后加入信号量的等待队列
        task_t *curr = task_current();
   1169d:	e8 99 ef ff ff       	call   1063b <task_current>
   116a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   116a5:	83 ec 0c             	sub    $0xc,%esp
   116a8:	ff 75 f0             	pushl  -0x10(%ebp)
   116ab:	e8 60 ef ff ff       	call   10610 <task_set_block>
   116b0:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &curr->wait_node);
   116b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116b6:	8d 50 38             	lea    0x38(%eax),%edx
   116b9:	8b 45 08             	mov    0x8(%ebp),%eax
   116bc:	83 c0 04             	add    $0x4,%eax
   116bf:	83 ec 08             	sub    $0x8,%esp
   116c2:	52                   	push   %edx
   116c3:	50                   	push   %eax
   116c4:	e8 80 06 00 00       	call   11d49 <list_insert_last>
   116c9:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   116cc:	e8 15 f0 ff ff       	call   106e6 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   116d1:	83 ec 0c             	sub    $0xc,%esp
   116d4:	ff 75 f4             	pushl  -0xc(%ebp)
   116d7:	e8 f2 fb ff ff       	call   112ce <irq_leave_protection>
   116dc:	83 c4 10             	add    $0x10,%esp
}
   116df:	90                   	nop
   116e0:	c9                   	leave  
   116e1:	c3                   	ret    

000116e2 <sem_notify>:

/**
 * 释放信号量
 */
void sem_notify(sem_t *sem)
{
   116e2:	55                   	push   %ebp
   116e3:	89 e5                	mov    %esp,%ebp
   116e5:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   116e8:	e8 c9 fb ff ff       	call   112b6 <irq_enter_protection>
   116ed:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&sem->wait_list))
   116f0:	8b 45 08             	mov    0x8(%ebp),%eax
   116f3:	83 c0 04             	add    $0x4,%eax
   116f6:	83 ec 0c             	sub    $0xc,%esp
   116f9:	50                   	push   %eax
   116fa:	e8 4a ff ff ff       	call   11649 <list_count>
   116ff:	83 c4 10             	add    $0x10,%esp
   11702:	85 c0                	test   %eax,%eax
   11704:	74 40                	je     11746 <sem_notify+0x64>
    {
        // 有进程等待，则唤醒加入就绪队列
        list_node_t *node = list_remove_first(&sem->wait_list);
   11706:	8b 45 08             	mov    0x8(%ebp),%eax
   11709:	83 c0 04             	add    $0x4,%eax
   1170c:	83 ec 0c             	sub    $0xc,%esp
   1170f:	50                   	push   %eax
   11710:	e8 98 06 00 00       	call   11dad <list_remove_first>
   11715:	83 c4 10             	add    $0x10,%esp
   11718:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node, task_t, wait_node);
   1171b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1171f:	74 08                	je     11729 <sem_notify+0x47>
   11721:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11724:	83 e8 38             	sub    $0x38,%eax
   11727:	eb 05                	jmp    1172e <sem_notify+0x4c>
   11729:	b8 00 00 00 00       	mov    $0x0,%eax
   1172e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   11731:	83 ec 0c             	sub    $0xc,%esp
   11734:	ff 75 ec             	pushl  -0x14(%ebp)
   11737:	e8 a0 ee ff ff       	call   105dc <task_set_ready>
   1173c:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   1173f:	e8 a2 ef ff ff       	call   106e6 <task_dispatch>
   11744:	eb 0d                	jmp    11753 <sem_notify+0x71>
    }
    else
    {
        sem->count++;
   11746:	8b 45 08             	mov    0x8(%ebp),%eax
   11749:	8b 00                	mov    (%eax),%eax
   1174b:	8d 50 01             	lea    0x1(%eax),%edx
   1174e:	8b 45 08             	mov    0x8(%ebp),%eax
   11751:	89 10                	mov    %edx,(%eax)
    }

    irq_leave_protection(irq_state);
   11753:	83 ec 0c             	sub    $0xc,%esp
   11756:	ff 75 f4             	pushl  -0xc(%ebp)
   11759:	e8 70 fb ff ff       	call   112ce <irq_leave_protection>
   1175e:	83 c4 10             	add    $0x10,%esp
}
   11761:	90                   	nop
   11762:	c9                   	leave  
   11763:	c3                   	ret    

00011764 <sem_count>:

/**
 * 获取信号量的当前值
 */
int sem_count(sem_t *sem)
{
   11764:	55                   	push   %ebp
   11765:	89 e5                	mov    %esp,%ebp
   11767:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   1176a:	e8 47 fb ff ff       	call   112b6 <irq_enter_protection>
   1176f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   11772:	8b 45 08             	mov    0x8(%ebp),%eax
   11775:	8b 00                	mov    (%eax),%eax
   11777:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(irq_state);
   1177a:	83 ec 0c             	sub    $0xc,%esp
   1177d:	ff 75 f4             	pushl  -0xc(%ebp)
   11780:	e8 49 fb ff ff       	call   112ce <irq_leave_protection>
   11785:	83 c4 10             	add    $0x10,%esp
    return count;
   11788:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1178b:	c9                   	leave  
   1178c:	c3                   	ret    

0001178d <hlt>:
{
   1178d:	55                   	push   %ebp
   1178e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   11790:	f4                   	hlt    
}
   11791:	90                   	nop
   11792:	5d                   	pop    %ebp
   11793:	c3                   	ret    

00011794 <kernel_strcpy>:
#include "tools/klib.h"
#include "comm/types.h"
#include "comm/cpu_instr.h"

void kernel_strcpy(char *dest, const char *src)
{
   11794:	55                   	push   %ebp
   11795:	89 e5                	mov    %esp,%ebp
    if (!dest || !src)
   11797:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1179b:	74 3b                	je     117d8 <kernel_strcpy+0x44>
   1179d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   117a1:	74 35                	je     117d8 <kernel_strcpy+0x44>
    {
        return;
    }

    while (*dest && *src)
   117a3:	eb 17                	jmp    117bc <kernel_strcpy+0x28>
    {
        *dest++ = *src++;
   117a5:	8b 55 0c             	mov    0xc(%ebp),%edx
   117a8:	8d 42 01             	lea    0x1(%edx),%eax
   117ab:	89 45 0c             	mov    %eax,0xc(%ebp)
   117ae:	8b 45 08             	mov    0x8(%ebp),%eax
   117b1:	8d 48 01             	lea    0x1(%eax),%ecx
   117b4:	89 4d 08             	mov    %ecx,0x8(%ebp)
   117b7:	0f b6 12             	movzbl (%edx),%edx
   117ba:	88 10                	mov    %dl,(%eax)
    while (*dest && *src)
   117bc:	8b 45 08             	mov    0x8(%ebp),%eax
   117bf:	0f b6 00             	movzbl (%eax),%eax
   117c2:	84 c0                	test   %al,%al
   117c4:	74 0a                	je     117d0 <kernel_strcpy+0x3c>
   117c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   117c9:	0f b6 00             	movzbl (%eax),%eax
   117cc:	84 c0                	test   %al,%al
   117ce:	75 d5                	jne    117a5 <kernel_strcpy+0x11>
    }
    *dest = '\0';
   117d0:	8b 45 08             	mov    0x8(%ebp),%eax
   117d3:	c6 00 00             	movb   $0x0,(%eax)
   117d6:	eb 01                	jmp    117d9 <kernel_strcpy+0x45>
        return;
   117d8:	90                   	nop
}
   117d9:	5d                   	pop    %ebp
   117da:	c3                   	ret    

000117db <kernel_strncpy>:

void kernel_strncpy(char *dest, const char *src, int size)
{
   117db:	55                   	push   %ebp
   117dc:	89 e5                	mov    %esp,%ebp
   117de:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   117e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   117e5:	74 61                	je     11848 <kernel_strncpy+0x6d>
   117e7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   117eb:	74 5b                	je     11848 <kernel_strncpy+0x6d>
   117ed:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   117f1:	74 55                	je     11848 <kernel_strncpy+0x6d>
    {
        return;
    }

    char *d = dest;
   117f3:	8b 45 08             	mov    0x8(%ebp),%eax
   117f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   117f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   117fc:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while ((size-- > 0) && (*s))
   117ff:	eb 17                	jmp    11818 <kernel_strncpy+0x3d>
    {
        *d++ = *s++;
   11801:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11804:	8d 42 01             	lea    0x1(%edx),%eax
   11807:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1180a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1180d:	8d 48 01             	lea    0x1(%eax),%ecx
   11810:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   11813:	0f b6 12             	movzbl (%edx),%edx
   11816:	88 10                	mov    %dl,(%eax)
    while ((size-- > 0) && (*s))
   11818:	8b 45 10             	mov    0x10(%ebp),%eax
   1181b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1181e:	89 55 10             	mov    %edx,0x10(%ebp)
   11821:	85 c0                	test   %eax,%eax
   11823:	7e 0a                	jle    1182f <kernel_strncpy+0x54>
   11825:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11828:	0f b6 00             	movzbl (%eax),%eax
   1182b:	84 c0                	test   %al,%al
   1182d:	75 d2                	jne    11801 <kernel_strncpy+0x26>
    }
    if (size == 0)
   1182f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11833:	75 0b                	jne    11840 <kernel_strncpy+0x65>
    {
        *(d - 1) = '\0';
   11835:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11838:	83 e8 01             	sub    $0x1,%eax
   1183b:	c6 00 00             	movb   $0x0,(%eax)
   1183e:	eb 09                	jmp    11849 <kernel_strncpy+0x6e>
    }
    else
    {
        *d = '\0';
   11840:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11843:	c6 00 00             	movb   $0x0,(%eax)
   11846:	eb 01                	jmp    11849 <kernel_strncpy+0x6e>
        return;
   11848:	90                   	nop
    }
}
   11849:	c9                   	leave  
   1184a:	c3                   	ret    

0001184b <kernel_strncmp>:

int kernel_strncmp(const char *s1, const char *s2, int size)
{
   1184b:	55                   	push   %ebp
   1184c:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2)
   1184e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11852:	74 06                	je     1185a <kernel_strncmp+0xf>
   11854:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11858:	75 13                	jne    1186d <kernel_strncmp+0x22>
    {
        return -1;
   1185a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1185f:	eb 66                	jmp    118c7 <kernel_strncmp+0x7c>
    }

    while (*s1 && *s2 && (*s1 == *s2) && size)
    {
        s1++;
   11861:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   11865:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        size--;
   11869:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    while (*s1 && *s2 && (*s1 == *s2) && size)
   1186d:	8b 45 08             	mov    0x8(%ebp),%eax
   11870:	0f b6 00             	movzbl (%eax),%eax
   11873:	84 c0                	test   %al,%al
   11875:	74 20                	je     11897 <kernel_strncmp+0x4c>
   11877:	8b 45 0c             	mov    0xc(%ebp),%eax
   1187a:	0f b6 00             	movzbl (%eax),%eax
   1187d:	84 c0                	test   %al,%al
   1187f:	74 16                	je     11897 <kernel_strncmp+0x4c>
   11881:	8b 45 08             	mov    0x8(%ebp),%eax
   11884:	0f b6 10             	movzbl (%eax),%edx
   11887:	8b 45 0c             	mov    0xc(%ebp),%eax
   1188a:	0f b6 00             	movzbl (%eax),%eax
   1188d:	38 c2                	cmp    %al,%dl
   1188f:	75 06                	jne    11897 <kernel_strncmp+0x4c>
   11891:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11895:	75 ca                	jne    11861 <kernel_strncmp+0x16>
    }
    // 相等返回0
    // s1="abc",s2="abcdef" 也属于相等
    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   11897:	8b 45 08             	mov    0x8(%ebp),%eax
   1189a:	0f b6 00             	movzbl (%eax),%eax
   1189d:	84 c0                	test   %al,%al
   1189f:	74 21                	je     118c2 <kernel_strncmp+0x77>
   118a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   118a4:	0f b6 00             	movzbl (%eax),%eax
   118a7:	84 c0                	test   %al,%al
   118a9:	74 17                	je     118c2 <kernel_strncmp+0x77>
   118ab:	8b 45 08             	mov    0x8(%ebp),%eax
   118ae:	0f b6 10             	movzbl (%eax),%edx
   118b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   118b4:	0f b6 00             	movzbl (%eax),%eax
   118b7:	38 c2                	cmp    %al,%dl
   118b9:	74 07                	je     118c2 <kernel_strncmp+0x77>
   118bb:	b8 01 00 00 00       	mov    $0x1,%eax
   118c0:	eb 05                	jmp    118c7 <kernel_strncmp+0x7c>
   118c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   118c7:	5d                   	pop    %ebp
   118c8:	c3                   	ret    

000118c9 <kernel_strlen>:

int kernel_strlen(const char *str)
{
   118c9:	55                   	push   %ebp
   118ca:	89 e5                	mov    %esp,%ebp
   118cc:	83 ec 10             	sub    $0x10,%esp
    if (str == (const char *)0)
   118cf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   118d3:	75 07                	jne    118dc <kernel_strlen+0x13>
    {
        return 0;
   118d5:	b8 00 00 00 00       	mov    $0x0,%eax
   118da:	eb 26                	jmp    11902 <kernel_strlen+0x39>
    }

    const char *c = str;
   118dc:	8b 45 08             	mov    0x8(%ebp),%eax
   118df:	89 45 fc             	mov    %eax,-0x4(%ebp)

    int len = 0;
   118e2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while (*c++)
   118e9:	eb 04                	jmp    118ef <kernel_strlen+0x26>
    {
        len++;
   118eb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (*c++)
   118ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   118f2:	8d 50 01             	lea    0x1(%eax),%edx
   118f5:	89 55 fc             	mov    %edx,-0x4(%ebp)
   118f8:	0f b6 00             	movzbl (%eax),%eax
   118fb:	84 c0                	test   %al,%al
   118fd:	75 ec                	jne    118eb <kernel_strlen+0x22>
    }

    return len;
   118ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   11902:	c9                   	leave  
   11903:	c3                   	ret    

00011904 <kernel_memcpy>:

void kernel_memcpy(void *dest, void *src, int size)
{
   11904:	55                   	push   %ebp
   11905:	89 e5                	mov    %esp,%ebp
   11907:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   1190a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1190e:	74 40                	je     11950 <kernel_memcpy+0x4c>
   11910:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11914:	74 3a                	je     11950 <kernel_memcpy+0x4c>
   11916:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1191a:	74 34                	je     11950 <kernel_memcpy+0x4c>
    {
        return;
    }

    uint8_t *s = (uint8_t *)src;
   1191c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1191f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *d = (uint8_t *)dest;
   11922:	8b 45 08             	mov    0x8(%ebp),%eax
   11925:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   11928:	eb 17                	jmp    11941 <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   1192a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1192d:	8d 42 01             	lea    0x1(%edx),%eax
   11930:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11933:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11936:	8d 48 01             	lea    0x1(%eax),%ecx
   11939:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   1193c:	0f b6 12             	movzbl (%edx),%edx
   1193f:	88 10                	mov    %dl,(%eax)
    while (size--)
   11941:	8b 45 10             	mov    0x10(%ebp),%eax
   11944:	8d 50 ff             	lea    -0x1(%eax),%edx
   11947:	89 55 10             	mov    %edx,0x10(%ebp)
   1194a:	85 c0                	test   %eax,%eax
   1194c:	75 dc                	jne    1192a <kernel_memcpy+0x26>
   1194e:	eb 01                	jmp    11951 <kernel_memcpy+0x4d>
        return;
   11950:	90                   	nop
    }
}
   11951:	c9                   	leave  
   11952:	c3                   	ret    

00011953 <kernel_memset>:

// 内存逐字节设置v
void kernel_memset(void *dest, uint8_t v, int size)
{
   11953:	55                   	push   %ebp
   11954:	89 e5                	mov    %esp,%ebp
   11956:	83 ec 14             	sub    $0x14,%esp
   11959:	8b 45 0c             	mov    0xc(%ebp),%eax
   1195c:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (!dest || !size)
   1195f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11963:	74 2c                	je     11991 <kernel_memset+0x3e>
   11965:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11969:	74 26                	je     11991 <kernel_memset+0x3e>
    {
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   1196b:	8b 45 08             	mov    0x8(%ebp),%eax
   1196e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (size--)
   11971:	eb 0f                	jmp    11982 <kernel_memset+0x2f>
    {
        *d++ = v;
   11973:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11976:	8d 50 01             	lea    0x1(%eax),%edx
   11979:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1197c:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   11980:	88 10                	mov    %dl,(%eax)
    while (size--)
   11982:	8b 45 10             	mov    0x10(%ebp),%eax
   11985:	8d 50 ff             	lea    -0x1(%eax),%edx
   11988:	89 55 10             	mov    %edx,0x10(%ebp)
   1198b:	85 c0                	test   %eax,%eax
   1198d:	75 e4                	jne    11973 <kernel_memset+0x20>
   1198f:	eb 01                	jmp    11992 <kernel_memset+0x3f>
        return;
   11991:	90                   	nop
    }
}
   11992:	c9                   	leave  
   11993:	c3                   	ret    

00011994 <kernel_memcmp>:

int kernel_memcmp(void *d1, void *d2, int size)
{
   11994:	55                   	push   %ebp
   11995:	89 e5                	mov    %esp,%ebp
   11997:	83 ec 10             	sub    $0x10,%esp
    if (!d1 || !d2)
   1199a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1199e:	74 06                	je     119a6 <kernel_memcmp+0x12>
   119a0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   119a4:	75 07                	jne    119ad <kernel_memcmp+0x19>
    {
        return 1;
   119a6:	b8 01 00 00 00       	mov    $0x1,%eax
   119ab:	eb 43                	jmp    119f0 <kernel_memcmp+0x5c>
    }

    uint8_t *p_d1 = (uint8_t *)d1;
   119ad:	8b 45 08             	mov    0x8(%ebp),%eax
   119b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2 = (uint8_t *)d2;
   119b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   119b9:	eb 23                	jmp    119de <kernel_memcmp+0x4a>
    {
        if (*p_d1++ != *p_d2++)
   119bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   119be:	8d 50 01             	lea    0x1(%eax),%edx
   119c1:	89 55 fc             	mov    %edx,-0x4(%ebp)
   119c4:	0f b6 08             	movzbl (%eax),%ecx
   119c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   119ca:	8d 50 01             	lea    0x1(%eax),%edx
   119cd:	89 55 f8             	mov    %edx,-0x8(%ebp)
   119d0:	0f b6 00             	movzbl (%eax),%eax
   119d3:	38 c1                	cmp    %al,%cl
   119d5:	74 07                	je     119de <kernel_memcmp+0x4a>
        {
            return 1;
   119d7:	b8 01 00 00 00       	mov    $0x1,%eax
   119dc:	eb 12                	jmp    119f0 <kernel_memcmp+0x5c>
    while (size--)
   119de:	8b 45 10             	mov    0x10(%ebp),%eax
   119e1:	8d 50 ff             	lea    -0x1(%eax),%edx
   119e4:	89 55 10             	mov    %edx,0x10(%ebp)
   119e7:	85 c0                	test   %eax,%eax
   119e9:	75 d0                	jne    119bb <kernel_memcmp+0x27>
        }
    }

    // 内存一样返回0
    return 0;
   119eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   119f0:	c9                   	leave  
   119f1:	c3                   	ret    

000119f2 <kernel_itoa>:

void kernel_itoa(char *buf, int num, int base)
{
   119f2:	55                   	push   %ebp
   119f3:	89 e5                	mov    %esp,%ebp
   119f5:	53                   	push   %ebx
   119f6:	83 ec 20             	sub    $0x20,%esp
    // 转换字符索引[-15, -14, ...-1, 0, 1, ...., 14, 15]
    static const char *num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char *p = buf;
   119f9:	8b 45 08             	mov    0x8(%ebp),%eax
   119fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   119ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a02:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 仅支持部分进制
    if ((base != 2) && (base != 8) && (base != 10) && (base != 16))
   11a05:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   11a09:	74 1d                	je     11a28 <kernel_itoa+0x36>
   11a0b:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   11a0f:	74 17                	je     11a28 <kernel_itoa+0x36>
   11a11:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   11a15:	74 11                	je     11a28 <kernel_itoa+0x36>
   11a17:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   11a1b:	74 0b                	je     11a28 <kernel_itoa+0x36>
    {
        *p = '\0';
   11a1d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a20:	c6 00 00             	movb   $0x0,(%eax)
        return;
   11a23:	e9 03 01 00 00       	jmp    11b2b <kernel_itoa+0x139>
    }

    // 只支持十进制负数
    int signed_num = 0;
   11a28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10))
   11a2f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11a33:	79 19                	jns    11a4e <kernel_itoa+0x5c>
   11a35:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   11a39:	75 13                	jne    11a4e <kernel_itoa+0x5c>
    {
        *p++ = '-';
   11a3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a3e:	8d 50 01             	lea    0x1(%eax),%edx
   11a41:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11a44:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   11a47:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num)
   11a4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11a52:	74 3b                	je     11a8f <kernel_itoa+0x9d>
    {
        do
        {
            char ch = num2ch[num % base + 15];
   11a54:	8b 0d d8 23 01 00    	mov    0x123d8,%ecx
   11a5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a5d:	99                   	cltd   
   11a5e:	f7 7d 10             	idivl  0x10(%ebp)
   11a61:	89 d0                	mov    %edx,%eax
   11a63:	83 c0 0f             	add    $0xf,%eax
   11a66:	01 c8                	add    %ecx,%eax
   11a68:	0f b6 00             	movzbl (%eax),%eax
   11a6b:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   11a6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a71:	8d 50 01             	lea    0x1(%eax),%edx
   11a74:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11a77:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   11a7b:	88 10                	mov    %dl,(%eax)
            num /= base;
   11a7d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a80:	99                   	cltd   
   11a81:	f7 7d 10             	idivl  0x10(%ebp)
   11a84:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   11a87:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11a8b:	75 c7                	jne    11a54 <kernel_itoa+0x62>
   11a8d:	eb 4b                	jmp    11ada <kernel_itoa+0xe8>
    }
    else
    {
        uint32_t u_num = (uint32_t)num;
   11a8f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a92:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do
        {
            char ch = num2ch[u_num % base + 15];
   11a95:	8b 0d d8 23 01 00    	mov    0x123d8,%ecx
   11a9b:	8b 5d 10             	mov    0x10(%ebp),%ebx
   11a9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11aa1:	ba 00 00 00 00       	mov    $0x0,%edx
   11aa6:	f7 f3                	div    %ebx
   11aa8:	89 d0                	mov    %edx,%eax
   11aaa:	83 c0 0f             	add    $0xf,%eax
   11aad:	01 c8                	add    %ecx,%eax
   11aaf:	0f b6 00             	movzbl (%eax),%eax
   11ab2:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   11ab5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ab8:	8d 50 01             	lea    0x1(%eax),%edx
   11abb:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11abe:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   11ac2:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   11ac4:	8b 5d 10             	mov    0x10(%ebp),%ebx
   11ac7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11aca:	ba 00 00 00 00       	mov    $0x0,%edx
   11acf:	f7 f3                	div    %ebx
   11ad1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   11ad4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11ad8:	75 bb                	jne    11a95 <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   11ada:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11add:	8d 50 ff             	lea    -0x1(%eax),%edx
   11ae0:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11ae3:	c6 00 00             	movb   $0x0,(%eax)

    // 将转换结果逆序，生成最终的结果
    char *start = (!signed_num) ? buf : buf + 1;
   11ae6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11aea:	74 08                	je     11af4 <kernel_itoa+0x102>
   11aec:	8b 45 08             	mov    0x8(%ebp),%eax
   11aef:	83 c0 01             	add    $0x1,%eax
   11af2:	eb 03                	jmp    11af7 <kernel_itoa+0x105>
   11af4:	8b 45 08             	mov    0x8(%ebp),%eax
   11af7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p)
   11afa:	eb 27                	jmp    11b23 <kernel_itoa+0x131>
    {
        char ch = *start;
   11afc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11aff:	0f b6 00             	movzbl (%eax),%eax
   11b02:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   11b05:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b08:	0f b6 10             	movzbl (%eax),%edx
   11b0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b0e:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   11b10:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b13:	8d 50 ff             	lea    -0x1(%eax),%edx
   11b16:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11b19:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   11b1d:	88 10                	mov    %dl,(%eax)
        start++;
   11b1f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p)
   11b23:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b26:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   11b29:	72 d1                	jb     11afc <kernel_itoa+0x10a>
    }
}
   11b2b:	83 c4 20             	add    $0x20,%esp
   11b2e:	5b                   	pop    %ebx
   11b2f:	5d                   	pop    %ebp
   11b30:	c3                   	ret    

00011b31 <kernel_vsprintf>:
// buf 为最终显示的目标
// fmt 为整个字符串
// args 为va_list 可变变量
void kernel_vsprintf(char *buf, const char *fmt, va_list args)
{
   11b31:	55                   	push   %ebp
   11b32:	89 e5                	mov    %esp,%ebp
   11b34:	83 ec 20             	sub    $0x20,%esp
    enum
    {
        NORMAL,
        READ_FMT
    } state = NORMAL;
   11b37:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char ch;
    char *curr = buf;
   11b3e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b41:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while ((ch = *fmt++))
   11b44:	e9 17 01 00 00       	jmp    11c60 <kernel_vsprintf+0x12f>
    {
        switch (state)
   11b49:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b4c:	85 c0                	test   %eax,%eax
   11b4e:	74 0a                	je     11b5a <kernel_vsprintf+0x29>
   11b50:	83 f8 01             	cmp    $0x1,%eax
   11b53:	74 2b                	je     11b80 <kernel_vsprintf+0x4f>
   11b55:	e9 06 01 00 00       	jmp    11c60 <kernel_vsprintf+0x12f>
        {
        // 普通字符
        case NORMAL:
            if (ch == '%')
   11b5a:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   11b5e:	75 0c                	jne    11b6c <kernel_vsprintf+0x3b>
            {
                state = READ_FMT;
   11b60:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   11b67:	e9 f4 00 00 00       	jmp    11c60 <kernel_vsprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   11b6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b6f:	8d 50 01             	lea    0x1(%eax),%edx
   11b72:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11b75:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   11b79:	88 10                	mov    %dl,(%eax)
            }
            break;
   11b7b:	e9 e0 00 00 00       	jmp    11c60 <kernel_vsprintf+0x12f>
        // 格式化控制字符，只支持部分
        case READ_FMT:
            if (ch == 'd')
   11b80:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   11b84:	75 31                	jne    11bb7 <kernel_vsprintf+0x86>
            {
                int num = va_arg(args, int);
   11b86:	8b 45 10             	mov    0x10(%ebp),%eax
   11b89:	8d 50 04             	lea    0x4(%eax),%edx
   11b8c:	89 55 10             	mov    %edx,0x10(%ebp)
   11b8f:	8b 00                	mov    (%eax),%eax
   11b91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr, num, 10);
   11b94:	6a 0a                	push   $0xa
   11b96:	ff 75 e4             	pushl  -0x1c(%ebp)
   11b99:	ff 75 f8             	pushl  -0x8(%ebp)
   11b9c:	e8 51 fe ff ff       	call   119f2 <kernel_itoa>
   11ba1:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr); // 移动到下一个
   11ba4:	ff 75 f8             	pushl  -0x8(%ebp)
   11ba7:	e8 1d fd ff ff       	call   118c9 <kernel_strlen>
   11bac:	83 c4 04             	add    $0x4,%esp
   11baf:	01 45 f8             	add    %eax,-0x8(%ebp)
   11bb2:	e9 a1 00 00 00       	jmp    11c58 <kernel_vsprintf+0x127>
            }
            else if (ch == 'x')
   11bb7:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   11bbb:	75 2e                	jne    11beb <kernel_vsprintf+0xba>
            {
                int num = va_arg(args, int);
   11bbd:	8b 45 10             	mov    0x10(%ebp),%eax
   11bc0:	8d 50 04             	lea    0x4(%eax),%edx
   11bc3:	89 55 10             	mov    %edx,0x10(%ebp)
   11bc6:	8b 00                	mov    (%eax),%eax
   11bc8:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr, num, 16);
   11bcb:	6a 10                	push   $0x10
   11bcd:	ff 75 e8             	pushl  -0x18(%ebp)
   11bd0:	ff 75 f8             	pushl  -0x8(%ebp)
   11bd3:	e8 1a fe ff ff       	call   119f2 <kernel_itoa>
   11bd8:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   11bdb:	ff 75 f8             	pushl  -0x8(%ebp)
   11bde:	e8 e6 fc ff ff       	call   118c9 <kernel_strlen>
   11be3:	83 c4 04             	add    $0x4,%esp
   11be6:	01 45 f8             	add    %eax,-0x8(%ebp)
   11be9:	eb 6d                	jmp    11c58 <kernel_vsprintf+0x127>
            }
            else if (ch == 'c')
   11beb:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   11bef:	75 1f                	jne    11c10 <kernel_vsprintf+0xdf>
            {
                char c = va_arg(args, int);
   11bf1:	8b 45 10             	mov    0x10(%ebp),%eax
   11bf4:	8d 50 04             	lea    0x4(%eax),%edx
   11bf7:	89 55 10             	mov    %edx,0x10(%ebp)
   11bfa:	8b 00                	mov    (%eax),%eax
   11bfc:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = c;
   11bff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c02:	8d 50 01             	lea    0x1(%eax),%edx
   11c05:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11c08:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   11c0c:	88 10                	mov    %dl,(%eax)
   11c0e:	eb 48                	jmp    11c58 <kernel_vsprintf+0x127>
            }
            else if (ch == 's')
   11c10:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   11c14:	75 42                	jne    11c58 <kernel_vsprintf+0x127>
            {
                const char *str = va_arg(args, char *);
   11c16:	8b 45 10             	mov    0x10(%ebp),%eax
   11c19:	8d 50 04             	lea    0x4(%eax),%edx
   11c1c:	89 55 10             	mov    %edx,0x10(%ebp)
   11c1f:	8b 00                	mov    (%eax),%eax
   11c21:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   11c24:	ff 75 f4             	pushl  -0xc(%ebp)
   11c27:	e8 9d fc ff ff       	call   118c9 <kernel_strlen>
   11c2c:	83 c4 04             	add    $0x4,%esp
   11c2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while (len--)
   11c32:	eb 17                	jmp    11c4b <kernel_vsprintf+0x11a>
                {
                    *curr++ = *str++;
   11c34:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c37:	8d 42 01             	lea    0x1(%edx),%eax
   11c3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11c3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c40:	8d 48 01             	lea    0x1(%eax),%ecx
   11c43:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   11c46:	0f b6 12             	movzbl (%edx),%edx
   11c49:	88 10                	mov    %dl,(%eax)
                while (len--)
   11c4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c4e:	8d 50 ff             	lea    -0x1(%eax),%edx
   11c51:	89 55 f0             	mov    %edx,-0x10(%ebp)
   11c54:	85 c0                	test   %eax,%eax
   11c56:	75 dc                	jne    11c34 <kernel_vsprintf+0x103>
                }
            }
            state = NORMAL;
   11c58:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   11c5f:	90                   	nop
    while ((ch = *fmt++))
   11c60:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c63:	8d 50 01             	lea    0x1(%eax),%edx
   11c66:	89 55 0c             	mov    %edx,0xc(%ebp)
   11c69:	0f b6 00             	movzbl (%eax),%eax
   11c6c:	88 45 ef             	mov    %al,-0x11(%ebp)
   11c6f:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   11c73:	0f 85 d0 fe ff ff    	jne    11b49 <kernel_vsprintf+0x18>
        }
    }
}
   11c79:	90                   	nop
   11c7a:	c9                   	leave  
   11c7b:	c3                   	ret    

00011c7c <panic>:

void panic(const char *file, int line, const char *func, const char *cond)
{
   11c7c:	55                   	push   %ebp
   11c7d:	89 e5                	mov    %esp,%ebp
   11c7f:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed! %s", cond);
   11c82:	83 ec 08             	sub    $0x8,%esp
   11c85:	ff 75 14             	pushl  0x14(%ebp)
   11c88:	68 88 23 01 00       	push   $0x12388
   11c8d:	e8 cd 02 00 00       	call   11f5f <log_printf>
   11c92:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline %d\nfunc: %s\n", file, line, func);
   11c95:	ff 75 10             	pushl  0x10(%ebp)
   11c98:	ff 75 0c             	pushl  0xc(%ebp)
   11c9b:	ff 75 08             	pushl  0x8(%ebp)
   11c9e:	68 9a 23 01 00       	push   $0x1239a
   11ca3:	e8 b7 02 00 00       	call   11f5f <log_printf>
   11ca8:	83 c4 10             	add    $0x10,%esp

    for (;;)
    {
        hlt();
   11cab:	e8 dd fa ff ff       	call   1178d <hlt>
   11cb0:	eb f9                	jmp    11cab <panic+0x2f>

00011cb2 <list_is_empty>:
{
   11cb2:	55                   	push   %ebp
   11cb3:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   11cb5:	8b 45 08             	mov    0x8(%ebp),%eax
   11cb8:	8b 40 08             	mov    0x8(%eax),%eax
   11cbb:	85 c0                	test   %eax,%eax
   11cbd:	0f 94 c0             	sete   %al
   11cc0:	0f b6 c0             	movzbl %al,%eax
}
   11cc3:	5d                   	pop    %ebp
   11cc4:	c3                   	ret    

00011cc5 <list_init>:
/**
 * 初始化链表
 * @param list 待初始化的链表
 */
void list_init(list_t *list)
{
   11cc5:	55                   	push   %ebp
   11cc6:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   11cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   11ccb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11cd2:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd5:	8b 50 04             	mov    0x4(%eax),%edx
   11cd8:	8b 45 08             	mov    0x8(%ebp),%eax
   11cdb:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   11cdd:	8b 45 08             	mov    0x8(%ebp),%eax
   11ce0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   11ce7:	90                   	nop
   11ce8:	5d                   	pop    %ebp
   11ce9:	c3                   	ret    

00011cea <list_insert_first>:
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node)
{
   11cea:	55                   	push   %ebp
   11ceb:	89 e5                	mov    %esp,%ebp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
   11ced:	8b 45 08             	mov    0x8(%ebp),%eax
   11cf0:	8b 10                	mov    (%eax),%edx
   11cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cf5:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   11cf8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cfb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list))
   11d01:	ff 75 08             	pushl  0x8(%ebp)
   11d04:	e8 a9 ff ff ff       	call   11cb2 <list_is_empty>
   11d09:	83 c4 04             	add    $0x4,%esp
   11d0c:	85 c0                	test   %eax,%eax
   11d0e:	74 15                	je     11d25 <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   11d10:	8b 45 08             	mov    0x8(%ebp),%eax
   11d13:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d16:	89 10                	mov    %edx,(%eax)
   11d18:	8b 45 08             	mov    0x8(%ebp),%eax
   11d1b:	8b 10                	mov    (%eax),%edx
   11d1d:	8b 45 08             	mov    0x8(%ebp),%eax
   11d20:	89 50 04             	mov    %edx,0x4(%eax)
   11d23:	eb 12                	jmp    11d37 <list_insert_first+0x4d>
    }
    else
    {
        // 否则，设置好原本第一个结点的pre
        list->first->pre = node;
   11d25:	8b 45 08             	mov    0x8(%ebp),%eax
   11d28:	8b 00                	mov    (%eax),%eax
   11d2a:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d2d:	89 10                	mov    %edx,(%eax)

        // 调整first指向
        list->first = node;
   11d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   11d32:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d35:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   11d37:	8b 45 08             	mov    0x8(%ebp),%eax
   11d3a:	8b 40 08             	mov    0x8(%eax),%eax
   11d3d:	8d 50 01             	lea    0x1(%eax),%edx
   11d40:	8b 45 08             	mov    0x8(%ebp),%eax
   11d43:	89 50 08             	mov    %edx,0x8(%eax)
}
   11d46:	90                   	nop
   11d47:	c9                   	leave  
   11d48:	c3                   	ret    

00011d49 <list_insert_last>:
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node)
{
   11d49:	55                   	push   %ebp
   11d4a:	89 e5                	mov    %esp,%ebp
    // 设置好结点本身
    node->pre = list->last;
   11d4c:	8b 45 08             	mov    0x8(%ebp),%eax
   11d4f:	8b 50 04             	mov    0x4(%eax),%edx
   11d52:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d55:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t *)0;
   11d57:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d5a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list))
   11d61:	ff 75 08             	pushl  0x8(%ebp)
   11d64:	e8 49 ff ff ff       	call   11cb2 <list_is_empty>
   11d69:	83 c4 04             	add    $0x4,%esp
   11d6c:	85 c0                	test   %eax,%eax
   11d6e:	74 16                	je     11d86 <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   11d70:	8b 45 08             	mov    0x8(%ebp),%eax
   11d73:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d76:	89 50 04             	mov    %edx,0x4(%eax)
   11d79:	8b 45 08             	mov    0x8(%ebp),%eax
   11d7c:	8b 50 04             	mov    0x4(%eax),%edx
   11d7f:	8b 45 08             	mov    0x8(%ebp),%eax
   11d82:	89 10                	mov    %edx,(%eax)
   11d84:	eb 15                	jmp    11d9b <list_insert_last+0x52>
    }
    else
    {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
   11d86:	8b 45 08             	mov    0x8(%ebp),%eax
   11d89:	8b 40 04             	mov    0x4(%eax),%eax
   11d8c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d8f:	89 50 04             	mov    %edx,0x4(%eax)

        // node变成了新的后继结点
        list->last = node;
   11d92:	8b 45 08             	mov    0x8(%ebp),%eax
   11d95:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d98:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   11d9b:	8b 45 08             	mov    0x8(%ebp),%eax
   11d9e:	8b 40 08             	mov    0x8(%eax),%eax
   11da1:	8d 50 01             	lea    0x1(%eax),%edx
   11da4:	8b 45 08             	mov    0x8(%ebp),%eax
   11da7:	89 50 08             	mov    %edx,0x8(%eax)
}
   11daa:	90                   	nop
   11dab:	c9                   	leave  
   11dac:	c3                   	ret    

00011dad <list_remove_first>:
 * 移除指定链表的头部
 * @param list 操作的链表
 * @return 链表的第一个结点
 */
list_node_t *list_remove_first(list_t *list)
{
   11dad:	55                   	push   %ebp
   11dae:	89 e5                	mov    %esp,%ebp
   11db0:	83 ec 10             	sub    $0x10,%esp
    // 表项为空，返回空
    if (list_is_empty(list))
   11db3:	ff 75 08             	pushl  0x8(%ebp)
   11db6:	e8 f7 fe ff ff       	call   11cb2 <list_is_empty>
   11dbb:	83 c4 04             	add    $0x4,%esp
   11dbe:	85 c0                	test   %eax,%eax
   11dc0:	74 07                	je     11dc9 <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   11dc2:	b8 00 00 00 00       	mov    $0x0,%eax
   11dc7:	eb 5a                	jmp    11e23 <list_remove_first+0x76>
    }

    // 取第一个结点
    list_node_t *remove_node = list->first;
   11dc9:	8b 45 08             	mov    0x8(%ebp),%eax
   11dcc:	8b 00                	mov    (%eax),%eax
   11dce:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 将first往表尾移1个，跳过刚才移过的那个，如果没有后继，则first=0
    list->first = remove_node->next;
   11dd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11dd4:	8b 50 04             	mov    0x4(%eax),%edx
   11dd7:	8b 45 08             	mov    0x8(%ebp),%eax
   11dda:	89 10                	mov    %edx,(%eax)
    if (list->first == (list_node_t *)0)
   11ddc:	8b 45 08             	mov    0x8(%ebp),%eax
   11ddf:	8b 00                	mov    (%eax),%eax
   11de1:	85 c0                	test   %eax,%eax
   11de3:	75 0c                	jne    11df1 <list_remove_first+0x44>
    {
        // node为最后一个结点
        list->last = (list_node_t *)0;
   11de5:	8b 45 08             	mov    0x8(%ebp),%eax
   11de8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11def:	eb 0c                	jmp    11dfd <list_remove_first+0x50>
    }
    else
    {
        // 非最后一结点，将后继的前驱清0
        remove_node->next->pre = (list_node_t *)0;
   11df1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11df4:	8b 40 04             	mov    0x4(%eax),%eax
   11df7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

    // 调整node自己，置0，因为没有后继结点
    remove_node->next = remove_node->pre = (list_node_t *)0;
   11dfd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11e00:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11e06:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11e09:	8b 10                	mov    (%eax),%edx
   11e0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11e0e:	89 50 04             	mov    %edx,0x4(%eax)

    // 同时调整计数值
    list->count--;
   11e11:	8b 45 08             	mov    0x8(%ebp),%eax
   11e14:	8b 40 08             	mov    0x8(%eax),%eax
   11e17:	8d 50 ff             	lea    -0x1(%eax),%edx
   11e1a:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1d:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   11e20:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11e23:	c9                   	leave  
   11e24:	c3                   	ret    

00011e25 <list_remove>:
/**
 * 移除指定链表的中的表项
 * 不检查node是否在结点中
 */
list_node_t *list_remove(list_t *list, list_node_t *remove_node)
{
   11e25:	55                   	push   %ebp
   11e26:	89 e5                	mov    %esp,%ebp
    // 如果是头，头往前移
    if (remove_node == list->first)
   11e28:	8b 45 08             	mov    0x8(%ebp),%eax
   11e2b:	8b 00                	mov    (%eax),%eax
   11e2d:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11e30:	75 0b                	jne    11e3d <list_remove+0x18>
    {
        list->first = remove_node->next;
   11e32:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e35:	8b 50 04             	mov    0x4(%eax),%edx
   11e38:	8b 45 08             	mov    0x8(%ebp),%eax
   11e3b:	89 10                	mov    %edx,(%eax)
    }

    // 如果是尾，则尾往回移
    if (remove_node == list->last)
   11e3d:	8b 45 08             	mov    0x8(%ebp),%eax
   11e40:	8b 40 04             	mov    0x4(%eax),%eax
   11e43:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11e46:	75 0b                	jne    11e53 <list_remove+0x2e>
    {
        list->last = remove_node->pre;
   11e48:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e4b:	8b 10                	mov    (%eax),%edx
   11e4d:	8b 45 08             	mov    0x8(%ebp),%eax
   11e50:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有前，则调整前的后继
    if (remove_node->pre)
   11e53:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e56:	8b 00                	mov    (%eax),%eax
   11e58:	85 c0                	test   %eax,%eax
   11e5a:	74 0e                	je     11e6a <list_remove+0x45>
    {
        remove_node->pre->next = remove_node->next;
   11e5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e5f:	8b 00                	mov    (%eax),%eax
   11e61:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e64:	8b 52 04             	mov    0x4(%edx),%edx
   11e67:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有后，则调整后往前的
    if (remove_node->next)
   11e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e6d:	8b 40 04             	mov    0x4(%eax),%eax
   11e70:	85 c0                	test   %eax,%eax
   11e72:	74 0d                	je     11e81 <list_remove+0x5c>
    {
        remove_node->next->pre = remove_node->pre;
   11e74:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e77:	8b 40 04             	mov    0x4(%eax),%eax
   11e7a:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e7d:	8b 12                	mov    (%edx),%edx
   11e7f:	89 10                	mov    %edx,(%eax)
    }

    // 清空node指向
    remove_node->pre = remove_node->next = (list_node_t *)0;
   11e81:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e84:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11e8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e8e:	8b 50 04             	mov    0x4(%eax),%edx
   11e91:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e94:	89 10                	mov    %edx,(%eax)
    --list->count;
   11e96:	8b 45 08             	mov    0x8(%ebp),%eax
   11e99:	8b 40 08             	mov    0x8(%eax),%eax
   11e9c:	8d 50 ff             	lea    -0x1(%eax),%edx
   11e9f:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea2:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   11ea5:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   11ea8:	5d                   	pop    %ebp
   11ea9:	c3                   	ret    

00011eaa <inb>:
{
   11eaa:	55                   	push   %ebp
   11eab:	89 e5                	mov    %esp,%ebp
   11ead:	83 ec 14             	sub    $0x14,%esp
   11eb0:	8b 45 08             	mov    0x8(%ebp),%eax
   11eb3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   11eb7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   11ebb:	89 c2                	mov    %eax,%edx
   11ebd:	ec                   	in     (%dx),%al
   11ebe:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   11ec1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   11ec5:	c9                   	leave  
   11ec6:	c3                   	ret    

00011ec7 <outb>:
{
   11ec7:	55                   	push   %ebp
   11ec8:	89 e5                	mov    %esp,%ebp
   11eca:	83 ec 08             	sub    $0x8,%esp
   11ecd:	8b 55 08             	mov    0x8(%ebp),%edx
   11ed0:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ed3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   11ed7:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" ::[p] "d"(port), [v] "a"(data));
   11eda:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   11ede:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   11ee2:	ee                   	out    %al,(%dx)
}
   11ee3:	90                   	nop
   11ee4:	c9                   	leave  
   11ee5:	c3                   	ret    

00011ee6 <log_init>:
#define COM1_PORT 0x3F8 // RS232端口0初始化

static mutex_t mutex;

void log_init(void)
{
   11ee6:	55                   	push   %ebp
   11ee7:	89 e5                	mov    %esp,%ebp
   11ee9:	83 ec 08             	sub    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); // Disable all interrupts
   11eec:	6a 00                	push   $0x0
   11eee:	68 f9 03 00 00       	push   $0x3f9
   11ef3:	e8 cf ff ff ff       	call   11ec7 <outb>
   11ef8:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor)
   11efb:	68 80 00 00 00       	push   $0x80
   11f00:	68 fb 03 00 00       	push   $0x3fb
   11f05:	e8 bd ff ff ff       	call   11ec7 <outb>
   11f0a:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud
   11f0d:	6a 03                	push   $0x3
   11f0f:	68 f8 03 00 00       	push   $0x3f8
   11f14:	e8 ae ff ff ff       	call   11ec7 <outb>
   11f19:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 1, 0x00); //                  (hi byte)
   11f1c:	6a 00                	push   $0x0
   11f1e:	68 f9 03 00 00       	push   $0x3f9
   11f23:	e8 9f ff ff ff       	call   11ec7 <outb>
   11f28:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 3, 0x03); // 8 bits, no parity, one stop bit
   11f2b:	6a 03                	push   $0x3
   11f2d:	68 fb 03 00 00       	push   $0x3fb
   11f32:	e8 90 ff ff ff       	call   11ec7 <outb>
   11f37:	83 c4 08             	add    $0x8,%esp
    outb(COM1_PORT + 2, 0xC7); // Enable FIFO, clear them, with 14-byte threshold
   11f3a:	68 c7 00 00 00       	push   $0xc7
   11f3f:	68 fa 03 00 00       	push   $0x3fa
   11f44:	e8 7e ff ff ff       	call   11ec7 <outb>
   11f49:	83 c4 08             	add    $0x8,%esp
    mutex_init(&mutex);
   11f4c:	83 ec 0c             	sub    $0xc,%esp
   11f4f:	68 90 52 01 00       	push   $0x15290
   11f54:	e8 71 f5 ff ff       	call   114ca <mutex_init>
   11f59:	83 c4 10             	add    $0x10,%esp
}
   11f5c:	90                   	nop
   11f5d:	c9                   	leave  
   11f5e:	c3                   	ret    

00011f5f <log_printf>:

void log_printf(const char *fmt, ...)
{
   11f5f:	55                   	push   %ebp
   11f60:	89 e5                	mov    %esp,%ebp
   11f62:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf, '\0', sizeof(str_buf));
   11f68:	83 ec 04             	sub    $0x4,%esp
   11f6b:	68 80 00 00 00       	push   $0x80
   11f70:	6a 00                	push   $0x0
   11f72:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11f78:	50                   	push   %eax
   11f79:	e8 d5 f9 ff ff       	call   11953 <kernel_memset>
   11f7e:	83 c4 10             	add    $0x10,%esp
    va_start(args, fmt);
   11f81:	8d 45 0c             	lea    0xc(%ebp),%eax
   11f84:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    kernel_vsprintf(str_buf, fmt, args);
   11f8a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
   11f90:	83 ec 04             	sub    $0x4,%esp
   11f93:	50                   	push   %eax
   11f94:	ff 75 08             	pushl  0x8(%ebp)
   11f97:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11f9d:	50                   	push   %eax
   11f9e:	e8 8e fb ff ff       	call   11b31 <kernel_vsprintf>
   11fa3:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    // 临界区进入
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   11fa6:	83 ec 0c             	sub    $0xc,%esp
   11fa9:	68 90 52 01 00       	push   $0x15290
   11fae:	e8 45 f5 ff ff       	call   114f8 <mutex_lock>
   11fb3:	83 c4 10             	add    $0x10,%esp
    const char *p = str_buf;
   11fb6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11fbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != '\0')
   11fbf:	eb 3b                	jmp    11ffc <log_printf+0x9d>
    {
        // 检查串口是否忙
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0)
   11fc1:	90                   	nop
   11fc2:	83 ec 0c             	sub    $0xc,%esp
   11fc5:	68 fd 03 00 00       	push   $0x3fd
   11fca:	e8 db fe ff ff       	call   11eaa <inb>
   11fcf:	83 c4 10             	add    $0x10,%esp
   11fd2:	0f b6 c0             	movzbl %al,%eax
   11fd5:	83 e0 40             	and    $0x40,%eax
   11fd8:	85 c0                	test   %eax,%eax
   11fda:	74 e6                	je     11fc2 <log_printf+0x63>
        {
        }
        outb(COM1_PORT, *p++);
   11fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fdf:	8d 50 01             	lea    0x1(%eax),%edx
   11fe2:	89 55 f4             	mov    %edx,-0xc(%ebp)
   11fe5:	0f b6 00             	movzbl (%eax),%eax
   11fe8:	0f b6 c0             	movzbl %al,%eax
   11feb:	83 ec 08             	sub    $0x8,%esp
   11fee:	50                   	push   %eax
   11fef:	68 f8 03 00 00       	push   $0x3f8
   11ff4:	e8 ce fe ff ff       	call   11ec7 <outb>
   11ff9:	83 c4 10             	add    $0x10,%esp
    while (*p != '\0')
   11ffc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fff:	0f b6 00             	movzbl (%eax),%eax
   12002:	84 c0                	test   %al,%al
   12004:	75 bb                	jne    11fc1 <log_printf+0x62>
    }
    // 增加默认换行
    outb(COM1_PORT, '\r'); // 行号不变，列号归零
   12006:	83 ec 08             	sub    $0x8,%esp
   12009:	6a 0d                	push   $0xd
   1200b:	68 f8 03 00 00       	push   $0x3f8
   12010:	e8 b2 fe ff ff       	call   11ec7 <outb>
   12015:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT, '\n'); // 列号不变，行号+1
   12018:	83 ec 08             	sub    $0x8,%esp
   1201b:	6a 0a                	push   $0xa
   1201d:	68 f8 03 00 00       	push   $0x3f8
   12022:	e8 a0 fe ff ff       	call   11ec7 <outb>
   12027:	83 c4 10             	add    $0x10,%esp
    // irq_leave_protection(state); // 临界区退出
    mutex_unlock(&mutex);
   1202a:	83 ec 0c             	sub    $0xc,%esp
   1202d:	68 90 52 01 00       	push   $0x15290
   12032:	e8 55 f5 ff ff       	call   1158c <mutex_unlock>
   12037:	83 c4 10             	add    $0x10,%esp
   1203a:	90                   	nop
   1203b:	c9                   	leave  
   1203c:	c3                   	ret    
